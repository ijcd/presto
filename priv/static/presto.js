(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["Presto"] = factory();
	else
		root["Presto"] = factory();
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./js/presto.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./js/presto.js":
/*!**********************!*\
  !*** ./js/presto.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n* Presto JavaScript client\n*\n* ## Setup\n*\n* Presto needs a Phoenix channel to communiacate on. It also needs a\n* reference to an Unpoly object for DOM manipulation.\n*\n* ```javascript\n*     import \"presto\"\n*     import unpoly from \"unpoly/dist/unpoly.js\"\n*\n*     let presto = new Presto(channel, up);\n* ```\n*\n* @module presto\n*/\n\n// import $ from 'cash-dom'\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Presto = exports.Component = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _unpoly = __webpack_require__(/*! unpoly */ \"./node_modules/unpoly/dist/unpoly.js\");\n\nvar _unpoly2 = _interopRequireDefault(_unpoly);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n// up.log.enable();\n\nvar Component = exports.Component = function () {\n  function Component() {\n    _classCallCheck(this, Component);\n  }\n\n  _createClass(Component, null, [{\n    key: 'scan',\n\n\n    /**\n     * returns a map, indexing .presto.component-instance elements\n     * by their corresponding .presto-component#id (component-id)\n     */\n    value: function scan() {\n      var m = new Map();\n\n      // find all component instances in the page\n      var elements = document.querySelectorAll('.presto-component-instance');\n      Array.prototype.forEach.call(elements, function (pci, i) {\n        // find the component for this instance (should only be one)\n        var pcc = pci.querySelector('.presto-component');\n\n        // get the current instance set, initializing if not yet found\n        var instances = m.get(pcc.id);\n        if (!instances) {\n          instances = new Set();\n        }\n\n        // add instance to instances set, \n        instances.add(pci.id);\n        m.set(pcc.id, instances);\n      });\n\n      return m;\n    }\n  }, {\n    key: 'update',\n    value: function update(componentId, content) {\n      var focused = document.activeElement;\n      try {\n        Component.doUpdate(componentId, content);\n      } finally {\n        focused.focus();\n      }\n    }\n  }, {\n    key: 'doUpdate',\n    value: function doUpdate(componentId, content) {\n      // TODO: implement this by listening for DOM mutation events instead (don't scan every time)\n      var components = Component.scan();\n      var instances = components.get(componentId);\n\n      switch (instances) {\n        case undefined:\n          console.warn(\"[Presto] Ignoring request to update unknown componentId: \" + componentId);\n          break;\n        default:\n          var _iteratorNormalCompletion = true;\n          var _didIteratorError = false;\n          var _iteratorError = undefined;\n\n          try {\n            for (var _iterator = components.get(componentId)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n              var instanceId = _step.value;\n\n              var decorated = '<div class=\"presto-component-instance\" id=\"' + instanceId + '\">' + content + '</div>';\n              up.extract('div.presto-component-instance#' + instanceId, decorated);\n            }\n          } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion && _iterator.return) {\n                _iterator.return();\n              }\n            } finally {\n              if (_didIteratorError) {\n                throw _iteratorError;\n              }\n            }\n          }\n\n      }\n    }\n  }]);\n\n  return Component;\n}();\n\n// https://stackoverflow.com/questions/9368538/getting-an-array-of-all-dom-events-possible\n\n\nfunction allEventNames() {\n  return Object.getOwnPropertyNames(document).concat(Object.getOwnPropertyNames(Object.getPrototypeOf(Object.getPrototypeOf(document)))).concat(Object.getOwnPropertyNames(Object.getPrototypeOf(window))).filter(function (i) {\n    return !i.indexOf(\"on\") && (document[i] == null || typeof document[i] == \"function\");\n  }).filter(function (elem, pos, self) {\n    return self.indexOf(elem) == pos;\n  });\n}\n\nvar Presto = exports.Presto = function () {\n  function Presto() {\n    _classCallCheck(this, Presto);\n\n    this.callbacks = {\n      onEvent: [],\n      preUpdate: [],\n      postUpdate: []\n    };\n    this.eventNamespace = '.presto';\n\n    this.allEventNames = allEventNames().map(function (name) {\n      return name.replace(/^on/, '');\n    });\n  }\n\n  _createClass(Presto, [{\n    key: 'bindEvents',\n    value: function bindEvents() {\n      var _this = this;\n\n      var self = this;\n\n      // Attach a delegated event handler\n      this.allEventNames.forEach(function (eventName) {\n        var prestoClass = '.presto-' + eventName;\n        var namespacedName = eventName + _this.eventNamespace;\n\n        // events attached to internal elements\n        $('body').on(namespacedName, prestoClass, function (event) {\n          var prestoEvent = self.prepareEvent(event);\n          self.runEventHooks(prestoEvent);\n        });\n\n        // events attached to the body\n        $('body' + prestoClass).on(namespacedName, function (event) {\n          var prestoEvent = self.prepareEvent(event);\n          self.runEventHooks(prestoEvent);\n        });\n      });\n    }\n  }, {\n    key: 'unbindEvents',\n    value: function unbindEvents() {\n      $('body').off(self.eventNamespace);\n    }\n  }, {\n    key: 'onEvent',\n    value: function onEvent(callback) {\n      this.callbacks.onEvent.push(callback);\n    }\n  }, {\n    key: 'onPreUpdate',\n    value: function onPreUpdate(callback) {\n      this.callbacks.preUpdate.push(callback);\n    }\n  }, {\n    key: 'onPostUpdate',\n    value: function onPostUpdate(callback) {\n      this.callbacks.postUpdate.push(callback);\n    }\n  }, {\n    key: 'runEventHooks',\n    value: function runEventHooks(payload) {\n      this.callbacks.onEvent.forEach(function (callback) {\n        return callback(payload);\n      });\n    }\n  }, {\n    key: 'runPreUpdateHooks',\n    value: function runPreUpdateHooks(payload) {\n      this.callbacks.preUpdate.forEach(function (callback) {\n        return callback(payload);\n      });\n    }\n  }, {\n    key: 'runPostUpdateHooks',\n    value: function runPostUpdateHooks(payload) {\n      this.callbacks.postUpdate.forEach(function (callback) {\n        return callback(payload);\n      });\n    }\n\n    // this.channel.on(\"presto\", payload => {\n    //   console.log(\"RECEIVED\", payload)\n    //   self.handleCommand(payload)\n    // }\n\n  }, {\n    key: 'handleCommand',\n    value: function handleCommand(payload) {\n      var name = payload.name;\n\n      switch (name) {\n        case \"update_component\":\n          {\n            this.runPreUpdateHooks(payload);\n            this.handleCommandUpdateComponent(payload);\n            this.runPostUpdateHooks(payload);\n            break;\n          }\n        default:\n          this.handleCommandUnknown(payload);\n      }\n    }\n  }, {\n    key: 'handleCommandUpdateComponent',\n    value: function handleCommandUpdateComponent(payload) {\n      var componentId = payload.componentId,\n          content = payload.content;\n\n      Component.update(componentId, content);\n    }\n  }, {\n    key: 'handleCommandUnknown',\n    value: function handleCommandUnknown(payload) {\n      console.warn(\"[Presto] Unable to handle payload: \", payload);\n    }\n  }, {\n    key: 'prepareEvent',\n    value: function prepareEvent(event) {\n      var $elem = $(event.target);\n\n      var $instance = $elem.parents(\".presto-component-instance\").toArray().reverse()[0];\n      var $component = $elem.parents(\".presto-component\").toArray().reverse()[0];\n\n      var prestoEvent = {\n        element: $elem.prop('tagName'),\n        domEvent: event,\n        attrs: $elem.attr(),\n        id: $elem.prop('id'),\n        instanceId: $instance && $instance.id,\n        componentId: $component && $component.id\n      };\n\n      return prestoEvent;\n    }\n  }]);\n\n  return Presto;\n}();\n\n// Extend jQuery with attr()\n\n\n(function (old) {\n  $.fn.attr = function () {\n    if (arguments.length === 0) {\n      if (this.length === 0) {\n        return null;\n      }\n\n      var obj = {};\n      $.each(this[0].attributes, function () {\n        if (this.specified) {\n          obj[this.name] = this.value;\n        }\n      });\n      return obj;\n    }\n\n    return old.apply(this, arguments);\n  };\n})($.fn.attr);\n\n//# sourceURL=webpack://Presto/./js/presto.js?");

/***/ }),

/***/ "./node_modules/unpoly/dist/unpoly.js":
/*!********************************************!*\
  !*** ./node_modules/unpoly/dist/unpoly.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("\n/***\n@module up\n */\n\n(function() {\n  window.up = {\n    version: \"0.57.0\",\n    deprecateRenamedModule: function(oldName, newName) {\n      return typeof Object.defineProperty === \"function\" ? Object.defineProperty(up, oldName, {\n        get: function() {\n          up.warn(\"Deprecated: up.\" + oldName + \" has been renamed to up.\" + newName);\n          return up[newName];\n        }\n      }) : void 0;\n    }\n  };\n\n}).call(this);\n\n/***\nUtility functions\n=================\n  \nUnpoly comes with a number of utility functions\nthat might save you from loading something like [Lodash](https://lodash.com/).\n\n@class up.util\n */\n\n(function() {\n  var slice = [].slice,\n    hasProp = {}.hasOwnProperty,\n    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };\n\n  up.util = (function($) {\n\n    /***\n    A function that does nothing.\n    \n    @function up.util.noop\n    @experimental\n     */\n    var $createElementFromSelector, $createPlaceholder, CASE_CONVERSION_GROUP, CSS_LENGTH_PROPS, DivertibleChain, ESCAPE_HTML_ENTITY_MAP, addClass, addTemporaryClass, all, always, any, arrayToSet, assign, assignPolyfill, asyncNoop, attributeSelector, camelCase, camelCaseKeys, castedAttr, changeClassList, clientSize, compact, concludeCssTransition, config, contains, convertCase, copy, copyAttributes, copyWithRenamedKeys, createElementFromHtml, cssLength, deprecateRenamedKey, detachWith, detect, documentHasVerticalScrollbar, each, eachIterator, elementTagName, escapeHtml, escapePressed, evalOption, except, extractFromStyleObject, extractOptions, fail, fixedToAbsolute, flatMap, flatten, forceRepaint, getElement, hasClass, hasCssTransition, hide, horizontalScreenHalf, identity, intersect, isArray, isBasicObjectProperty, isBlank, isBodyDescendant, isBoolean, isCrossDomain, isDefined, isDetached, isElement, isEqual, isFixed, isFormData, isFunction, isGiven, isJQuery, isMissing, isNull, isNumber, isObject, isOptions, isPresent, isPromise, isSingletonElement, isStandardPort, isString, isTruthy, isUndefined, isUnmodifiedKeyEvent, isUnmodifiedMouseEvent, jsonAttr, kebabCase, kebabCaseKeys, last, listBlock, map, margins, measure, memoize, merge, methodAllowsPayload, microtask, muteRejection, newDeferred, newOptions, nextFrame, nonUpClasses, noop, normalizeMethod, normalizeStyleValueForWrite, normalizeUrl, nullJQuery, objectValues, offsetParent, only, opacity, openConfig, option, parseUrl, pluckData, pluckKey, presence, presentAttr, previewable, promiseTimer, readComputedStyle, readComputedStyleNumber, readInlineStyle, reject, rejectOnError, remove, removeClass, renameKey, scrollbarWidth, select, selectInDynasty, selectInSubtree, selectorForElement, sequence, setMissingAttrs, setTimer, setToArray, splitValues, submittedValue, sum, times, toArray, trim, uniq, uniqBy, unresolvablePromise, unwrapElement, valuesPolyfill, whenReady, writeInlineStyle, writeTemporaryStyle;\n    noop = (function() {});\n\n    /***\n    A function that returns a resolved promise.\n    \n    @function up.util.asyncNoop\n    @internal\n     */\n    asyncNoop = function() {\n      return Promise.resolve();\n    };\n\n    /***\n    Ensures that the given function can only be called a single time.\n    Subsequent calls will return the return value of the first call.\n    \n    Note that this is a simple implementation that\n    doesn't distinguish between argument lists.\n    \n    @function up.util.memoize\n    @internal\n     */\n    memoize = function(func) {\n      var cached, cachedValue;\n      cachedValue = void 0;\n      cached = false;\n      return function() {\n        var args;\n        args = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n        if (cached) {\n          return cachedValue;\n        } else {\n          cached = true;\n          return cachedValue = func.apply(null, args);\n        }\n      };\n    };\n\n    /***\n    Returns if the given port is the default port for the given protocol.\n    \n    @function up.util.isStandardPort\n    @internal\n     */\n    isStandardPort = function(protocol, port) {\n      port = port.toString();\n      return ((port === \"\" || port === \"80\") && protocol === 'http:') || (port === \"443\" && protocol === 'https:');\n    };\n\n    /***\n    Normalizes relative paths and absolute paths to a full URL\n    that can be checked for equality with other normalized URLs.\n    \n    By default hashes are ignored, search queries are included.\n    \n    @function up.util.normalizeUrl\n    @param {boolean} [options.hash=false]\n      Whether to include an `#hash` anchor in the normalized URL\n    @param {boolean} [options.search=true]\n      Whether to include a `?query` string in the normalized URL\n    @param {boolean} [options.stripTrailingSlash=false]\n      Whether to strip a trailing slash from the pathname\n    @internal\n     */\n    normalizeUrl = function(urlOrAnchor, options) {\n      var normalized, parts, pathname;\n      parts = parseUrl(urlOrAnchor);\n      normalized = parts.protocol + \"//\" + parts.hostname;\n      if (!isStandardPort(parts.protocol, parts.port)) {\n        normalized += \":\" + parts.port;\n      }\n      pathname = parts.pathname;\n      if (pathname[0] !== '/') {\n        pathname = \"/\" + pathname;\n      }\n      if ((options != null ? options.stripTrailingSlash : void 0) === true) {\n        pathname = pathname.replace(/\\/$/, '');\n      }\n      normalized += pathname;\n      if ((options != null ? options.search : void 0) !== false) {\n        normalized += parts.search;\n      }\n      if ((options != null ? options.hash : void 0) === true) {\n        normalized += parts.hash;\n      }\n      return normalized;\n    };\n    isCrossDomain = function(targetUrl) {\n      var currentUrl;\n      currentUrl = parseUrl(location.href);\n      targetUrl = parseUrl(targetUrl);\n      return currentUrl.protocol !== targetUrl.protocol || currentUrl.host !== targetUrl.host;\n    };\n\n    /***\n    Parses the given URL into components such as hostname and path.\n    \n    If the given URL is not fully qualified, it is assumed to be relative\n    to the current page.\n    \n    @function up.util.parseUrl\n    @return {Object}\n      The parsed URL as an object with\n      `protocol`, `hostname`, `port`, `pathname`, `search` and `hash`\n      properties.\n    @experimental\n     */\n    parseUrl = function(urlOrAnchor) {\n      var anchor;\n      if (isJQuery(urlOrAnchor)) {\n        urlOrAnchor = getElement(urlOrAnchor);\n      }\n      if (urlOrAnchor.pathname) {\n        return urlOrAnchor;\n      }\n      anchor = $('<a>').attr({\n        href: urlOrAnchor\n      }).get(0);\n      if (isBlank(anchor.hostname)) {\n        anchor.href = anchor.href;\n      }\n      return anchor;\n    };\n\n    /***\n    @function up.util.normalizeMethod\n    @internal\n     */\n    normalizeMethod = function(method) {\n      if (method) {\n        return method.toUpperCase();\n      } else {\n        return 'GET';\n      }\n    };\n\n    /***\n    @function up.util.methodAllowsPayload\n    @internal\n     */\n    methodAllowsPayload = function(method) {\n      return method !== 'GET' && method !== 'HEAD';\n    };\n\n    /***\n    @function $createElementFromSelector\n    @internal\n     */\n    $createElementFromSelector = function(selector) {\n      var $element, $parent, $root, classes, conjunction, depthSelector, expression, html, id, iteration, j, l, len, len1, path, tag;\n      path = selector.split(/[ >]/);\n      $root = null;\n      for (iteration = j = 0, len = path.length; j < len; iteration = ++j) {\n        depthSelector = path[iteration];\n        conjunction = depthSelector.match(/(^|\\.|\\#)[A-Za-z0-9\\-_]+/g);\n        tag = \"div\";\n        classes = [];\n        id = null;\n        for (l = 0, len1 = conjunction.length; l < len1; l++) {\n          expression = conjunction[l];\n          switch (expression[0]) {\n            case \".\":\n              classes.push(expression.substr(1));\n              break;\n            case \"#\":\n              id = expression.substr(1);\n              break;\n            default:\n              tag = expression;\n          }\n        }\n        html = \"<\" + tag;\n        if (classes.length) {\n          html += \" class=\\\"\" + classes.join(\" \") + \"\\\"\";\n        }\n        if (id) {\n          html += \" id=\\\"\" + id + \"\\\"\";\n        }\n        html += \">\";\n        $element = $(html);\n        if ($parent) {\n          $element.appendTo($parent);\n        }\n        if (iteration === 0) {\n          $root = $element;\n        }\n        $parent = $element;\n      }\n      return $root;\n    };\n\n    /***\n    @function $createPlaceHolder\n    @internal\n     */\n    $createPlaceholder = function(selector, container) {\n      var $placeholder;\n      if (container == null) {\n        container = document.body;\n      }\n      $placeholder = $createElementFromSelector(selector);\n      $placeholder.addClass('up-placeholder');\n      $placeholder.appendTo(container);\n      return $placeholder;\n    };\n\n    /***\n    Returns a CSS selector that matches the given element as good as possible.\n    \n    This uses, in decreasing order of priority:\n    \n    - The element's `up-id` attribute\n    - The element's ID\n    - The element's name\n    - The element's classes\n    - The element's tag names\n    \n    @function up.util.selectorForElement\n    @param {string|Element|jQuery}\n      The element for which to create a selector.\n    @experimental\n     */\n    selectorForElement = function(element) {\n      var $element, ariaLabel, classes, id, j, klass, len, name, selector, upId;\n      $element = $(element);\n      selector = void 0;\n      if (isSingletonElement($element)) {\n        selector = elementTagName($element);\n      } else if (upId = presence($element.attr(\"up-id\"))) {\n        selector = attributeSelector('up-id', upId);\n      } else if (id = presence($element.attr(\"id\"))) {\n        if (id.match(/^[a-z0-9\\-_]+$/i)) {\n          selector = \"#\" + id;\n        } else {\n          selector = attributeSelector('id', id);\n        }\n      } else if (name = presence($element.attr(\"name\"))) {\n        selector = elementTagName($element) + attributeSelector('name', name);\n      } else if (classes = presence(nonUpClasses($element))) {\n        selector = '';\n        for (j = 0, len = classes.length; j < len; j++) {\n          klass = classes[j];\n          selector += \".\" + klass;\n        }\n      } else if (ariaLabel = presence($element.attr(\"aria-label\"))) {\n        selector = attributeSelector('aria-label', ariaLabel);\n      } else {\n        selector = elementTagName($element);\n      }\n      return selector;\n    };\n    isSingletonElement = function($element) {\n      return $element.is('html, body, head, title');\n    };\n    elementTagName = function($element) {\n      return $element.prop('tagName').toLowerCase();\n    };\n    attributeSelector = function(attribute, value) {\n      value = value.replace(/\"/g, '\\\\\"');\n      return \"[\" + attribute + \"=\\\"\" + value + \"\\\"]\";\n    };\n    nonUpClasses = function($element) {\n      var classString, classes;\n      classString = $element.attr('class') || '';\n      classes = splitValues(classString);\n      return reject(classes, function(klass) {\n        return klass.match(/^up-/);\n      });\n    };\n    createElementFromHtml = function(html) {\n      var parser;\n      parser = new DOMParser();\n      return parser.parseFromString(html, 'text/html');\n    };\n    assignPolyfill = function() {\n      var j, key, len, source, sources, target, value;\n      target = arguments[0], sources = 2 <= arguments.length ? slice.call(arguments, 1) : [];\n      for (j = 0, len = sources.length; j < len; j++) {\n        source = sources[j];\n        for (key in source) {\n          if (!hasProp.call(source, key)) continue;\n          value = source[key];\n          target[key] = value;\n        }\n      }\n      return target;\n    };\n\n    /***\n    Merge the own properties of one or more `sources` into the `target` object.\n    \n    @function up.util.assign\n    @param {Object} target\n    @param {Array<Object>} sources...\n    @stable\n     */\n    assign = Object.assign || assignPolyfill;\n    valuesPolyfill = function(object) {\n      var key, results, value;\n      results = [];\n      for (key in object) {\n        value = object[key];\n        results.push(value);\n      }\n      return results;\n    };\n\n    /***\n    Returns an array of values of the given object.\n    \n    @function up.util.values\n    @param {Object} object\n    @return {Array<string>}\n    @experimental\n     */\n    objectValues = Object.values || valuesPolyfill;\n\n    /***\n    Returns a new string with whitespace removed from the beginning\n    and end of the given string.\n    \n    @param {string}\n      A string that might have whitespace at the beginning and end.\n    @return {string}\n      The trimmed string.\n    @stable\n     */\n    trim = $.trim;\n    listBlock = function(block) {\n      if (isString(block)) {\n        return function(item) {\n          return item[block];\n        };\n      } else {\n        return block;\n      }\n    };\n\n    /***\n    Translate all items in an array to new array of items.\n    \n    @function up.util.map\n    @param {Array<T>} array\n    @param {Function(T, number): any|String} block\n      A function that will be called with each element and (optional) iteration index.\n    \n      You can also pass a property name as a String,\n      which will be collected from each item in the array.\n    @return {Array}\n      A new array containing the result of each function call.\n    @stable\n     */\n    map = function(array, block) {\n      var index, item, j, len, results;\n      if (array.length === 0) {\n        return [];\n      }\n      block = listBlock(block);\n      results = [];\n      for (index = j = 0, len = array.length; j < len; index = ++j) {\n        item = array[index];\n        results.push(block(item, index));\n      }\n      return results;\n    };\n\n    /***\n    Calls the given function for each element (and, optional, index)\n    of the given array.\n    \n    @function up.util.each\n    @param {Array<T>} array\n    @param {Function(T, number)} block\n      A function that will be called with each element and (optional) iteration index.\n    @stable\n     */\n    each = map;\n    eachIterator = function(iterator, callback) {\n      var entry, results;\n      results = [];\n      while ((entry = iterator.next()) && !entry.done) {\n        results.push(callback(entry.value));\n      }\n      return results;\n    };\n\n    /***\n    Calls the given function for the given number of times.\n    \n    @function up.util.times\n    @param {number} count\n    @param {Function} block\n    @stable\n     */\n    times = function(count, block) {\n      var iteration, j, ref, results;\n      results = [];\n      for (iteration = j = 0, ref = count - 1; 0 <= ref ? j <= ref : j >= ref; iteration = 0 <= ref ? ++j : --j) {\n        results.push(block(iteration));\n      }\n      return results;\n    };\n\n    /***\n    Returns whether the given argument is `null`.\n    \n    @function up.util.isNull\n    @param object\n    @return {boolean}\n    @stable\n     */\n    isNull = function(object) {\n      return object === null;\n    };\n\n    /***\n    Returns whether the given argument is `undefined`.\n    \n    @function up.util.isUndefined\n    @param object\n    @return {boolean}\n    @stable\n     */\n    isUndefined = function(object) {\n      return object === void 0;\n    };\n\n    /***\n    Returns whether the given argument is not `undefined`.\n    \n    @function up.util.isDefined\n    @param object\n    @return {boolean}\n    @stable\n     */\n    isDefined = function(object) {\n      return !isUndefined(object);\n    };\n\n    /***\n    Returns whether the given argument is either `undefined` or `null`.\n    \n    Note that empty strings or zero are *not* considered to be \"missing\".\n    \n    For the opposite of `up.util.isMissing()` see [`up.util.isGiven()`](/up.util.isGiven).\n    \n    @function up.util.isMissing\n    @param object\n    @return {boolean}\n    @stable\n     */\n    isMissing = function(object) {\n      return isUndefined(object) || isNull(object);\n    };\n\n    /***\n    Returns whether the given argument is neither `undefined` nor `null`.\n    \n    Note that empty strings or zero *are* considered to be \"given\".\n    \n    For the opposite of `up.util.isGiven()` see [`up.util.isMissing()`](/up.util.isMissing).\n    \n    @function up.util.isGiven\n    @param object\n    @return {boolean}\n    @stable\n     */\n    isGiven = function(object) {\n      return !isMissing(object);\n    };\n\n    /***\n    Return whether the given argument is considered to be blank.\n    \n    This returns `true` for:\n    \n    - `undefined`\n    - `null`\n    - Empty strings\n    - Empty arrays\n    - An object without own enumerable properties\n    \n    All other arguments return `false`.\n    \n    @function up.util.isBlank\n    @param object\n    @return {boolean}\n    @stable\n     */\n    isBlank = function(object) {\n      if (isMissing(object)) {\n        return true;\n      }\n      if (isFunction(object)) {\n        return false;\n      }\n      if (isObject(object) && Object.keys(object).length === 0) {\n        return true;\n      }\n      if (object.length === 0) {\n        return true;\n      }\n      return false;\n    };\n\n    /***\n    Returns the given argument if the argument is [present](/up.util.isPresent),\n    otherwise returns `undefined`.\n    \n    @function up.util.presence\n    @param object\n    @param {Function(T): boolean} [tester=up.util.isPresent]\n      The function that will be used to test whether the argument is present.\n    @return {T|undefined}\n    @stable\n     */\n    presence = function(object, tester) {\n      if (tester == null) {\n        tester = isPresent;\n      }\n      if (tester(object)) {\n        return object;\n      } else {\n        return void 0;\n      }\n    };\n\n    /***\n    Returns whether the given argument is not [blank](/up.util.isBlank).\n    \n    @function up.util.isPresent\n    @param object\n    @return {boolean}\n    @stable\n     */\n    isPresent = function(object) {\n      return !isBlank(object);\n    };\n\n    /***\n    Returns whether the given argument is a function.\n    \n    @function up.util.isFunction\n    @param object\n    @return {boolean}\n    @stable\n     */\n    isFunction = function(object) {\n      return typeof object === 'function';\n    };\n\n    /***\n    Returns whether the given argument is a string.\n    \n    @function up.util.isString\n    @param object\n    @return {boolean}\n    @stable\n     */\n    isString = function(object) {\n      return typeof object === 'string' || object instanceof String;\n    };\n\n    /***\n    Returns whether the given argument is a boolean value.\n    \n    @function up.util.isBoolean\n    @param object\n    @return {boolean}\n    @experimental\n     */\n    isBoolean = function(object) {\n      return typeof object === 'boolean' || object instanceof Boolean;\n    };\n\n    /***\n    Returns whether the given argument is a number.\n    \n    Note that this will check the argument's *type*.\n    It will return `false` for a string like `\"123\"`.\n    \n    @function up.util.isNumber\n    @param object\n    @return {boolean}\n    @stable\n     */\n    isNumber = function(object) {\n      return typeof object === 'number' || object instanceof Number;\n    };\n\n    /***\n    Returns whether the given argument is an options hash,\n    \n    Differently from [`up.util.isObject()`], this returns false for\n    functions, jQuery collections, promises, `FormData` instances and arrays.\n    \n    @function up.util.isOptions\n    @param object\n    @return {boolean}\n    @internal\n     */\n    isOptions = function(object) {\n      return typeof object === 'object' && !isNull(object) && (isUndefined(object.constructor) || object.constructor === Object);\n    };\n\n    /***\n    Returns whether the given argument is an object.\n    \n    This also returns `true` for functions, which may behave like objects in JavaScript.\n    \n    @function up.util.isObject\n    @param object\n    @return {boolean}\n    @stable\n     */\n    isObject = function(object) {\n      var typeOfResult;\n      typeOfResult = typeof object;\n      return (typeOfResult === 'object' && !isNull(object)) || typeOfResult === 'function';\n    };\n\n    /***\n    Returns whether the given argument is a DOM element.\n    \n    @function up.util.isElement\n    @param object\n    @return {boolean}\n    @stable\n     */\n    isElement = function(object) {\n      return !!(object && object.nodeType === 1);\n    };\n\n    /***\n    Returns whether the given argument is a jQuery collection.\n    \n    @function up.util.isJQuery\n    @param object\n    @return {boolean}\n    @stable\n     */\n    isJQuery = function(object) {\n      return object instanceof jQuery;\n    };\n\n    /***\n    Returns whether the given argument is an object with a `then` method.\n    \n    @function up.util.isPromise\n    @param object\n    @return {boolean}\n    @stable\n     */\n    isPromise = function(object) {\n      return isObject(object) && isFunction(object.then);\n    };\n\n    /***\n    Returns whether the given argument is an array.\n    \n    @function up.util.isArray\n    @param object\n    @return {boolean}\n    @stable\n     */\n    isArray = Array.isArray;\n\n    /***\n    Returns whether the given argument is a `FormData` instance.\n    \n    Always returns `false` in browsers that don't support `FormData`.\n    \n    @function up.util.isFormData\n    @param object\n    @return {boolean}\n    @internal\n     */\n    isFormData = function(object) {\n      return object instanceof FormData;\n    };\n\n    /***\n    Converts the given array-like argument into an array.\n    \n    Returns the array.\n    \n    @function up.util.toArray\n    @param object\n    @return {Array}\n    @stable\n     */\n    toArray = function(object) {\n      return Array.prototype.slice.call(object);\n    };\n\n    /***\n    Returns a shallow copy of the given array or object.\n    \n    @function up.util.copy\n    @param {Object|Array} object\n    @return {Object|Array}\n    @stable\n     */\n    copy = function(object, deep) {\n      if (isArray(object)) {\n        object = object.slice();\n      } else if (isOptions(object)) {\n        object = assign({}, object);\n      }\n      return object;\n    };\n\n    /***\n    If given a jQuery collection, returns the first native DOM element in the collection.\n    If given a string, returns the first element matching that string.\n    If given any other argument, returns the argument unchanged.\n    \n    @function up.util.element\n    @param {jQuery|Element|String} object\n    @return {Element}\n    @internal\n     */\n    getElement = function(object) {\n      if (isJQuery(object)) {\n        return object.get(0);\n      } else if (isString(object)) {\n        return $(object).get(0);\n      } else {\n        return object;\n      }\n    };\n\n    /***\n    Creates a new object by merging together the properties from the given objects.\n    \n    @function up.util.merge\n    @param {Array<Object>} sources...\n    @return Object\n    @stable\n     */\n    merge = function() {\n      var sources;\n      sources = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n      return assign.apply(null, [{}].concat(slice.call(sources)));\n    };\n\n    /***\n    Creates an options hash from the given argument and some defaults.\n    \n    The semantics of this function are confusing.\n    We want to get rid of this in the future.\n    \n    @function up.util.options\n    @param {Object} object\n    @param {Object} [defaults]\n    @return {Object}\n    @internal\n     */\n    newOptions = function(object, defaults) {\n      if (defaults) {\n        return merge(defaults, object);\n      } else if (object) {\n        return copy(object);\n      } else {\n        return {};\n      }\n    };\n\n    /***\n    Returns the first argument that is considered [given](/up.util.isGiven).\n    \n    This function is useful when you have multiple option sources and the value can be boolean.\n    In that case you cannot change the sources with a `||` operator\n    (since that doesn't short-circuit at `false`).\n    \n    @function up.util.option\n    @param {Array} args...\n    @internal\n     */\n    option = function() {\n      var args;\n      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n      return detect(args, isGiven);\n    };\n\n    /***\n    Passes each element in the given array to the given function.\n    Returns the first element for which the function returns a truthy value.\n    \n    If no object matches, returns `undefined`.\n    \n    @function up.util.detect\n    @param {Array<T>} array\n    @param {Function(T): boolean} tester\n    @return {T|undefined}\n    @stable\n     */\n    detect = function(array, tester) {\n      var element, j, len, match;\n      match = void 0;\n      for (j = 0, len = array.length; j < len; j++) {\n        element = array[j];\n        if (tester(element)) {\n          match = element;\n          break;\n        }\n      }\n      return match;\n    };\n\n    /***\n    Returns whether the given function returns a truthy value\n    for any element in the given array.\n    \n    @function up.util.any\n    @param {Array<T>} array\n    @param {Function(T, number): boolean} tester\n      A function that will be called with each element and (optional) iteration index.\n    \n    @return {boolean}\n    @experimental\n     */\n    any = function(array, tester) {\n      var element, index, j, len, match;\n      tester = listBlock(tester);\n      match = false;\n      for (index = j = 0, len = array.length; j < len; index = ++j) {\n        element = array[index];\n        if (tester(element, index)) {\n          match = true;\n          break;\n        }\n      }\n      return match;\n    };\n\n    /***\n    Returns whether the given function returns a truthy value\n    for all elements in the given array.\n    \n    @function up.util.all\n    @param {Array<T>} array\n    @param {Function(T, number): boolean} tester\n      A function that will be called with each element and (optional) iteration index.\n    \n    @return {boolean}\n    @experimental\n     */\n    all = function(array, tester) {\n      var element, index, j, len, match;\n      tester = listBlock(tester);\n      match = true;\n      for (index = j = 0, len = array.length; j < len; index = ++j) {\n        element = array[index];\n        if (!tester(element, index)) {\n          match = false;\n          break;\n        }\n      }\n      return match;\n    };\n\n    /***\n    Returns all elements from the given array that are\n    neither `null` or `undefined`.\n    \n    @function up.util.compact\n    @param {Array<T>} array\n    @return {Array<T>}\n    @stable\n     */\n    compact = function(array) {\n      return select(array, isGiven);\n    };\n\n    /***\n    Returns the given array without duplicates.\n    \n    @function up.util.uniq\n    @param {Array<T>} array\n    @return {Array<T>}\n    @stable\n     */\n    uniq = function(array) {\n      if (array.length < 2) {\n        return array;\n      }\n      return setToArray(arrayToSet(array));\n    };\n\n    /***\n    This function is like [`uniq`](/up.util.uniq), accept that\n    the given function is invoked for each element to generate the value\n    for which uniquness is computed.\n    \n    @function up.util.uniqBy\n    @param {Array<T>} array\n    @param {Function<T>: any} array\n    @return {Array<T>}\n    @experimental\n     */\n    uniqBy = function(array, mapper) {\n      var set;\n      if (array.length < 2) {\n        return array;\n      }\n      mapper = listBlock(mapper);\n      set = new Set();\n      return select(array, function(elem, index) {\n        var mapped;\n        mapped = mapper(elem, index);\n        if (set.has(mapped)) {\n          return false;\n        } else {\n          set.add(mapped);\n          return true;\n        }\n      });\n    };\n\n    /***\n    @function up.util.setToArray\n    @internal\n     */\n    setToArray = function(set) {\n      var array;\n      array = [];\n      set.forEach(function(elem) {\n        return array.push(elem);\n      });\n      return array;\n    };\n\n    /***\n    @function up.util.arrayToSet\n    @internal\n     */\n    arrayToSet = function(array) {\n      var set;\n      set = new Set();\n      array.forEach(function(elem) {\n        return set.add(elem);\n      });\n      return set;\n    };\n\n    /***\n    Returns all elements from the given array that return\n    a truthy value when passed to the given function.\n    \n    @function up.util.select\n    @param {Array<T>} array\n    @param {Function(T, number): boolean} tester\n    @return {Array<T>}\n    @stable\n     */\n    select = function(array, tester) {\n      var matches;\n      tester = listBlock(tester);\n      matches = [];\n      each(array, function(element, index) {\n        if (tester(element, index)) {\n          return matches.push(element);\n        }\n      });\n      return matches;\n    };\n\n    /***\n    Returns all elements from the given array that do not return\n    a truthy value when passed to the given function.\n    \n    @function up.util.reject\n    @param {Array<T>} array\n    @param {Function(T, number): boolean} tester\n    @return {Array<T>}\n    @stable\n     */\n    reject = function(array, tester) {\n      tester = listBlock(tester);\n      return select(array, function(element, index) {\n        return !tester(element, index);\n      });\n    };\n\n    /***\n    Returns the intersection of the given two arrays.\n    \n    Implementation is not optimized. Don't use it for large arrays.\n    \n    @function up.util.intersect\n    @internal\n     */\n    intersect = function(array1, array2) {\n      return select(array1, function(element) {\n        return contains(array2, element);\n      });\n    };\n    addClass = function(element, klassOrKlasses) {\n      return changeClassList(element, klassOrKlasses, 'add');\n    };\n    removeClass = function(element, klassOrKlasses) {\n      return changeClassList(element, klassOrKlasses, 'remove');\n    };\n    changeClassList = function(element, klassOrKlasses, fnName) {\n      var classList;\n      classList = getElement(element).classList;\n      if (isArray(klassOrKlasses)) {\n        return each(klassOrKlasses, function(klass) {\n          return classList[fnName](klass);\n        });\n      } else {\n        return classList[fnName](klassOrKlasses);\n      }\n    };\n    addTemporaryClass = function(element, klassOrKlasses) {\n      addClass(element, klassOrKlasses);\n      return function() {\n        return removeClass(element, klassOrKlasses);\n      };\n    };\n    hasClass = function(element, klass) {\n      var classList;\n      classList = getElement(element).classList;\n      return classList.contains(klass);\n    };\n\n    /***\n    Returns the first [present](/up.util.isPresent) element attribute\n    among the given list of attribute names.\n    \n    @function up.util.presentAttr\n    @internal\n     */\n    presentAttr = function() {\n      var $element, attrName, attrNames, values;\n      $element = arguments[0], attrNames = 2 <= arguments.length ? slice.call(arguments, 1) : [];\n      values = (function() {\n        var j, len, results;\n        results = [];\n        for (j = 0, len = attrNames.length; j < len; j++) {\n          attrName = attrNames[j];\n          results.push($element.attr(attrName));\n        }\n        return results;\n      })();\n      return detect(values, isPresent);\n    };\n\n    /***\n    Waits for the given number of milliseconds, the runs the given callback.\n    \n    Instead of `up.util.setTimer(0, fn)` you can also use [`up.util.nextFrame(fn)`](/up.util.nextFrame).\n    \n    @function up.util.setTimer\n    @param {number} millis\n    @param {Function} callback\n    @stable\n     */\n    setTimer = function(millis, callback) {\n      return setTimeout(callback, millis);\n    };\n\n    /***\n    Schedules the given function to be called in the\n    next JavaScript execution frame.\n    \n    @function up.util.nextFrame\n    @param {Function} block\n    @stable\n     */\n    nextFrame = function(block) {\n      return setTimeout(block, 0);\n    };\n\n    /***\n    Queue a function to be executed in the next microtask.\n    \n    @function up.util.queueMicrotask\n    @param {Function} task\n    @internal\n     */\n    microtask = function(task) {\n      return Promise.resolve().then(task);\n    };\n\n    /***\n    Returns the last element of the given array.\n    \n    @function up.util.last\n    @param {Array<T>} array\n    @return {T}\n     */\n    last = function(array) {\n      return array[array.length - 1];\n    };\n\n    /***\n    Measures the drawable area of the document.\n    \n    @function up.util.clientSize\n    @internal\n     */\n    clientSize = function() {\n      var element;\n      element = document.documentElement;\n      return {\n        width: element.clientWidth,\n        height: element.clientHeight\n      };\n    };\n\n    /***\n    Returns the width of a scrollbar.\n    \n    This only runs once per page load.\n    \n    @function up.util.scrollbarWidth\n    @internal\n     */\n    scrollbarWidth = memoize(function() {\n      var $outer, outer, width;\n      $outer = $('<div>');\n      outer = $outer.get(0);\n      $outer.attr('up-viewport', '');\n      writeInlineStyle(outer, {\n        position: 'absolute',\n        top: '0',\n        left: '0',\n        width: '100px',\n        height: '100px',\n        overflowY: 'scroll'\n      });\n      $outer.appendTo(document.body);\n      width = outer.offsetWidth - outer.clientWidth;\n      $outer.remove();\n      return width;\n    });\n\n    /***\n    Returns whether the given element is currently showing a vertical scrollbar.\n    \n    @function up.util.documentHasVerticalScrollbar\n    @internal\n     */\n    documentHasVerticalScrollbar = function() {\n      var $body, body, bodyOverflow, forcedHidden, forcedScroll, html;\n      body = document.body;\n      $body = $(body);\n      html = document.documentElement;\n      bodyOverflow = readComputedStyle($body, 'overflowY');\n      forcedScroll = bodyOverflow === 'scroll';\n      forcedHidden = bodyOverflow === 'hidden';\n      return forcedScroll || (!forcedHidden && html.scrollHeight > html.clientHeight);\n    };\n\n    /***\n    Temporarily sets the CSS for the given element.\n    \n    @function up.util.writeTemporaryStyle\n    @param {jQuery} $element\n    @param {Object} css\n    @param {Function} [block]\n      If given, the CSS is set, the block is called and\n      the old CSS is restored.\n    @return {Function}\n      A function that restores the original CSS when called.\n    @internal\n     */\n    writeTemporaryStyle = function(elementOrSelector, newCss, block) {\n      var $element, oldStyles, restoreOldStyles;\n      $element = $(elementOrSelector);\n      oldStyles = readInlineStyle($element, Object.keys(newCss));\n      restoreOldStyles = function() {\n        return writeInlineStyle($element, oldStyles);\n      };\n      writeInlineStyle($element, newCss);\n      if (block) {\n        block();\n        return restoreOldStyles();\n      } else {\n        return restoreOldStyles;\n      }\n    };\n\n    /***\n    Forces a repaint of the given element.\n    \n    @function up.util.forceRepaint\n    @internal\n     */\n    forceRepaint = function(element) {\n      element = getElement(element);\n      return element.offsetHeight;\n    };\n\n    /***\n    @function up.util.finishTransition\n    @internal\n     */\n    concludeCssTransition = function(element) {\n      var undo;\n      undo = writeTemporaryStyle(element, {\n        transition: 'none'\n      });\n      forceRepaint(element);\n      return undo;\n    };\n\n    /***\n    @internal\n     */\n    margins = function(selectorOrElement) {\n      var element;\n      element = getElement(selectorOrElement);\n      return {\n        top: readComputedStyleNumber(element, 'marginTop'),\n        right: readComputedStyleNumber(element, 'marginRight'),\n        bottom: readComputedStyleNumber(element, 'marginBottom'),\n        left: readComputedStyleNumber(element, 'marginLeft')\n      };\n    };\n\n    /***\n    Measures the given element.\n    \n    @function up.util.measure\n    @internal\n     */\n    measure = function($element, opts) {\n      var $context, box, contextCoords, coordinates, elementCoords, mgs;\n      opts = newOptions(opts, {\n        relative: false,\n        inner: false,\n        includeMargin: false\n      });\n      if (opts.relative) {\n        if (opts.relative === true) {\n          coordinates = $element.position();\n        } else {\n          $context = $(opts.relative);\n          elementCoords = $element.offset();\n          if ($context.is(document)) {\n            coordinates = elementCoords;\n          } else {\n            contextCoords = $context.offset();\n            coordinates = {\n              left: elementCoords.left - contextCoords.left,\n              top: elementCoords.top - contextCoords.top\n            };\n          }\n        }\n      } else {\n        coordinates = $element.offset();\n      }\n      box = {\n        left: coordinates.left,\n        top: coordinates.top\n      };\n      if (opts.inner) {\n        box.width = $element.width();\n        box.height = $element.height();\n      } else {\n        box.width = $element.outerWidth();\n        box.height = $element.outerHeight();\n      }\n      if (opts.includeMargin) {\n        mgs = margins($element);\n        box.left -= mgs.left;\n        box.top -= mgs.top;\n        box.height += mgs.top + mgs.bottom;\n        box.width += mgs.left + mgs.right;\n      }\n      return box;\n    };\n\n    /***\n    Copies all attributes from the source element to the target element.\n    \n    @function up.util.copyAttributes\n    @internal\n     */\n    copyAttributes = function($source, $target) {\n      var attr, j, len, ref, results;\n      ref = $source.get(0).attributes;\n      results = [];\n      for (j = 0, len = ref.length; j < len; j++) {\n        attr = ref[j];\n        if (attr.specified) {\n          results.push($target.attr(attr.name, attr.value));\n        } else {\n          results.push(void 0);\n        }\n      }\n      return results;\n    };\n\n    /***\n    Looks for the given selector in the element and its descendants.\n    \n    @function up.util.selectInSubtree\n    @internal\n     */\n    selectInSubtree = function($element, selector) {\n      var $matches;\n      $matches = $();\n      if ($element.is(selector)) {\n        $matches = $matches.add($element);\n      }\n      $matches = $matches.add($element.find(selector));\n      return $matches;\n    };\n\n    /***\n    Looks for the given selector in the element, its descendants and its ancestors.\n    \n    @function up.util.selectInDynasty\n    @internal\n     */\n    selectInDynasty = function($element, selector) {\n      var $ancestors, $subtree;\n      $subtree = selectInSubtree($element, selector);\n      $ancestors = $element.parents(selector);\n      return $subtree.add($ancestors);\n    };\n\n    /***\n    Returns whether the given keyboard event involved the ESC key.\n    \n    @function up.util.escapePressed\n    @internal\n     */\n    escapePressed = function(event) {\n      return event.keyCode === 27;\n    };\n\n    /***\n    Returns whether the given array or string contains the given element or substring.\n    \n    @function up.util.contains\n    @param {Array|string} arrayOrString\n    @param elementOrSubstring\n    @stable\n     */\n    contains = function(arrayOrString, elementOrSubstring) {\n      return arrayOrString.indexOf(elementOrSubstring) >= 0;\n    };\n\n    /***\n    @function up.util.castedAttr\n    @internal\n     */\n    castedAttr = function($element, attribute) {\n      var value;\n      value = $element.attr(attribute);\n      switch (value) {\n        case 'false':\n          return false;\n        case 'true':\n        case '':\n        case attribute:\n          return true;\n        default:\n          return value;\n      }\n    };\n\n    /***\n    @function up.util.jsonAttr\n    @internal\n     */\n    jsonAttr = function(elementOrSelector, attribute) {\n      var element, json;\n      if (element = getElement(elementOrSelector)) {\n        json = typeof element.getAttribute === \"function\" ? element.getAttribute(attribute) : void 0;\n        if (isString(json) && trim(json) !== '') {\n          return JSON.parse(json);\n        }\n      }\n    };\n\n    /***\n    Returns a copy of the given object that only contains\n    the given properties.\n    \n    @function up.util.only\n    @param {Object} object\n    @param {Array} keys...\n    @stable\n     */\n    only = function() {\n      var filtered, j, len, object, properties, property;\n      object = arguments[0], properties = 2 <= arguments.length ? slice.call(arguments, 1) : [];\n      filtered = {};\n      for (j = 0, len = properties.length; j < len; j++) {\n        property = properties[j];\n        if (property in object) {\n          filtered[property] = object[property];\n        }\n      }\n      return filtered;\n    };\n\n    /***\n    Returns a copy of the given object that contains all except\n    the given properties.\n    \n    @function up.util.except\n    @param {Object} object\n    @param {Array} keys...\n    @stable\n     */\n    except = function() {\n      var filtered, j, len, object, properties, property;\n      object = arguments[0], properties = 2 <= arguments.length ? slice.call(arguments, 1) : [];\n      filtered = copy(object);\n      for (j = 0, len = properties.length; j < len; j++) {\n        property = properties[j];\n        delete filtered[property];\n      }\n      return filtered;\n    };\n\n    /***\n    @function up.util.isUnmodifiedKeyEvent\n    @internal\n     */\n    isUnmodifiedKeyEvent = function(event) {\n      return !(event.metaKey || event.shiftKey || event.ctrlKey);\n    };\n\n    /***\n    @function up.util.isUnmodifiedMouseEvent\n    @internal\n     */\n    isUnmodifiedMouseEvent = function(event) {\n      var isLeftButton;\n      isLeftButton = isUndefined(event.button) || event.button === 0;\n      return isLeftButton && isUnmodifiedKeyEvent(event);\n    };\n\n    /***\n    Returns a promise that will never be resolved.\n    \n    @function up.util.unresolvablePromise\n    @experimental\n     */\n    unresolvablePromise = function() {\n      return new Promise(noop);\n    };\n\n    /***\n    Returns an empty jQuery collection.\n    \n    @function up.util.nullJQuery\n    @internal\n     */\n    nullJQuery = function() {\n      return $();\n    };\n\n    /***\n    On the given element, set attributes that are still missing.\n    \n    @function up.util.setMissingAttrs\n    @internal\n     */\n    setMissingAttrs = function($element, attrs) {\n      var key, results, value;\n      results = [];\n      for (key in attrs) {\n        value = attrs[key];\n        if (isMissing($element.attr(key))) {\n          results.push($element.attr(key, value));\n        } else {\n          results.push(void 0);\n        }\n      }\n      return results;\n    };\n\n    /***\n    Removes the given element from the given array.\n    \n    This changes the given array.\n    \n    @function up.util.remove\n    @param {Array<T>} array\n    @param {T} element\n    @stable\n     */\n    remove = function(array, element) {\n      var index;\n      index = array.indexOf(element);\n      if (index >= 0) {\n        array.splice(index, 1);\n        return element;\n      }\n    };\n\n    /***\n    If the given `value` is a function, calls the function with the given `args`.\n    Otherwise it just returns `value`.\n    \n    @function up.util.evalOption\n    @internal\n     */\n    evalOption = function() {\n      var args, value;\n      value = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];\n      if (isFunction(value)) {\n        return value.apply(null, args);\n      } else {\n        return value;\n      }\n    };\n\n    /***\n    @function up.util.config\n    @param {Object|Function} blueprint\n      Default configuration options.\n      Will be restored by calling `reset` on the returned object.\n    @return {Object}\n      An object with a `reset` function.\n    @internal\n     */\n    config = function(blueprint) {\n      var hash;\n      hash = openConfig(blueprint);\n      Object.preventExtensions(hash);\n      return hash;\n    };\n\n    /***\n    @function up.util.openConfig\n    @internal\n     */\n    openConfig = function(blueprint) {\n      var hash;\n      if (blueprint == null) {\n        blueprint = {};\n      }\n      hash = {};\n      hash.reset = function() {\n        var opts;\n        opts = blueprint;\n        if (isFunction(opts)) {\n          opts = opts();\n        }\n        return assign(hash, opts);\n      };\n      hash.reset();\n      return hash;\n    };\n\n    /***\n    @function up.util.unwrapElement\n    @internal\n     */\n    unwrapElement = function(wrapper) {\n      var parent, wrappedNodes;\n      wrapper = getElement(wrapper);\n      parent = wrapper.parentNode;\n      wrappedNodes = toArray(wrapper.childNodes);\n      each(wrappedNodes, function(wrappedNode) {\n        return parent.insertBefore(wrappedNode, wrapper);\n      });\n      return parent.removeChild(wrapper);\n    };\n\n    /***\n    @function up.util.offsetParent\n    @internal\n     */\n    offsetParent = function($element) {\n      var $match, position;\n      $match = void 0;\n      while (($element = $element.parent()) && $element.length) {\n        position = readComputedStyle($element, 'position');\n        if (position === 'absolute' || position === 'relative' || $element.is('body')) {\n          $match = $element;\n          break;\n        }\n      }\n      return $match;\n    };\n\n    /***\n    Returns if the given element has a `fixed` position.\n    \n    @function up.util.isFixed\n    @internal\n     */\n    isFixed = function(element) {\n      var $element, position;\n      $element = $(element);\n      while (true) {\n        position = readComputedStyle($element, 'position');\n        if (position === 'fixed') {\n          return true;\n        } else {\n          $element = $element.parent();\n          if ($element.length === 0 || $element.is(document)) {\n            return false;\n          }\n        }\n      }\n    };\n\n    /***\n    @function up.util.fixedToAbsolute\n    @internal\n     */\n    fixedToAbsolute = function(element, $viewport) {\n      var $element, $futureOffsetParent, elementCoords, futureParentCoords;\n      $element = $(element);\n      $futureOffsetParent = offsetParent($element);\n      elementCoords = $element.position();\n      futureParentCoords = $futureOffsetParent.offset();\n      return writeInlineStyle($element, {\n        position: 'absolute',\n        left: elementCoords.left - futureParentCoords.left,\n        top: elementCoords.top - futureParentCoords.top + $viewport.scrollTop(),\n        right: '',\n        bottom: ''\n      });\n    };\n\n    /***\n    Throws a [JavaScript error](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error)\n    with the given message.\n    \n    The message will also be printed to the [error log](/up.log.error). Also a notification will be shown at the bottom of the screen.\n    \n    The message may contain [substitution marks](https://developer.mozilla.org/en-US/docs/Web/API/console#Using_string_substitutions).\n    \n    \\#\\#\\# Examples\n    \n        up.fail('Division by zero')\n        up.fail('Unexpected result %o', result)\n    \n    @function up.fail\n    @param {string} message\n      A message with details about the error.\n    \n      The message can contain [substitution marks](https://developer.mozilla.org/en-US/docs/Web/API/console#Using_string_substitutions)\n      like `%s` or `%o`.\n    @param {Array<string>} vars...\n      A list of variables to replace any substitution marks in the error message.\n    @experimental\n     */\n    fail = function() {\n      var args, asString, messageArgs, ref, ref1, toastOptions;\n      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n      if (isArray(args[0])) {\n        messageArgs = args[0];\n        toastOptions = args[1] || {};\n      } else {\n        messageArgs = args;\n        toastOptions = {};\n      }\n      (ref = up.log).error.apply(ref, messageArgs);\n      whenReady().then(function() {\n        return up.toast.open(messageArgs, toastOptions);\n      });\n      asString = (ref1 = up.browser).sprintf.apply(ref1, messageArgs);\n      throw new Error(asString);\n    };\n    ESCAPE_HTML_ENTITY_MAP = {\n      \"&\": \"&amp;\",\n      \"<\": \"&lt;\",\n      \">\": \"&gt;\",\n      '\"': '&quot;'\n    };\n\n    /***\n    Escapes the given string of HTML by replacing control chars with their HTML entities.\n    \n    @function up.util.escapeHtml\n    @param {string} string\n      The text that should be escaped\n    @experimental\n     */\n    escapeHtml = function(string) {\n      return string.replace(/[&<>\"]/g, function(char) {\n        return ESCAPE_HTML_ENTITY_MAP[char];\n      });\n    };\n    pluckKey = function(object, key) {\n      var value;\n      value = object[key];\n      delete object[key];\n      return value;\n    };\n    renameKey = function(object, oldKey, newKey) {\n      return object[newKey] = pluckKey(object, oldKey);\n    };\n    deprecateRenamedKey = function(object, oldKey, newKey) {\n      if (isDefined(object[oldKey])) {\n        up.warn('Deprecated: Object key { %s } has been renamed to { %s } (found in %o)', oldKey, newKey, object);\n        return renameKey(object, oldKey, newKey);\n      }\n    };\n    pluckData = function(elementOrSelector, key) {\n      var $element, value;\n      $element = $(elementOrSelector);\n      value = $element.data(key);\n      $element.removeData(key);\n      return value;\n    };\n    extractOptions = function(args) {\n      var lastArg;\n      lastArg = last(args);\n      if (isOptions(lastArg)) {\n        return args.pop();\n      } else {\n        return {};\n      }\n    };\n    CASE_CONVERSION_GROUP = /[^\\-\\_]+?(?=[A-Z\\-\\_]|$)/g;\n    convertCase = function(string, separator, fn) {\n      var parts;\n      parts = string.match(CASE_CONVERSION_GROUP);\n      parts = map(parts, fn);\n      return parts.join(separator);\n    };\n\n    /***\n    Returns a copy of the given string that is transformed to `kebab-case`.\n    \n    @function up.util.kebabCase\n    @param {string} string\n    @return {string}\n    @internal\n     */\n    kebabCase = function(string) {\n      return convertCase(string, '-', function(part) {\n        return part.toLowerCase();\n      });\n    };\n\n    /***\n    Returns a copy of the given string that is transformed to `camelCase`.\n    \n    @function up.util.camelCase\n    @param {string} string\n    @return {string}\n    @internal\n     */\n    camelCase = function(string) {\n      return convertCase(string, '', function(part, i) {\n        if (i === 0) {\n          return part.toLowerCase();\n        } else {\n          return part.charAt(0).toUpperCase() + part.substr(1).toLowerCase();\n        }\n      });\n    };\n\n    /***\n    Returns a copy of the given object with all keys renamed\n    in `kebab-case`.\n    \n    Does not change the given object.\n    \n    @function up.util.kebabCaseKeys\n    @param {object} obj\n    @return {object}\n    @internal\n     */\n    kebabCaseKeys = function(obj) {\n      return copyWithRenamedKeys(obj, kebabCase);\n    };\n\n    /***\n    Returns a copy of the given object with all keys renamed\n    in `camelCase`.\n    \n    Does not change the given object.\n    \n    @function up.util.camelCaseKeys\n    @param {object} obj\n    @return {object}\n    @internal\n     */\n    camelCaseKeys = function(obj) {\n      return copyWithRenamedKeys(obj, camelCase);\n    };\n    copyWithRenamedKeys = function(obj, keyTransformer) {\n      var k, result, v;\n      result = {};\n      for (k in obj) {\n        v = obj[k];\n        k = keyTransformer(k);\n        result[k] = v;\n      }\n      return result;\n    };\n    opacity = function(element) {\n      return readComputedStyleNumber(element, 'opacity');\n    };\n    whenReady = memoize(function() {\n      if ($.isReady) {\n        return Promise.resolve();\n      } else {\n        return new Promise(function(resolve) {\n          return $(resolve);\n        });\n      }\n    });\n    identity = function(arg) {\n      return arg;\n    };\n\n    /***\n    Returns whether the given element has been detached from the DOM\n    (or whether it was never attached).\n    \n    @function up.util.isDetached\n    @internal\n     */\n    isDetached = function(element) {\n      element = getElement(element);\n      return !$.contains(document.documentElement, element);\n    };\n\n    /***\n    Given a function that will return a promise, returns a proxy function\n    with an additional `.promise` attribute.\n    \n    When the proxy is called, the inner function is called.\n    The proxy's `.promise` attribute is available even before the function is called\n    and will resolve when the inner function's returned promise resolves.\n    \n    If the inner function does not return a promise, the proxy's `.promise` attribute\n    will resolve as soon as the inner function returns.\n    \n    @function up.util.previewable\n    @internal\n     */\n    previewable = function(fun) {\n      var deferred, preview;\n      deferred = newDeferred();\n      preview = function() {\n        var args, funValue;\n        args = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n        funValue = fun.apply(null, args);\n        deferred.resolve(funValue);\n        return funValue;\n      };\n      preview.promise = deferred.promise();\n      return preview;\n    };\n\n    /***\n    A linear task queue whose (2..n)th tasks can be changed at any time.\n    \n    @function up.util.DivertibleChain\n    @internal\n     */\n    DivertibleChain = (function() {\n      function DivertibleChain() {\n        this.asap = bind(this.asap, this);\n        this.poke = bind(this.poke, this);\n        this.allTasks = bind(this.allTasks, this);\n        this.promise = bind(this.promise, this);\n        this.reset = bind(this.reset, this);\n        this.reset();\n      }\n\n      DivertibleChain.prototype.reset = function() {\n        this.queue = [];\n        return this.currentTask = void 0;\n      };\n\n      DivertibleChain.prototype.promise = function() {\n        var lastTask;\n        lastTask = last(this.allTasks());\n        return (lastTask != null ? lastTask.promise : void 0) || Promise.resolve();\n      };\n\n      DivertibleChain.prototype.allTasks = function() {\n        var tasks;\n        tasks = [];\n        if (this.currentTask) {\n          tasks.push(this.currentTask);\n        }\n        tasks = tasks.concat(this.queue);\n        return tasks;\n      };\n\n      DivertibleChain.prototype.poke = function() {\n        var promise;\n        if (!this.currentTask) {\n          if (this.currentTask = this.queue.shift()) {\n            promise = this.currentTask();\n            return always(promise, (function(_this) {\n              return function() {\n                _this.currentTask = void 0;\n                return _this.poke();\n              };\n            })(this));\n          }\n        }\n      };\n\n      DivertibleChain.prototype.asap = function() {\n        var newTasks;\n        newTasks = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n        this.queue = map(newTasks, previewable);\n        this.poke();\n        return this.promise();\n      };\n\n      return DivertibleChain;\n\n    })();\n\n    /***\n    @function up.util.submittedValue\n    @internal\n     */\n    submittedValue = function(fieldOrSelector) {\n      var $field;\n      $field = $(fieldOrSelector);\n      if ($field.is('[type=checkbox], [type=radio]') && !$field.is(':checked')) {\n        return void 0;\n      } else {\n        return $field.val();\n      }\n    };\n\n    /***\n    @function up.util.sequence\n    @param {Array<Function>} functions...\n    @return {Function}\n      A function that will call all `functions` if called.\n    \n    @internal\n     */\n    sequence = function() {\n      var functions;\n      functions = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n      return function() {\n        return map(functions, function(f) {\n          return f();\n        });\n      };\n    };\n\n    /***\n    @function up.util.promiseTimer\n    @internal\n     */\n    promiseTimer = function(ms) {\n      var promise, timeout;\n      timeout = void 0;\n      promise = new Promise(function(resolve, reject) {\n        return timeout = setTimer(ms, resolve);\n      });\n      promise.cancel = function() {\n        return clearTimeout(timeout);\n      };\n      return promise;\n    };\n\n    /***\n    Returns `'left'` if the center of the given element is in the left 50% of the screen.\n    Otherwise returns `'right'`.\n    \n    @function up.util.horizontalScreenHalf\n    @internal\n     */\n    horizontalScreenHalf = function($element) {\n      var elementDims, elementMid, screenDims, screenMid;\n      elementDims = measure($element);\n      screenDims = clientSize();\n      elementMid = elementDims.left + 0.5 * elementDims.width;\n      screenMid = 0.5 * screenDims.width;\n      if (elementMid < screenMid) {\n        return 'left';\n      } else {\n        return 'right';\n      }\n    };\n\n    /***\n    Like `$old.replaceWith($new)`, but keeps event handlers bound to `$old`.\n    \n    Note that this is a memory leak unless you re-attach `$old` to the DOM aferwards.\n    \n    @function up.util.detachWith\n    @internal\n     */\n    detachWith = function($old, $new) {\n      var $insertion;\n      $insertion = $('<div></div>');\n      $insertion.insertAfter($old);\n      $old.detach();\n      $insertion.replaceWith($new);\n      return $old;\n    };\n\n    /***\n    Hides the given element faster than `jQuery.fn.hide()`.\n    \n    @function up.util.hide\n    @param {jQuery|Element} element\n     */\n    hide = function(element) {\n      return writeInlineStyle(element, {\n        display: 'none'\n      });\n    };\n\n    /***\n    Gets the computed style(s) for the given element.\n    \n    @function up.util.readComputedStyle\n    @param {jQuery|Element} element\n    @param {String|Array} propOrProps\n      One or more CSS property names in camelCase.\n    @return {string|object}\n    @internal\n     */\n    readComputedStyle = function(element, props) {\n      var style;\n      element = getElement(element);\n      style = window.getComputedStyle(element);\n      return extractFromStyleObject(style, props);\n    };\n\n    /***\n    Gets a computed style value for the given element.\n    If a value is set, the value is parsed to a number before returning.\n    \n    @function up.util.readComputedStyleNumber\n    @param {jQuery|Element} element\n    @param {String} prop\n      A CSS property name in camelCase.\n    @return {string|object}\n    @internal\n     */\n    readComputedStyleNumber = function(element, prop) {\n      var rawValue;\n      rawValue = readComputedStyle(element, prop);\n      if (isGiven(rawValue)) {\n        return parseFloat(rawValue);\n      } else {\n        return void 0;\n      }\n    };\n\n    /***\n    Gets the given inline style(s) from the given element's `[style]` attribute.\n    \n    @function up.util.readInlineStyle\n    @param {jQuery|Element} element\n    @param {String|Array} propOrProps\n      One or more CSS property names in camelCase.\n    @return {string|object}\n    @internal\n     */\n    readInlineStyle = function(element, props) {\n      var style;\n      element = getElement(element);\n      style = element.style;\n      return extractFromStyleObject(style, props);\n    };\n    extractFromStyleObject = function(style, keyOrKeys) {\n      if (isString(keyOrKeys)) {\n        return style[keyOrKeys];\n      } else {\n        return only.apply(null, [style].concat(slice.call(keyOrKeys)));\n      }\n    };\n\n    /***\n    Merges the given inline style(s) into the given element's `[style]` attribute.\n    \n    @function up.util.readInlineStyle\n    @param {jQuery|Element} element\n    @param {Object} props\n      One or more CSS properties with camelCase keys.\n    @return {string|object}\n    @internal\n     */\n    writeInlineStyle = function(element, props) {\n      var key, results, style, value;\n      element = getElement(element);\n      style = element.style;\n      results = [];\n      for (key in props) {\n        value = props[key];\n        value = normalizeStyleValueForWrite(key, value);\n        results.push(style[key] = value);\n      }\n      return results;\n    };\n    normalizeStyleValueForWrite = function(key, value) {\n      if (isMissing(value)) {\n        value = '';\n      } else if (CSS_LENGTH_PROPS.has(key)) {\n        value = cssLength(value);\n      }\n      return value;\n    };\n    CSS_LENGTH_PROPS = arrayToSet(['top', 'right', 'bottom', 'left', 'padding', 'paddingTop', 'paddingRight', 'paddingBottom', 'paddingLeft', 'margin', 'marginTop', 'marginRight', 'marginBottom', 'marginLeft', 'width', 'height', 'maxWidth', 'maxHeight', 'minWidth', 'minHeight']);\n\n    /***\n    Converts the given value to a CSS length value, adding a `px` unit if required.\n    \n    @function up.util.cssLength\n    @internal\n     */\n    cssLength = function(obj) {\n      if (isNumber(obj) || (isString(obj) && /^\\d+$/.test(obj))) {\n        return obj.toString() + \"px\";\n      } else {\n        return obj;\n      }\n    };\n\n    /***\n    Returns whether the given element has a CSS transition set.\n    \n    @function up.util.hasCssTransition\n    @return {boolean}\n    @internal\n     */\n    hasCssTransition = function(elementOrStyleHash) {\n      var duration, element, noTransition, prop, style;\n      if (isOptions(elementOrStyleHash)) {\n        style = elementOrStyleHash;\n      } else {\n        element = getElement(element);\n        style = getComputedStyle(element);\n      }\n      prop = style.transitionProperty;\n      duration = style.transitionDuration;\n      noTransition = prop === 'none' || (prop === 'all' && duration === 0);\n      return !noTransition;\n    };\n\n    /***\n    Flattens the given `array` a single level deep.\n    \n    @function up.util.flatten\n    @param {Array} array\n      An array which might contain other arrays\n    @return {Array}\n      The flattened array\n    @internal\n     */\n    flatten = function(array) {\n      var flattened, j, len, object;\n      flattened = [];\n      for (j = 0, len = array.length; j < len; j++) {\n        object = array[j];\n        if (isArray(object)) {\n          flattened = flattened.concat(object);\n        } else {\n          flattened.push(object);\n        }\n      }\n      return flattened;\n    };\n    flatMap = function(array, block) {\n      return flatten(map(array, block));\n    };\n\n    /***\n    Returns whether the given value is truthy.\n    \n    @function up.util.isTruthy\n    @internal\n     */\n    isTruthy = function(object) {\n      return !!object;\n    };\n\n    /***\n    Sets the given callback as both fulfillment and rejection handler for the given promise.\n    \n    @function up.util.always\n    @internal\n     */\n    always = function(promise, callback) {\n      return promise.then(callback, callback);\n    };\n\n    /***\n     * Registers an empty rejection handler with the given promise.\n     * This prevents browsers from printing \"Uncaught (in promise)\" to the error\n     * console when the promise is rejection.\n     *\n     * This is helpful for event handlers where it is clear that no rejection\n     * handler will be registered:\n     *\n     *     up.on('submit', 'form[up-target]', (event, $form) => {\n     *       promise = up.submit($form)\n     *       up.util.muteRejection(promise)\n     *     })\n     *\n     * Does nothing if passed a missing value.\n     *\n     * @function up.util.muteRejection\n     * @param {Promise|undefined|null} promise\n     * @return {Promise}\n     */\n    muteRejection = function(promise) {\n      return promise != null ? promise[\"catch\"](noop) : void 0;\n    };\n\n    /***\n    @function up.util.newDeferred\n    @internal\n     */\n\n    /***\n    @function up.util.newDeferred\n    @internal\n     */\n    newDeferred = function() {\n      var nativePromise, rejectFn, resolveFn;\n      resolveFn = void 0;\n      rejectFn = void 0;\n      nativePromise = new Promise(function(givenResolve, givenReject) {\n        resolveFn = givenResolve;\n        return rejectFn = givenReject;\n      });\n      nativePromise.resolve = resolveFn;\n      nativePromise.reject = rejectFn;\n      nativePromise.promise = function() {\n        return nativePromise;\n      };\n      return nativePromise;\n    };\n\n    /***\n    Calls the given block. If the block throws an exception,\n    a rejected promise is returned instead.\n    \n    @function up.util.rejectOnError\n    @internal\n     */\n    rejectOnError = function(block) {\n      var error;\n      try {\n        return block();\n      } catch (error1) {\n        error = error1;\n        return Promise.reject(error);\n      }\n    };\n    sum = function(list, block) {\n      var entry, entryValue, j, len, totalValue;\n      block = listBlock(block);\n      totalValue = 0;\n      for (j = 0, len = list.length; j < len; j++) {\n        entry = list[j];\n        entryValue = block(entry);\n        if (isGiven(entryValue)) {\n          totalValue += entryValue;\n        }\n      }\n      return totalValue;\n    };\n\n    /***\n    Returns whether the given element is a descendant of the `<body>` element.\n    \n    @function up.util.isBodyDescendant\n    @internal\n     */\n    isBodyDescendant = function(element) {\n      return $(element).parents('body').length > 0;\n    };\n    isBasicObjectProperty = function(k) {\n      return Object.prototype.hasOwnProperty(k);\n    };\n    isEqual = function(a, b) {\n      if (typeof a !== typeof b) {\n        return false;\n      } else if (isArray(a)) {\n        return a.length === b.length && all(a, function(elem, index) {\n          return isEqual(elem, b[index]);\n        });\n      } else if (isObject(a)) {\n        return fail('isEqual cannot compare objects yet');\n      } else {\n        return a === b;\n      }\n    };\n    splitValues = function(string, separator) {\n      var values;\n      if (separator == null) {\n        separator = ' ';\n      }\n      values = string.split(separator);\n      values = map(values, trim);\n      values = select(values, isPresent);\n      return values;\n    };\n    return {\n      offsetParent: offsetParent,\n      fixedToAbsolute: fixedToAbsolute,\n      isFixed: isFixed,\n      presentAttr: presentAttr,\n      parseUrl: parseUrl,\n      normalizeUrl: normalizeUrl,\n      normalizeMethod: normalizeMethod,\n      methodAllowsPayload: methodAllowsPayload,\n      createElementFromHtml: createElementFromHtml,\n      $createElementFromSelector: $createElementFromSelector,\n      $createPlaceholder: $createPlaceholder,\n      selectorForElement: selectorForElement,\n      attributeSelector: attributeSelector,\n      assign: assign,\n      assignPolyfill: assignPolyfill,\n      copy: copy,\n      merge: merge,\n      options: newOptions,\n      option: option,\n      fail: fail,\n      each: each,\n      eachIterator: eachIterator,\n      map: map,\n      flatMap: flatMap,\n      times: times,\n      any: any,\n      all: all,\n      detect: detect,\n      select: select,\n      reject: reject,\n      intersect: intersect,\n      compact: compact,\n      uniq: uniq,\n      uniqBy: uniqBy,\n      last: last,\n      isNull: isNull,\n      isDefined: isDefined,\n      isUndefined: isUndefined,\n      isGiven: isGiven,\n      isMissing: isMissing,\n      isPresent: isPresent,\n      isBlank: isBlank,\n      presence: presence,\n      isObject: isObject,\n      isFunction: isFunction,\n      isString: isString,\n      isBoolean: isBoolean,\n      isNumber: isNumber,\n      isElement: isElement,\n      isJQuery: isJQuery,\n      isPromise: isPromise,\n      isOptions: isOptions,\n      isArray: isArray,\n      isFormData: isFormData,\n      isUnmodifiedKeyEvent: isUnmodifiedKeyEvent,\n      isUnmodifiedMouseEvent: isUnmodifiedMouseEvent,\n      nullJQuery: nullJQuery,\n      element: getElement,\n      setTimer: setTimer,\n      nextFrame: nextFrame,\n      measure: measure,\n      addClass: addClass,\n      removeClass: removeClass,\n      hasClass: hasClass,\n      addTemporaryClass: addTemporaryClass,\n      writeTemporaryStyle: writeTemporaryStyle,\n      forceRepaint: forceRepaint,\n      concludeCssTransition: concludeCssTransition,\n      escapePressed: escapePressed,\n      copyAttributes: copyAttributes,\n      selectInSubtree: selectInSubtree,\n      selectInDynasty: selectInDynasty,\n      contains: contains,\n      toArray: toArray,\n      castedAttr: castedAttr,\n      jsonAttr: jsonAttr,\n      clientSize: clientSize,\n      only: only,\n      except: except,\n      trim: trim,\n      unresolvablePromise: unresolvablePromise,\n      setMissingAttrs: setMissingAttrs,\n      remove: remove,\n      memoize: memoize,\n      scrollbarWidth: scrollbarWidth,\n      documentHasVerticalScrollbar: documentHasVerticalScrollbar,\n      config: config,\n      openConfig: openConfig,\n      unwrapElement: unwrapElement,\n      camelCase: camelCase,\n      camelCaseKeys: camelCaseKeys,\n      kebabCase: kebabCase,\n      kebabCaseKeys: kebabCaseKeys,\n      error: fail,\n      pluckData: pluckData,\n      pluckKey: pluckKey,\n      renameKey: renameKey,\n      deprecateRenamedKey: deprecateRenamedKey,\n      extractOptions: extractOptions,\n      isDetached: isDetached,\n      noop: noop,\n      asyncNoop: asyncNoop,\n      opacity: opacity,\n      whenReady: whenReady,\n      identity: identity,\n      escapeHtml: escapeHtml,\n      DivertibleChain: DivertibleChain,\n      submittedValue: submittedValue,\n      sequence: sequence,\n      promiseTimer: promiseTimer,\n      previewable: previewable,\n      evalOption: evalOption,\n      horizontalScreenHalf: horizontalScreenHalf,\n      detachWith: detachWith,\n      flatten: flatten,\n      isTruthy: isTruthy,\n      isSingletonElement: isSingletonElement,\n      newDeferred: newDeferred,\n      always: always,\n      muteRejection: muteRejection,\n      rejectOnError: rejectOnError,\n      isBodyDescendant: isBodyDescendant,\n      isBasicObjectProperty: isBasicObjectProperty,\n      isCrossDomain: isCrossDomain,\n      microtask: microtask,\n      isEqual: isEqual,\n      hide: hide,\n      cssLength: cssLength,\n      readComputedStyle: readComputedStyle,\n      readComputedStyleNumber: readComputedStyleNumber,\n      readInlineStyle: readInlineStyle,\n      writeInlineStyle: writeInlineStyle,\n      hasCssTransition: hasCssTransition,\n      splitValues: splitValues,\n      sum: sum,\n      values: objectValues\n    };\n  })(jQuery);\n\n  up.fail = up.util.fail;\n\n}).call(this);\n(function() {\n  var u,\n    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },\n    slice = [].slice;\n\n  u = up.util;\n\n\n  /***\n  @class up.Cache\n  @internal\n   */\n\n  up.Cache = (function() {\n\n    /***\n    @constructor\n    @param {number|Function() :number} [config.size]\n      Maximum number of cache entries.\n      Set to `undefined` to not limit the cache size.\n    @param {number|Function(): number} [config.expiry]\n      The number of milliseconds after which a cache entry\n      will be discarded.\n    @param {string} [config.logPrefix]\n      A prefix for log entries printed by this cache object.\n    @param {Function(any): string} [config.key]\n      A function that takes an argument and returns a string key\n      for storage. If omitted, `toString()` is called on the argument.\n    @param {Function(any): boolean} [config.cachable]\n      A function that takes a potential cache entry and returns whether\n      this entry  can be stored in the hash. If omitted, all entries are considered\n      cachable.\n     */\n    function Cache(config) {\n      this.config = config != null ? config : {};\n      this.get = bind(this.get, this);\n      this.isFresh = bind(this.isFresh, this);\n      this.remove = bind(this.remove, this);\n      this.set = bind(this.set, this);\n      this.timestamp = bind(this.timestamp, this);\n      this.alias = bind(this.alias, this);\n      this.makeRoomForAnotherKey = bind(this.makeRoomForAnotherKey, this);\n      this.keys = bind(this.keys, this);\n      this.log = bind(this.log, this);\n      this.clear = bind(this.clear, this);\n      this.isCachable = bind(this.isCachable, this);\n      this.isEnabled = bind(this.isEnabled, this);\n      this.normalizeStoreKey = bind(this.normalizeStoreKey, this);\n      this.expiryMillis = bind(this.expiryMillis, this);\n      this.maxKeys = bind(this.maxKeys, this);\n      this.store = this.config.store || new up.store.Memory();\n    }\n\n    Cache.prototype.maxKeys = function() {\n      return u.evalOption(this.config.size);\n    };\n\n    Cache.prototype.expiryMillis = function() {\n      return u.evalOption(this.config.expiry);\n    };\n\n    Cache.prototype.normalizeStoreKey = function(key) {\n      if (this.config.key) {\n        return this.config.key(key);\n      } else {\n        return key.toString();\n      }\n    };\n\n    Cache.prototype.isEnabled = function() {\n      return this.maxKeys() !== 0 && this.expiryMillis() !== 0;\n    };\n\n    Cache.prototype.isCachable = function(key) {\n      if (this.config.cachable) {\n        return this.config.cachable(key);\n      } else {\n        return true;\n      }\n    };\n\n    Cache.prototype.clear = function() {\n      return this.store.clear();\n    };\n\n    Cache.prototype.log = function() {\n      var args;\n      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n      if (this.config.logPrefix) {\n        args[0] = \"[\" + this.config.logPrefix + \"] \" + args[0];\n        return up.puts.apply(up, args);\n      }\n    };\n\n    Cache.prototype.keys = function() {\n      return this.store.keys();\n    };\n\n    Cache.prototype.makeRoomForAnotherKey = function() {\n      var max, oldestKey, oldestTimestamp, storeKeys;\n      storeKeys = u.copy(this.keys());\n      max = this.maxKeys();\n      if (max && storeKeys.length >= max) {\n        oldestKey = void 0;\n        oldestTimestamp = void 0;\n        u.each(storeKeys, (function(_this) {\n          return function(key) {\n            var entry, timestamp;\n            entry = _this.store.get(key);\n            timestamp = entry.timestamp;\n            if (!oldestTimestamp || oldestTimestamp > timestamp) {\n              oldestKey = key;\n              return oldestTimestamp = timestamp;\n            }\n          };\n        })(this));\n        if (oldestKey) {\n          return this.store.remove(oldestKey);\n        }\n      }\n    };\n\n    Cache.prototype.alias = function(oldKey, newKey) {\n      var value;\n      value = this.get(oldKey, {\n        silent: true\n      });\n      if (u.isDefined(value)) {\n        return this.set(newKey, value);\n      }\n    };\n\n    Cache.prototype.timestamp = function() {\n      return (new Date()).valueOf();\n    };\n\n    Cache.prototype.set = function(key, value) {\n      var storeKey, timestampedValue;\n      if (this.isEnabled() && this.isCachable(key)) {\n        this.makeRoomForAnotherKey();\n        storeKey = this.normalizeStoreKey(key);\n        this.log(\"Setting entry %o to %o\", storeKey, value);\n        timestampedValue = {\n          timestamp: this.timestamp(),\n          value: value\n        };\n        return this.store.set(storeKey, timestampedValue);\n      }\n    };\n\n    Cache.prototype.remove = function(key) {\n      var storeKey;\n      if (this.isCachable(key)) {\n        storeKey = this.normalizeStoreKey(key);\n        return this.store.remove(storeKey);\n      }\n    };\n\n    Cache.prototype.isFresh = function(entry) {\n      var millis, timeSinceTouch;\n      millis = this.expiryMillis();\n      if (millis) {\n        timeSinceTouch = this.timestamp() - entry.timestamp;\n        return timeSinceTouch < millis;\n      } else {\n        return true;\n      }\n    };\n\n    Cache.prototype.get = function(key, options) {\n      var entry;\n      if (options == null) {\n        options = {};\n      }\n      if (this.isCachable(key) && (entry = this.store.get(this.normalizeStoreKey(key)))) {\n        if (this.isFresh(entry)) {\n          if (!options.silent) {\n            this.log(\"Cache hit for '%s'\", key);\n          }\n          return entry.value;\n        } else {\n          if (!options.silent) {\n            this.log(\"Discarding stale cache entry for '%s'\", key);\n          }\n          this.remove(key);\n          return void 0;\n        }\n      } else {\n        if (!options.silent) {\n          this.log(\"Cache miss for '%s'\", key);\n        }\n        return void 0;\n      }\n    };\n\n    return Cache;\n\n  })();\n\n}).call(this);\n(function() {\n  var u,\n    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },\n    slice = [].slice;\n\n  u = up.util;\n\n  up.Record = (function() {\n    Record.prototype.fields = function() {\n      throw 'Return an array of property names';\n    };\n\n    function Record(options) {\n      this.copy = bind(this.copy, this);\n      this.attributes = bind(this.attributes, this);\n      u.assign(this, this.attributes(options));\n    }\n\n    Record.prototype.attributes = function(source) {\n      if (source == null) {\n        source = this;\n      }\n      return u.only.apply(u, [source].concat(slice.call(this.fields())));\n    };\n\n    Record.prototype.copy = function(changes) {\n      var attributesWithChanges;\n      if (changes == null) {\n        changes = {};\n      }\n      attributesWithChanges = u.merge(this.attributes(), changes);\n      return new this.constructor(attributesWithChanges);\n    };\n\n    return Record;\n\n  })();\n\n}).call(this);\n(function() {\n  var u;\n\n  u = up.util;\n\n  up.CompilePass = (function() {\n    function CompilePass($root, compilers, options) {\n      this.$root = $root;\n      this.compilers = compilers;\n      if (options == null) {\n        options = {};\n      }\n      this.root = this.$root[0];\n      this.$skipSubtrees = $(options.skip);\n      if (!(this.$skipSubtrees.length && this.root.querySelector('[up-keep]'))) {\n        this.$skipSubtrees = void 0;\n      }\n    }\n\n    CompilePass.prototype.compile = function() {\n      return up.log.group(\"Compiling fragment %o\", this.root, (function(_this) {\n        return function() {\n          var compiler, i, len, ref, results;\n          ref = _this.compilers;\n          results = [];\n          for (i = 0, len = ref.length; i < len; i++) {\n            compiler = ref[i];\n            results.push(_this.runCompiler(compiler));\n          }\n          return results;\n        };\n      })(this));\n    };\n\n    CompilePass.prototype.runCompiler = function(compiler) {\n      var $matches;\n      $matches = this.$select(compiler.selector);\n      if (!$matches.length) {\n        return;\n      }\n      return up.log.group((!compiler.isSystem ? \"Compiling '%s' on %d element(s)\" : void 0), compiler.selector, $matches.length, (function(_this) {\n        return function() {\n          var i, keepValue, len, match, value;\n          if (compiler.batch) {\n            _this.compileBatch(compiler, $matches);\n          } else {\n            for (i = 0, len = $matches.length; i < len; i++) {\n              match = $matches[i];\n              _this.compileOneElement(compiler, $(match));\n            }\n          }\n          if (keepValue = compiler.keep) {\n            value = u.isString(keepValue) ? keepValue : '';\n            return $matches.attr('up-keep', value);\n          }\n        };\n      })(this));\n    };\n\n    CompilePass.prototype.compileOneElement = function(compiler, $element) {\n      var compileArgs, data, destructor, result;\n      compileArgs = [$element];\n      if (compiler.length !== 1) {\n        data = up.syntax.data($element);\n        compileArgs.push(data);\n      }\n      result = compiler.apply($element[0], compileArgs);\n      if (destructor = this.normalizeDestructor(result)) {\n        return up.syntax.destructor($element, destructor);\n      }\n    };\n\n    CompilePass.prototype.compileBatch = function(compiler, $elements) {\n      var compileArgs, dataList, result;\n      compileArgs = [$elements];\n      if (compiler.length !== 1) {\n        dataList = u.map($elements, up.syntax.data);\n        compileArgs.push(dataList);\n      }\n      result = compiler.apply($elements.get(), compileArgs);\n      if (this.normalizeDestructor(result)) {\n        return up.fail('Compilers with { batch: true } cannot return destructors');\n      }\n    };\n\n    CompilePass.prototype.normalizeDestructor = function(result) {\n      if (u.isFunction(result)) {\n        return result;\n      } else if (u.isArray(result) && u.all(result, u.isFunction)) {\n        up.warn('up.compiler(): Returning an array of destructor functions is deprecated. Return a single function instead.');\n        return u.sequence.apply(u, result);\n      }\n    };\n\n    CompilePass.prototype.$select = function(selector) {\n      var $matches, $skipSubtrees;\n      if (u.isFunction(selector)) {\n        selector = selector();\n      }\n      $matches = u.selectInSubtree(this.$root, selector);\n      if ($skipSubtrees = this.$skipSubtrees) {\n        $matches = $matches.filter(function() {\n          var $match;\n          $match = $(this);\n          return $match.closest($skipSubtrees).length === 0;\n        });\n      }\n      return $matches;\n    };\n\n    return CompilePass;\n\n  })();\n\n}).call(this);\n(function() {\n  var u,\n    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };\n\n  u = up.util;\n\n  up.CssTransition = (function() {\n    function CssTransition($element, lastFrame, options) {\n      this.startMotion = bind(this.startMotion, this);\n      this.resumeOldTransition = bind(this.resumeOldTransition, this);\n      this.pauseOldTransition = bind(this.pauseOldTransition, this);\n      this.finish = bind(this.finish, this);\n      this.onTransitionEnd = bind(this.onTransitionEnd, this);\n      this.stopListenToTransitionEnd = bind(this.stopListenToTransitionEnd, this);\n      this.listenToTransitionEnd = bind(this.listenToTransitionEnd, this);\n      this.stopFallbackTimer = bind(this.stopFallbackTimer, this);\n      this.startFallbackTimer = bind(this.startFallbackTimer, this);\n      this.onFinishEvent = bind(this.onFinishEvent, this);\n      this.stopListenToFinishEvent = bind(this.stopListenToFinishEvent, this);\n      this.listenToFinishEvent = bind(this.listenToFinishEvent, this);\n      this.start = bind(this.start, this);\n      this.$element = $element;\n      this.element = u.element($element);\n      this.lastFrameCamel = u.camelCaseKeys(lastFrame);\n      this.lastFrameKebab = u.kebabCaseKeys(lastFrame);\n      this.lastFrameKeysKebab = Object.keys(this.lastFrameKebab);\n      this.finishEvent = options.finishEvent;\n      this.duration = options.duration;\n      this.delay = options.delay;\n      this.totalDuration = this.delay + this.duration;\n      this.easing = options.easing;\n      this.finished = false;\n    }\n\n    CssTransition.prototype.start = function() {\n      if (this.lastFrameKeysKebab.length === 0) {\n        this.finished = true;\n        return Promise.resolve();\n      }\n      this.deferred = u.newDeferred();\n      this.pauseOldTransition();\n      this.startTime = new Date();\n      this.startFallbackTimer();\n      this.listenToFinishEvent();\n      this.listenToTransitionEnd();\n      this.startMotion();\n      return this.deferred.promise();\n    };\n\n    CssTransition.prototype.listenToFinishEvent = function() {\n      if (this.finishEvent) {\n        return this.$element.on(this.finishEvent, this.onFinishEvent);\n      }\n    };\n\n    CssTransition.prototype.stopListenToFinishEvent = function() {\n      if (this.finishEvent) {\n        return this.$element.off(this.finishEvent, this.onFinishEvent);\n      }\n    };\n\n    CssTransition.prototype.onFinishEvent = function(event) {\n      event.stopPropagation();\n      return this.finish();\n    };\n\n    CssTransition.prototype.startFallbackTimer = function() {\n      var timingTolerance;\n      timingTolerance = 100;\n      return this.fallbackTimer = u.setTimer(this.totalDuration + timingTolerance, (function(_this) {\n        return function() {\n          return _this.finish();\n        };\n      })(this));\n    };\n\n    CssTransition.prototype.stopFallbackTimer = function() {\n      return clearTimeout(this.fallbackTimer);\n    };\n\n    CssTransition.prototype.listenToTransitionEnd = function() {\n      return this.$element.on('transitionend', this.onTransitionEnd);\n    };\n\n    CssTransition.prototype.stopListenToTransitionEnd = function() {\n      return this.$element.off('transitionend', this.onTransitionEnd);\n    };\n\n    CssTransition.prototype.onTransitionEnd = function(event) {\n      var completedPropertyKebab, elapsed;\n      if (event.target !== this.element) {\n        return;\n      }\n      elapsed = new Date() - this.startTime;\n      if (!(elapsed > 0.25 * this.totalDuration)) {\n        return;\n      }\n      completedPropertyKebab = event.originalEvent.propertyName;\n      if (!u.contains(this.lastFrameKeysKebab, completedPropertyKebab)) {\n        return;\n      }\n      return this.finish();\n    };\n\n    CssTransition.prototype.finish = function() {\n      if (this.finished) {\n        return;\n      }\n      this.finished = true;\n      this.stopFallbackTimer();\n      this.stopListenToFinishEvent();\n      this.stopListenToTransitionEnd();\n      u.concludeCssTransition(this.element);\n      this.resumeOldTransition();\n      return this.deferred.resolve();\n    };\n\n    CssTransition.prototype.pauseOldTransition = function() {\n      var oldTransition, oldTransitionFrameCamel, oldTransitionFrameKebab, oldTransitionProperties;\n      oldTransition = u.readComputedStyle(this.element, ['transitionProperty', 'transitionDuration', 'transitionDelay', 'transitionTimingFunction']);\n      if (u.hasCssTransition(oldTransition)) {\n        if (oldTransition.transitionProperty !== 'all') {\n          oldTransitionProperties = oldTransition.transitionProperty.split(/\\s*,\\s*/);\n          oldTransitionFrameKebab = u.readComputedStyle(this.element, oldTransitionProperties);\n          oldTransitionFrameCamel = u.camelCaseKeys(oldTransitionFrameKebab);\n          this.setOldTransitionTargetFrame = u.writeTemporaryStyle(this.element, oldTransitionFrameCamel);\n        }\n        return this.setOldTransition = u.concludeCssTransition(this.element);\n      }\n    };\n\n    CssTransition.prototype.resumeOldTransition = function() {\n      if (typeof this.setOldTransitionTargetFrame === \"function\") {\n        this.setOldTransitionTargetFrame();\n      }\n      return typeof this.setOldTransition === \"function\" ? this.setOldTransition() : void 0;\n    };\n\n    CssTransition.prototype.startMotion = function() {\n      u.writeInlineStyle(this.element, {\n        transitionProperty: Object.keys(this.lastFrameKebab).join(', '),\n        transitionDuration: this.duration + \"ms\",\n        transitionDelay: this.delay + \"ms\",\n        transitionTimingFunction: this.easing\n      });\n      return u.writeInlineStyle(this.element, this.lastFrameCamel);\n    };\n\n    return CssTransition;\n\n  })();\n\n}).call(this);\n(function() {\n  var u,\n    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };\n\n  u = up.util;\n\n  up.ExtractCascade = (function() {\n    function ExtractCascade(selector, options) {\n      this.oldPlanNotFound = bind(this.oldPlanNotFound, this);\n      this.matchingPlanNotFound = bind(this.matchingPlanNotFound, this);\n      this.bestMatchingSteps = bind(this.bestMatchingSteps, this);\n      this.bestPreflightSelector = bind(this.bestPreflightSelector, this);\n      this.detectPlan = bind(this.detectPlan, this);\n      this.matchingPlan = bind(this.matchingPlan, this);\n      this.newPlan = bind(this.newPlan, this);\n      this.oldPlan = bind(this.oldPlan, this);\n      this.options = u.options(options, {\n        humanizedTarget: 'selector',\n        layer: 'auto'\n      });\n      this.options.transition = u.option(this.options.transition, this.options.animation);\n      this.options.hungry = u.option(this.options.hungry, true);\n      this.candidates = this.buildCandidates(selector);\n      this.plans = u.map(this.candidates, (function(_this) {\n        return function(candidate, i) {\n          var planOptions;\n          planOptions = u.copy(_this.options);\n          if (i > 0) {\n            planOptions.transition = u.option(up.dom.config.fallbackTransition, _this.options.transition);\n          }\n          return new up.ExtractPlan(candidate, planOptions);\n        };\n      })(this));\n    }\n\n    ExtractCascade.prototype.buildCandidates = function(selector) {\n      var candidates;\n      candidates = [selector, this.options.fallback, up.dom.config.fallbacks];\n      candidates = u.flatten(candidates);\n      candidates = u.select(candidates, u.isTruthy);\n      candidates = u.uniq(candidates);\n      if (this.options.fallback === false || this.options.provideTarget) {\n        candidates = [candidates[0]];\n      }\n      return candidates;\n    };\n\n    ExtractCascade.prototype.oldPlan = function() {\n      return this.detectPlan('oldExists');\n    };\n\n    ExtractCascade.prototype.newPlan = function() {\n      return this.detectPlan('newExists');\n    };\n\n    ExtractCascade.prototype.matchingPlan = function() {\n      return this.detectPlan('matchExists');\n    };\n\n    ExtractCascade.prototype.detectPlan = function(checker) {\n      return u.detect(this.plans, function(plan) {\n        return plan[checker]();\n      });\n    };\n\n    ExtractCascade.prototype.bestPreflightSelector = function() {\n      var plan;\n      if (this.options.provideTarget) {\n        plan = this.plans[0];\n      } else {\n        plan = this.oldPlan();\n      }\n      if (plan) {\n        plan.resolveNesting();\n        return plan.selector();\n      } else {\n        return this.oldPlanNotFound();\n      }\n    };\n\n    ExtractCascade.prototype.bestMatchingSteps = function() {\n      var plan;\n      if (plan = this.matchingPlan()) {\n        plan.addHungrySteps();\n        plan.resolveNesting();\n        return plan.steps;\n      } else {\n        return this.matchingPlanNotFound();\n      }\n    };\n\n    ExtractCascade.prototype.matchingPlanNotFound = function() {\n      var inspectAction, message;\n      if (this.newPlan()) {\n        return this.oldPlanNotFound();\n      } else {\n        if (this.oldPlan()) {\n          message = \"Could not find \" + this.options.humanizedTarget + \" in response\";\n        } else {\n          message = \"Could not match \" + this.options.humanizedTarget + \" in current page and response\";\n        }\n        if (this.options.inspectResponse) {\n          inspectAction = {\n            label: 'Open response',\n            callback: this.options.inspectResponse\n          };\n        }\n        return up.fail([message + \" (tried %o)\", this.candidates], {\n          action: inspectAction\n        });\n      }\n    };\n\n    ExtractCascade.prototype.oldPlanNotFound = function() {\n      var layerProse;\n      layerProse = this.options.layer;\n      if (layerProse === 'auto') {\n        layerProse = 'page, modal or popup';\n      }\n      return up.fail(\"Could not find \" + this.options.humanizedTarget + \" in current \" + layerProse + \" (tried %o)\", this.candidates);\n    };\n\n    return ExtractCascade;\n\n  })();\n\n}).call(this);\n(function() {\n  var u,\n    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };\n\n  u = up.util;\n\n  up.ExtractPlan = (function() {\n    function ExtractPlan(selector, options) {\n      this.addHungrySteps = bind(this.addHungrySteps, this);\n      this.parseSteps = bind(this.parseSteps, this);\n      this.selector = bind(this.selector, this);\n      this.resolveNesting = bind(this.resolveNesting, this);\n      this.addSteps = bind(this.addSteps, this);\n      this.matchExists = bind(this.matchExists, this);\n      this.newExists = bind(this.newExists, this);\n      this.oldExists = bind(this.oldExists, this);\n      this.findNew = bind(this.findNew, this);\n      this.findOld = bind(this.findOld, this);\n      var originalSelector;\n      this.reveal = options.reveal;\n      this.origin = options.origin;\n      this.hungry = options.hungry;\n      this.transition = options.transition;\n      this.response = options.response;\n      this.oldLayer = options.layer;\n      originalSelector = up.dom.resolveSelector(selector, this.origin);\n      this.parseSteps(originalSelector);\n    }\n\n    ExtractPlan.prototype.findOld = function() {\n      return u.each(this.steps, (function(_this) {\n        return function(step) {\n          return step.$old = up.dom.first(step.selector, {\n            layer: _this.oldLayer\n          });\n        };\n      })(this));\n    };\n\n    ExtractPlan.prototype.findNew = function() {\n      return u.each(this.steps, (function(_this) {\n        return function(step) {\n          return step.$new = _this.response.first(step.selector);\n        };\n      })(this));\n    };\n\n    ExtractPlan.prototype.oldExists = function() {\n      this.findOld();\n      return u.all(this.steps, function(step) {\n        return step.$old;\n      });\n    };\n\n    ExtractPlan.prototype.newExists = function() {\n      this.findNew();\n      return u.all(this.steps, function(step) {\n        return step.$new;\n      });\n    };\n\n    ExtractPlan.prototype.matchExists = function() {\n      return this.oldExists() && this.newExists();\n    };\n\n    ExtractPlan.prototype.addSteps = function(steps) {\n      return this.steps = this.steps.concat(steps);\n    };\n\n    ExtractPlan.prototype.resolveNesting = function() {\n      var compressed;\n      if (this.steps.length < 2) {\n        return;\n      }\n      compressed = u.copy(this.steps);\n      compressed = u.uniqBy(compressed, function(step) {\n        return step.$old[0];\n      });\n      compressed = u.select(compressed, (function(_this) {\n        return function(candidateStep, candidateIndex) {\n          return u.all(compressed, function(rivalStep, rivalIndex) {\n            var candidateElement, rivalElement;\n            if (rivalIndex === candidateIndex) {\n              return true;\n            } else {\n              candidateElement = candidateStep.$old[0];\n              rivalElement = rivalStep.$old[0];\n              return rivalStep.pseudoClass || !$.contains(rivalElement, candidateElement);\n            }\n          });\n        };\n      })(this));\n      compressed[0].reveal = this.steps[0].reveal;\n      return this.steps = compressed;\n    };\n\n    ExtractPlan.prototype.selector = function() {\n      return u.map(this.steps, 'expression').join(', ');\n    };\n\n    ExtractPlan.prototype.parseSteps = function(originalSelector) {\n      var comma, disjunction;\n      comma = /\\ *,\\ */;\n      this.steps = [];\n      disjunction = originalSelector.split(comma);\n      return u.each(disjunction, (function(_this) {\n        return function(expression, i) {\n          var doReveal, expressionParts, pseudoClass, selector;\n          expressionParts = expression.match(/^(.+?)(?:\\:(before|after))?$/);\n          expressionParts || up.fail('Could not parse selector literal \"%s\"', expression);\n          selector = expressionParts[1];\n          if (selector === 'html') {\n            selector = 'body';\n          }\n          pseudoClass = expressionParts[2];\n          doReveal = i === 0 ? _this.reveal : false;\n          return _this.steps.push({\n            expression: expression,\n            selector: selector,\n            pseudoClass: pseudoClass,\n            transition: _this.transition,\n            origin: _this.origin,\n            reveal: doReveal\n          });\n        };\n      })(this));\n    };\n\n    ExtractPlan.prototype.addHungrySteps = function() {\n      var $hungries, $hungry, $newHungry, hungry, hungrySteps, j, len, selector, transition;\n      hungrySteps = [];\n      if (this.hungry) {\n        $hungries = $(up.radio.hungrySelector());\n        transition = u.option(up.radio.config.hungryTransition, this.transition);\n        for (j = 0, len = $hungries.length; j < len; j++) {\n          hungry = $hungries[j];\n          $hungry = $(hungry);\n          selector = u.selectorForElement($hungry);\n          if ($newHungry = this.response.first(selector)) {\n            hungrySteps.push({\n              selector: selector,\n              $old: $hungry,\n              $new: $newHungry,\n              transition: transition,\n              reveal: false,\n              origin: null\n            });\n          }\n        }\n      }\n      return this.addSteps(hungrySteps);\n    };\n\n    return ExtractPlan;\n\n  })();\n\n}).call(this);\n(function() {\n  var u;\n\n  u = up.util;\n\n  up.ExtractStep = (function() {\n    function ExtractStep() {}\n\n    return ExtractStep;\n\n  })();\n\n}).call(this);\n(function() {\n  var u,\n    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };\n\n  u = up.util;\n\n  up.FieldObserver = (function() {\n    var CHANGE_EVENTS;\n\n    CHANGE_EVENTS = 'input change';\n\n    function FieldObserver($field, options) {\n      this.$field = $field;\n      this.check = bind(this.check, this);\n      this.readFieldValue = bind(this.readFieldValue, this);\n      this.requestCallback = bind(this.requestCallback, this);\n      this.isNewValue = bind(this.isNewValue, this);\n      this.scheduleTimer = bind(this.scheduleTimer, this);\n      this.cancelTimer = bind(this.cancelTimer, this);\n      this.stop = bind(this.stop, this);\n      this.start = bind(this.start, this);\n      this.delay = options.delay;\n      this.callback = options.callback;\n    }\n\n    FieldObserver.prototype.start = function() {\n      this.scheduledValue = null;\n      this.processedValue = this.readFieldValue();\n      this.currentTimer = void 0;\n      this.currentCallback = void 0;\n      return this.$field.on(CHANGE_EVENTS, this.check);\n    };\n\n    FieldObserver.prototype.stop = function() {\n      this.$field.off(CHANGE_EVENTS, this.check);\n      return this.cancelTimer();\n    };\n\n    FieldObserver.prototype.cancelTimer = function() {\n      clearTimeout(this.currentTimer);\n      return this.currentTimer = void 0;\n    };\n\n    FieldObserver.prototype.scheduleTimer = function() {\n      return this.currentTimer = u.setTimer(this.delay, (function(_this) {\n        return function() {\n          _this.currentTimer = void 0;\n          return _this.requestCallback();\n        };\n      })(this));\n    };\n\n    FieldObserver.prototype.isNewValue = function(value) {\n      return value !== this.processedValue && (this.scheduledValue === null || this.scheduledValue !== value);\n    };\n\n    FieldObserver.prototype.requestCallback = function() {\n      var callbackDone;\n      if (this.scheduledValue !== null && !this.currentTimer && !this.currentCallback) {\n        this.processedValue = this.scheduledValue;\n        this.scheduledValue = null;\n        this.currentCallback = (function(_this) {\n          return function() {\n            return _this.callback.call(_this.$field.get(0), _this.processedValue, _this.$field);\n          };\n        })(this);\n        callbackDone = Promise.resolve(this.currentCallback());\n        return u.always(callbackDone, (function(_this) {\n          return function() {\n            _this.currentCallback = void 0;\n            return _this.requestCallback();\n          };\n        })(this));\n      }\n    };\n\n    FieldObserver.prototype.readFieldValue = function() {\n      return u.submittedValue(this.$field);\n    };\n\n    FieldObserver.prototype.check = function() {\n      var value;\n      value = this.readFieldValue();\n      if (this.isNewValue(value)) {\n        this.scheduledValue = value;\n        this.cancelTimer();\n        return this.scheduleTimer();\n      }\n    };\n\n    return FieldObserver;\n\n  })();\n\n}).call(this);\n(function() {\n\n\n}).call(this);\n(function() {\n  var u,\n    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },\n    slice = [].slice;\n\n  u = up.util;\n\n  up.FollowVariant = (function() {\n    function FollowVariant(selector, options) {\n      this.matchesLink = bind(this.matchesLink, this);\n      this.preloadLink = bind(this.preloadLink, this);\n      this.followLink = bind(this.followLink, this);\n      this.fullSelector = bind(this.fullSelector, this);\n      this.onMousedown = bind(this.onMousedown, this);\n      this.onClick = bind(this.onClick, this);\n      this.followNow = options.follow;\n      this.preloadNow = options.preload;\n      this.selectors = selector.split(/\\s*,\\s*/);\n    }\n\n    FollowVariant.prototype.onClick = function(event, $link) {\n      if (up.link.shouldProcessEvent(event, $link)) {\n        if ($link.is('[up-instant]')) {\n          return up.bus.haltEvent(event);\n        } else {\n          up.bus.consumeAction(event);\n          return this.followLink($link);\n        }\n      } else {\n        return up.link.allowDefault(event);\n      }\n    };\n\n    FollowVariant.prototype.onMousedown = function(event, $link) {\n      if (up.link.shouldProcessEvent(event, $link)) {\n        up.bus.consumeAction(event);\n        return this.followLink($link);\n      }\n    };\n\n    FollowVariant.prototype.fullSelector = function(additionalClause) {\n      var parts;\n      if (additionalClause == null) {\n        additionalClause = '';\n      }\n      parts = [];\n      this.selectors.forEach(function(variantSelector) {\n        var i, len, ref, results, tagSelector;\n        ref = ['a', '[up-href]'];\n        results = [];\n        for (i = 0, len = ref.length; i < len; i++) {\n          tagSelector = ref[i];\n          results.push(parts.push(\"\" + tagSelector + variantSelector + additionalClause));\n        }\n        return results;\n      });\n      return parts.join(', ');\n    };\n\n    FollowVariant.prototype.registerEvents = function() {\n      up.on('click', this.fullSelector(), (function(_this) {\n        return function() {\n          var args;\n          args = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n          return u.muteRejection(_this.onClick.apply(_this, args));\n        };\n      })(this));\n      return up.on('mousedown', this.fullSelector('[up-instant]'), (function(_this) {\n        return function() {\n          var args;\n          args = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n          return u.muteRejection(_this.onMousedown.apply(_this, args));\n        };\n      })(this));\n    };\n\n    FollowVariant.prototype.followLink = function($link, options) {\n      var followEventAttrs;\n      options = u.options(options);\n      followEventAttrs = {\n        message: 'Following link',\n        $link: $link,\n        $element: $link\n      };\n      return up.bus.whenEmitted('up:link:follow', followEventAttrs).then((function(_this) {\n        return function() {\n          return up.feedback.start($link, options, function() {\n            return _this.followNow($link, options);\n          });\n        };\n      })(this));\n    };\n\n    FollowVariant.prototype.preloadLink = function($link, options) {\n      options = u.options(options);\n      return this.preloadNow($link, options);\n    };\n\n    FollowVariant.prototype.matchesLink = function($link) {\n      return $link.is(this.fullSelector());\n    };\n\n    return FollowVariant;\n\n  })();\n\n}).call(this);\n(function() {\n  var u;\n\n  u = up.util;\n\n  up.HtmlParser = (function() {\n    function HtmlParser(html) {\n      this.html = html;\n      this.wrapNoscriptInHtml();\n      this.parsedDoc = u.createElementFromHtml(this.html);\n    }\n\n    HtmlParser.prototype.title = function() {\n      var ref;\n      return (ref = this.parsedDoc.querySelector(\"head title\")) != null ? ref.textContent : void 0;\n    };\n\n    HtmlParser.prototype.first = function(selector) {\n      var match;\n      if (match = $.find(selector, this.parsedDoc)[0]) {\n        return $(match);\n      }\n    };\n\n    HtmlParser.prototype.prepareForInsertion = function($element) {\n      var element;\n      element = $element[0];\n      this.unwrapNoscriptInElement(element);\n      return $(element);\n    };\n\n    HtmlParser.prototype.wrapNoscriptInHtml = function() {\n      var noscriptPattern;\n      noscriptPattern = /<noscript[^>]*>((.|\\s)*?)<\\/noscript>/ig;\n      return this.html = this.html.replace(noscriptPattern, (function(_this) {\n        return function(match, content) {\n          _this.didWrapNoscript = true;\n          return '<div class=\"up-noscript\" data-html=\"' + u.escapeHtml(content) + '\"></div>';\n        };\n      })(this));\n    };\n\n    HtmlParser.prototype.unwrapNoscriptInElement = function(element) {\n      var i, len, noscript, results, wrappedContent, wrappedNoscript, wrappedNoscripts;\n      if (!this.didWrapNoscript) {\n        return;\n      }\n      wrappedNoscripts = element.querySelectorAll('.up-noscript');\n      results = [];\n      for (i = 0, len = wrappedNoscripts.length; i < len; i++) {\n        wrappedNoscript = wrappedNoscripts[i];\n        wrappedContent = wrappedNoscript.getAttribute('data-html');\n        noscript = document.createElement('noscript');\n        noscript.textContent = wrappedContent;\n        results.push(wrappedNoscript.parentNode.replaceChild(noscript, wrappedNoscript));\n      }\n      return results;\n    };\n\n    return HtmlParser;\n\n  })();\n\n}).call(this);\n(function() {\n  var u,\n    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };\n\n  u = up.util;\n\n  up.MotionTracker = (function() {\n    function MotionTracker(name) {\n      this.reset = bind(this.reset, this);\n      this.whileForwardingFinishEvent = bind(this.whileForwardingFinishEvent, this);\n      this.forwardFinishEvent = bind(this.forwardFinishEvent, this);\n      this.unmarkCluster = bind(this.unmarkCluster, this);\n      this.markCluster = bind(this.markCluster, this);\n      this.whenElementFinished = bind(this.whenElementFinished, this);\n      this.emitFinishEvent = bind(this.emitFinishEvent, this);\n      this.finishOneElement = bind(this.finishOneElement, this);\n      this.isActive = bind(this.isActive, this);\n      this.expandFinishRequest = bind(this.expandFinishRequest, this);\n      this.finish = bind(this.finish, this);\n      this.claim = bind(this.claim, this);\n      this.activeClass = \"up-\" + name;\n      this.dataKey = \"up-\" + name + \"-finished\";\n      this.selector = \".\" + this.activeClass;\n      this.finishEvent = \"up:\" + name + \":finish\";\n      this.finishCount = 0;\n      this.clusterCount = 0;\n    }\n\n\n    /***\n    Finishes all animations in the given element cluster's ancestors and descendants,\n    then calls the animator.\n    \n    The animation returned by the animator is tracked so it can be\n    [`finished`](/up.MotionTracker.finish) later.\n    \n    @method claim\n    @param {jQuery} $cluster\n    @param {Function(jQuery): Promise} animator\n    @param {Object} memory.trackMotion = true\n      Whether\n    @return {Promise} A promise that is fulfilled when the new animation ends.\n     */\n\n    MotionTracker.prototype.claim = function(cluster, animator, memory) {\n      var $cluster;\n      if (memory == null) {\n        memory = {};\n      }\n      $cluster = $(cluster);\n      memory.trackMotion = u.option(memory.trackMotion, up.motion.isEnabled());\n      if (memory.trackMotion === false) {\n        return u.microtask(animator);\n      } else {\n        memory.trackMotion = false;\n        return this.finish($cluster).then((function(_this) {\n          return function() {\n            var promise;\n            promise = _this.whileForwardingFinishEvent($cluster, animator);\n            promise = promise.then(function() {\n              return _this.unmarkCluster($cluster);\n            });\n            _this.markCluster($cluster, promise);\n            return promise;\n          };\n        })(this));\n      }\n    };\n\n\n    /***\n    @method finish\n    @param {jQuery} [elements]\n      If no element is given, finishes all animations in the documnet.\n      If an element is given, only finishes animations in its subtree and ancestors.\n    @return {Promise} A promise that is fulfilled when animations have finished.\n     */\n\n    MotionTracker.prototype.finish = function(elements) {\n      var $elements, allFinished;\n      this.finishCount++;\n      if (this.clusterCount === 0 || !up.motion.isEnabled()) {\n        return Promise.resolve();\n      }\n      $elements = this.expandFinishRequest(elements);\n      allFinished = u.map($elements, this.finishOneElement);\n      return Promise.all(allFinished);\n    };\n\n    MotionTracker.prototype.expandFinishRequest = function(elements) {\n      if (elements) {\n        return u.selectInDynasty($(elements), this.selector);\n      } else {\n        return $(this.selector);\n      }\n    };\n\n    MotionTracker.prototype.isActive = function(element) {\n      return u.hasClass(element, this.activeClass);\n    };\n\n    MotionTracker.prototype.finishOneElement = function(element) {\n      var $element;\n      $element = $(element);\n      this.emitFinishEvent($element);\n      return this.whenElementFinished($element);\n    };\n\n    MotionTracker.prototype.emitFinishEvent = function($element, eventAttrs) {\n      if (eventAttrs == null) {\n        eventAttrs = {};\n      }\n      eventAttrs = u.merge({\n        $element: $element,\n        message: false\n      }, eventAttrs);\n      return up.emit(this.finishEvent, eventAttrs);\n    };\n\n    MotionTracker.prototype.whenElementFinished = function($element) {\n      return $element.data(this.dataKey) || Promise.resolve();\n    };\n\n    MotionTracker.prototype.markCluster = function($cluster, promise) {\n      this.clusterCount++;\n      $cluster.addClass(this.activeClass);\n      return $cluster.data(this.dataKey, promise);\n    };\n\n    MotionTracker.prototype.unmarkCluster = function($cluster) {\n      this.clusterCount--;\n      $cluster.removeClass(this.activeClass);\n      return $cluster.removeData(this.dataKey);\n    };\n\n    MotionTracker.prototype.forwardFinishEvent = function($original, $ghost, duration) {\n      return this.start($original, (function(_this) {\n        return function() {\n          var doForward;\n          doForward = function() {\n            return $ghost.trigger(_this.finishEvent);\n          };\n          $original.on(_this.finishEvent, doForward);\n          return duration.then(function() {\n            return $original.off(_this.finishEvent, doForward);\n          });\n        };\n      })(this));\n    };\n\n    MotionTracker.prototype.whileForwardingFinishEvent = function($elements, fn) {\n      var doForward;\n      if ($elements.length < 2) {\n        return fn();\n      }\n      doForward = (function(_this) {\n        return function(event) {\n          if (!event.forwarded) {\n            return u.each($elements, function(element) {\n              var $element;\n              $element = $(element);\n              if (element !== event.target && _this.isActive($element)) {\n                return _this.emitFinishEvent($element, {\n                  forwarded: true\n                });\n              }\n            });\n          }\n        };\n      })(this);\n      $elements.on(this.finishEvent, doForward);\n      return fn().then((function(_this) {\n        return function() {\n          return $elements.off(_this.finishEvent, doForward);\n        };\n      })(this));\n    };\n\n    MotionTracker.prototype.reset = function() {\n      return this.finish().then((function(_this) {\n        return function() {\n          _this.finishCount = 0;\n          return _this.clusterCount = 0;\n        };\n      })(this));\n    };\n\n    return MotionTracker;\n\n  })();\n\n}).call(this);\n(function() {\n  var u,\n    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  u = up.util;\n\n\n  /***\n  Instances of `up.Request` normalizes properties of an [`AJAX request`](/up.request)\n  such as the requested URL, form parameters and HTTP method.\n  \n  @class up.Request\n   */\n\n  up.Request = (function(superClass) {\n    extend(Request, superClass);\n\n\n    /***\n    The HTTP method for the request.\n    \n    @property up.Request#method\n    @param {string} method\n    @stable\n     */\n\n\n    /***\n    The URL for the request.\n    \n    @property up.Request#url\n    @param {string} url\n    @stable\n     */\n\n\n    /***\n    [Parameters](/up.params) that should be sent as the request's payload.\n    \n    @property up.Request#params\n    @param {object|FormData|string|Array} params\n    @stable\n     */\n\n\n    /***\n    The CSS selector that will be sent as an [`X-Up-Target` header](/up.protocol#optimizing-responses).\n    \n    @property up.Request#target\n    @param {string} target\n    @stable\n     */\n\n\n    /***\n    The CSS selector that will be sent as an [`X-Up-Fail-Target` header](/up.protocol#optimizing-responses).\n    \n    @property up.Request#failTarget\n    @param {string} failTarget\n    @stable\n     */\n\n\n    /***\n    An object of additional HTTP headers.\n    \n    @property up.Request#headers\n    @param {object} headers\n    @stable\n     */\n\n\n    /***\n    A timeout in milliseconds.\n    \n    If [`up.proxy.config.maxRequests`](/up.proxy.config#config.maxRequests) is set,\n    the timeout will not include the time spent waiting in the queue.\n    \n    @property up.Request#timeout\n    @param {object|undefined} timeout\n    @stable\n     */\n\n    Request.prototype.fields = function() {\n      return ['method', 'url', 'params', 'data', 'target', 'failTarget', 'headers', 'timeout', 'preload', 'cache'];\n    };\n\n\n    /***\n    @constructor up.Request\n    @param {string} [attributes]\n     */\n\n    function Request(options) {\n      this.cacheKey = bind(this.cacheKey, this);\n      this.isCachable = bind(this.isCachable, this);\n      this.buildResponse = bind(this.buildResponse, this);\n      this.isCrossDomain = bind(this.isCrossDomain, this);\n      this.csrfToken = bind(this.csrfToken, this);\n      this.navigate = bind(this.navigate, this);\n      this.send = bind(this.send, this);\n      this.isSafe = bind(this.isSafe, this);\n      this.transferSearchToParams = bind(this.transferSearchToParams, this);\n      this.transferParamsToUrl = bind(this.transferParamsToUrl, this);\n      this.extractHashFromUrl = bind(this.extractHashFromUrl, this);\n      this.normalize = bind(this.normalize, this);\n      Request.__super__.constructor.call(this, options);\n      this.normalize();\n    }\n\n    Request.prototype.normalize = function() {\n      u.deprecateRenamedKey(this, 'data', 'params');\n      this.method = u.normalizeMethod(this.method);\n      this.headers || (this.headers = {});\n      this.extractHashFromUrl();\n      if (u.methodAllowsPayload(this.method)) {\n        return this.transferSearchToParams();\n      } else {\n        return this.transferParamsToUrl();\n      }\n    };\n\n    Request.prototype.extractHashFromUrl = function() {\n      var urlParts;\n      urlParts = u.parseUrl(this.url);\n      this.hash = u.presence(urlParts.hash);\n      return this.url = u.normalizeUrl(urlParts, {\n        hash: false\n      });\n    };\n\n    Request.prototype.transferParamsToUrl = function() {\n      if (this.params && !u.isFormData(this.params)) {\n        this.url = up.params.buildURL(this.url, this.params);\n        return this.params = void 0;\n      }\n    };\n\n    Request.prototype.transferSearchToParams = function() {\n      var query;\n      if (query = up.params.fromURL(this.url)) {\n        this.params = up.params.merge(this.params, query);\n        return this.url = u.normalizeUrl(this.url, {\n          search: false\n        });\n      }\n    };\n\n    Request.prototype.isSafe = function() {\n      return up.proxy.isSafeMethod(this.method);\n    };\n\n    Request.prototype.send = function() {\n      return new Promise((function(_this) {\n        return function(resolve, reject) {\n          var csrfToken, header, pc, ref, resolveWithResponse, value, xhr, xhrHeaders, xhrMethod, xhrPayload, xhrUrl;\n          xhr = new XMLHttpRequest();\n          xhrHeaders = u.copy(_this.headers);\n          xhrPayload = _this.params;\n          xhrMethod = _this.method;\n          xhrUrl = _this.url;\n          ref = up.proxy.wrapMethod(xhrMethod, xhrPayload), xhrMethod = ref[0], xhrPayload = ref[1];\n          if (xhrPayload) {\n            delete xhrHeaders['Content-Type'];\n            xhrPayload = up.params.toFormData(xhrPayload);\n          } else {\n            xhrPayload = null;\n          }\n          pc = up.protocol.config;\n          if (_this.target) {\n            xhrHeaders[pc.targetHeader] = _this.target;\n          }\n          if (_this.failTarget) {\n            xhrHeaders[pc.failTargetHeader] = _this.failTarget;\n          }\n          if (!_this.isCrossDomain()) {\n            xhrHeaders['X-Requested-With'] || (xhrHeaders['X-Requested-With'] = 'XMLHttpRequest');\n          }\n          if (csrfToken = _this.csrfToken()) {\n            xhrHeaders[pc.csrfHeader] = csrfToken;\n          }\n          xhr.open(xhrMethod, xhrUrl);\n          for (header in xhrHeaders) {\n            value = xhrHeaders[header];\n            xhr.setRequestHeader(header, value);\n          }\n          resolveWithResponse = function() {\n            var response;\n            response = _this.buildResponse(xhr);\n            if (response.isSuccess()) {\n              return resolve(response);\n            } else {\n              return reject(response);\n            }\n          };\n          xhr.onload = resolveWithResponse;\n          xhr.onerror = resolveWithResponse;\n          xhr.ontimeout = resolveWithResponse;\n          if (_this.timeout) {\n            xhr.timeout = _this.timeout;\n          }\n          return xhr.send(xhrPayload);\n        };\n      })(this));\n    };\n\n    Request.prototype.navigate = function() {\n      var $form, addField, csrfParam, csrfToken, formMethod;\n      this.transferSearchToParams();\n      $form = $('<form class=\"up-page-loader\"></form>');\n      addField = function(field) {\n        return $('<input type=\"hidden\">').attr(field).appendTo($form);\n      };\n      if (this.method === 'GET') {\n        formMethod = 'GET';\n      } else {\n        addField({\n          name: up.protocol.config.methodParam,\n          value: this.method\n        });\n        formMethod = 'POST';\n      }\n      $form.attr({\n        method: formMethod,\n        action: this.url\n      });\n      if ((csrfParam = up.protocol.csrfParam()) && (csrfToken = this.csrfToken())) {\n        addField({\n          name: csrfParam,\n          value: csrfToken\n        });\n      }\n      u.each(up.params.toArray(this.params), addField);\n      $form.hide().appendTo('body');\n      return up.browser.submitForm($form);\n    };\n\n    Request.prototype.csrfToken = function() {\n      if (!this.isSafe() && !this.isCrossDomain()) {\n        return up.protocol.csrfToken();\n      }\n    };\n\n    Request.prototype.isCrossDomain = function() {\n      return u.isCrossDomain(this.url);\n    };\n\n    Request.prototype.buildResponse = function(xhr) {\n      var ref, responseAttrs, urlFromServer;\n      responseAttrs = {\n        method: this.method,\n        url: this.url,\n        text: xhr.responseText,\n        status: xhr.status,\n        request: this,\n        xhr: xhr\n      };\n      if (urlFromServer = up.protocol.locationFromXhr(xhr)) {\n        responseAttrs.url = urlFromServer;\n        responseAttrs.method = (ref = up.protocol.methodFromXhr(xhr)) != null ? ref : 'GET';\n      }\n      responseAttrs.title = up.protocol.titleFromXhr(xhr);\n      return new up.Response(responseAttrs);\n    };\n\n    Request.prototype.isCachable = function() {\n      return this.isSafe() && !u.isFormData(this.params);\n    };\n\n    Request.prototype.cacheKey = function() {\n      var query;\n      query = up.params.toQuery(this.params);\n      return [this.url, this.method, query, this.target].join('|');\n    };\n\n    Request.wrap = function(object) {\n      if (object instanceof this) {\n        return object;\n      } else {\n        return new this(object);\n      }\n    };\n\n    return Request;\n\n  })(up.Record);\n\n}).call(this);\n(function() {\n  var u,\n    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  u = up.util;\n\n\n  /***\n  Instances of `up.Response` describe the server response to an [`AJAX request`](/up.request).\n  \n  \\#\\#\\# Example\n  \n      up.request('/foo').then(function(response) {\n        console.log(response.status); // 200\n        console.log(response.text);   // \"<html><body>...\"\n      });\n  \n  @class up.Response\n   */\n\n  up.Response = (function(superClass) {\n    extend(Response, superClass);\n\n\n    /***\n    The HTTP method used for the response.\n    \n    This is usually the HTTP method used by the request.\n    However, after a redirect the server should signal a `GET` method using\n    an [`X-Up-Method: GET` header](/up.protocol#redirect-detection).\n    \n    @property up.Response#method\n    @param {string} method\n    @stable\n     */\n\n\n    /***\n    The URL used for the response.\n    \n    This is usually the requested URL.\n    However, after a redirect the server should signal a the new URL\n    using an [`X-Up-Location: /new-url` header](/up.protocol#redirect-detection).\n    \n    @property up.Response#url\n    @param {string} method\n    @stable\n     */\n\n\n    /***\n    The response body as a `string`.\n    \n    @property up.Response#text\n    @param {string} text\n    @stable\n     */\n\n\n    /***\n    The response's\n    [HTTP status code](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes)\n    as a `number`.\n    \n    A successful response will usually have a `200` or `201' status code.\n    \n    @property up.Response#status\n    @param {number} status\n    @stable\n     */\n\n\n    /***\n    The [request](/up.Request) that triggered this response.\n    \n    @property up.Response#request\n    @param {up.Request} request\n    @experimental\n     */\n\n\n    /***\n    The [`XMLHttpRequest`](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest)\n    object that was used to create this response.\n    \n    @property up.Response#xhr\n    @param {XMLHttpRequest} xhr\n    @experimental\n     */\n\n\n    /***\n    A [document title pushed by the server](/up.protocol#pushing-a-document-title-to-the-client).\n    \n    If the server pushed no title via HTTP header, this will be `undefined`.\n    \n    @property up.Response#title\n    @param {string} [title]\n    @stable\n     */\n\n    Response.prototype.fields = function() {\n      return ['method', 'url', 'text', 'status', 'request', 'xhr', 'title'];\n    };\n\n    function Response(options) {\n      this.getHeader = bind(this.getHeader, this);\n      this.isFatalError = bind(this.isFatalError, this);\n      this.isError = bind(this.isError, this);\n      this.isSuccess = bind(this.isSuccess, this);\n      Response.__super__.constructor.call(this, options);\n    }\n\n\n    /***\n    Returns whether the server responded with a 2xx HTTP status.\n    \n    @function up.Response#isSuccess\n    @return {boolean}\n    @experimental\n     */\n\n    Response.prototype.isSuccess = function() {\n      return this.status && (this.status >= 200 && this.status <= 299);\n    };\n\n\n    /***\n    Returns whether the response was not [successful](/up.Request.prototype.isSuccess).\n    \n    This also returns `true` when the request encountered a [fatal error](/up.Request.prototype.isFatalError)\n    like a timeout or loss of network connectivity.\n    \n    @function up.Response#isError\n    @return {boolean}\n    @experimental\n     */\n\n    Response.prototype.isError = function() {\n      return !this.isSuccess();\n    };\n\n\n    /***\n    Returns whether the request encountered a [fatal error](/up.Request.prototype.isFatalError)\n    like a timeout or loss of network connectivity.\n    \n    When the server produces an error message with an HTTP status like `500`,\n    this is not considered a fatal error and `false` is returned.\n    \n    @function up.Response#isFatalError\n    @return {boolean}\n    @experimental\n     */\n\n    Response.prototype.isFatalError = function() {\n      return this.isError() && u.isBlank(this.text);\n    };\n\n\n    /***\n    Returns the HTTP header value with the given name.\n    \n    The search for the header name is case-insensitive.\n    \n    Returns `undefined` if the given header name was not included in the response.\n    \n    @function up.Response#getHeader\n    @param {string} name\n    @return {string|undefined} value\n    @experimental\n     */\n\n    Response.prototype.getHeader = function(name) {\n      return this.xhr.getResponseHeader(name);\n    };\n\n    return Response;\n\n  })(up.Record);\n\n}).call(this);\n(function() {\n  var u,\n    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };\n\n  up.store || (up.store = {});\n\n  u = up.util;\n\n  up.store.Memory = (function() {\n    function Memory() {\n      this.values = bind(this.values, this);\n      this.keys = bind(this.keys, this);\n      this.remove = bind(this.remove, this);\n      this.set = bind(this.set, this);\n      this.get = bind(this.get, this);\n      this.clear = bind(this.clear, this);\n      this.clear();\n    }\n\n    Memory.prototype.clear = function() {\n      return this.data = {};\n    };\n\n    Memory.prototype.get = function(key) {\n      return this.data[key];\n    };\n\n    Memory.prototype.set = function(key, value) {\n      return this.data[key] = value;\n    };\n\n    Memory.prototype.remove = function(key) {\n      return delete this.data[key];\n    };\n\n    Memory.prototype.keys = function() {\n      return Object.keys(this.data);\n    };\n\n    Memory.prototype.values = function() {\n      return u.values(this.data);\n    };\n\n    return Memory;\n\n  })();\n\n}).call(this);\n(function() {\n  var u,\n    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  u = up.util;\n\n  up.store.Session = (function(superClass) {\n    extend(Session, superClass);\n\n    function Session(rootKey) {\n      this.saveToSessionStorage = bind(this.saveToSessionStorage, this);\n      this.loadFromSessionStorage = bind(this.loadFromSessionStorage, this);\n      this.remove = bind(this.remove, this);\n      this.set = bind(this.set, this);\n      this.clear = bind(this.clear, this);\n      this.rootKey = rootKey;\n      this.loadFromSessionStorage();\n    }\n\n    Session.prototype.clear = function() {\n      Session.__super__.clear.call(this);\n      return this.saveToSessionStorage();\n    };\n\n    Session.prototype.set = function(key, value) {\n      Session.__super__.set.call(this, key, value);\n      return this.saveToSessionStorage();\n    };\n\n    Session.prototype.remove = function(key) {\n      Session.__super__.remove.call(this, key);\n      return this.saveToSessionStorage();\n    };\n\n    Session.prototype.loadFromSessionStorage = function() {\n      var raw;\n      try {\n        if (raw = typeof sessionStorage !== \"undefined\" && sessionStorage !== null ? sessionStorage.getItem(this.rootKey) : void 0) {\n          this.data = JSON.parse(raw);\n        }\n      } catch (error) {\n\n      }\n      return this.data || (this.data = {});\n    };\n\n    Session.prototype.saveToSessionStorage = function() {\n      var json;\n      json = JSON.stringify(this.data);\n      try {\n        return typeof sessionStorage !== \"undefined\" && sessionStorage !== null ? sessionStorage.setItem(this.rootKey, json) : void 0;\n      } catch (error) {\n\n      }\n    };\n\n    return Session;\n\n  })(up.store.Memory);\n\n}).call(this);\n(function() {\n  var u,\n    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };\n\n  u = up.util;\n\n  up.UrlSet = (function() {\n    function UrlSet(urls, options) {\n      this.urls = urls;\n      if (options == null) {\n        options = {};\n      }\n      this.isEqual = bind(this.isEqual, this);\n      this.matchesAny = bind(this.matchesAny, this);\n      this.doesMatchPrefix = bind(this.doesMatchPrefix, this);\n      this.doesMatchFully = bind(this.doesMatchFully, this);\n      this.matches = bind(this.matches, this);\n      this.normalizeUrl = options.normalizeUrl || u.normalizeUrl;\n      this.urls = u.map(this.urls, this.normalizeUrl);\n      this.urls = u.compact(this.urls);\n    }\n\n    UrlSet.prototype.matches = function(testUrl) {\n      if (testUrl.substr(-1) === '*') {\n        return this.doesMatchPrefix(testUrl.slice(0, -1));\n      } else {\n        return this.doesMatchFully(testUrl);\n      }\n    };\n\n    UrlSet.prototype.doesMatchFully = function(testUrl) {\n      return u.contains(this.urls, testUrl);\n    };\n\n    UrlSet.prototype.doesMatchPrefix = function(prefix) {\n      return u.detect(this.urls, function(url) {\n        return url.indexOf(prefix) === 0;\n      });\n    };\n\n    UrlSet.prototype.matchesAny = function(testUrls) {\n      return u.detect(testUrls, this.matches);\n    };\n\n    UrlSet.prototype.isEqual = function(otherSet) {\n      return u.isEqual(this.urls, otherSet != null ? otherSet.urls : void 0);\n    };\n\n    return UrlSet;\n\n  })();\n\n}).call(this);\n\n/***\nBrowser support\n===============\n\nUnpoly supports all modern browsers.\n\nChrome, Firefox, Edge, Safari\n: Full support\n\nInternet Explorer 11\n: Full support with a `Promise` polyfill like [es6-promise](https://github.com/stefanpenner/es6-promise) (2.4 KB).\n\nInternet Explorer 10 or lower\n: Unpoly prevents itself from booting itself, leaving you with a classic server-side application.\n\n@class up.browser\n */\n\n(function() {\n  var slice = [].slice;\n\n  up.browser = (function($) {\n    var CONSOLE_PLACEHOLDERS, canConsole, canCssTransition, canCustomElements, canDOMParser, canFormData, canInputEvent, canInspectFormData, canPromise, canPushState, documentViewportSelector, isIE10OrWorse, isRecentJQuery, isSupported, navigate, popCookie, puts, sprintf, sprintfWithFormattedArgs, stringifyArg, submitForm, u, url, whenConfirmed;\n    u = up.util;\n\n    /***\n    @method up.browser.navigate\n    @param {string} url\n    @param {string} [options.method='get']\n    @param {object|Array|FormData|string} [options.params]\n    @internal\n     */\n    navigate = function(url, options) {\n      var request;\n      if (options == null) {\n        options = {};\n      }\n      request = new up.Request(u.merge(options, {\n        url: url\n      }));\n      return request.navigate();\n    };\n\n    /***\n    For mocking in specs.\n    \n    @method submitForm\n     */\n    submitForm = function($form) {\n      return $form.submit();\n    };\n\n    /***\n    A cross-browser way to interact with `console.log`, `console.error`, etc.\n    \n    This function falls back to `console.log` if the output stream is not implemented.\n    It also prints substitution strings (e.g. `console.log(\"From %o to %o\", \"a\", \"b\")`)\n    as a single string if the browser console does not support substitution strings.\n    \n    \\#\\#\\# Example\n    \n        up.browser.puts('log', 'Hi world');\n        up.browser.puts('error', 'There was an error in %o', obj);\n    \n    @function up.browser.puts\n    @internal\n     */\n    puts = function() {\n      var args, stream;\n      stream = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];\n      return console[stream].apply(console, args);\n    };\n    CONSOLE_PLACEHOLDERS = /\\%[odisf]/g;\n    stringifyArg = function(arg) {\n      var $arg, attr, closer, j, len, maxLength, ref, string, value;\n      maxLength = 200;\n      closer = '';\n      if (u.isString(arg)) {\n        string = arg.replace(/[\\n\\r\\t ]+/g, ' ');\n        string = string.replace(/^[\\n\\r\\t ]+/, '');\n        string = string.replace(/[\\n\\r\\t ]$/, '');\n        string = \"\\\"\" + string + \"\\\"\";\n        closer = '\"';\n      } else if (u.isUndefined(arg)) {\n        string = 'undefined';\n      } else if (u.isNumber(arg) || u.isFunction(arg)) {\n        string = arg.toString();\n      } else if (u.isArray(arg)) {\n        string = \"[\" + (u.map(arg, stringifyArg).join(', ')) + \"]\";\n        closer = ']';\n      } else if (u.isJQuery(arg)) {\n        string = \"$(\" + (u.map(arg, stringifyArg).join(', ')) + \")\";\n        closer = ')';\n      } else if (u.isElement(arg)) {\n        $arg = $(arg);\n        string = \"<\" + (arg.tagName.toLowerCase());\n        ref = ['id', 'name', 'class'];\n        for (j = 0, len = ref.length; j < len; j++) {\n          attr = ref[j];\n          if (value = $arg.attr(attr)) {\n            string += \" \" + attr + \"=\\\"\" + value + \"\\\"\";\n          }\n        }\n        string += \">\";\n        closer = '>';\n      } else {\n        string = JSON.stringify(arg);\n      }\n      if (string.length > maxLength) {\n        string = (string.substr(0, maxLength)) + \" \";\n        string += closer;\n      }\n      return string;\n    };\n\n    /***\n    See https://developer.mozilla.org/en-US/docs/Web/API/Console#Using_string_substitutions\n    \n    @function up.browser.sprintf\n    @internal\n     */\n    sprintf = function() {\n      var args, message;\n      message = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];\n      return sprintfWithFormattedArgs.apply(null, [u.identity, message].concat(slice.call(args)));\n    };\n\n    /***\n    @function up.browser.sprintfWithBounds\n    @internal\n     */\n    sprintfWithFormattedArgs = function() {\n      var args, formatter, i, message;\n      formatter = arguments[0], message = arguments[1], args = 3 <= arguments.length ? slice.call(arguments, 2) : [];\n      if (u.isBlank(message)) {\n        return '';\n      }\n      i = 0;\n      return message.replace(CONSOLE_PLACEHOLDERS, function() {\n        var arg;\n        arg = args[i];\n        arg = formatter(stringifyArg(arg));\n        i += 1;\n        return arg;\n      });\n    };\n    url = function() {\n      return location.href;\n    };\n    isIE10OrWorse = u.memoize(function() {\n      return !window.atob;\n    });\n\n    /***\n    Returns whether this browser supports manipulation of the current URL\n    via [`history.pushState`](https://developer.mozilla.org/en-US/docs/Web/API/History/pushState).\n    \n    When `pushState`  (e.g. through [`up.follow()`](/up.follow)), it will gracefully\n    fall back to a full page load.\n    \n    Note that Unpoly will not use `pushState` if the initial page was loaded with\n    a request method other than GET.\n    \n    @function up.browser.canPushState\n    @return {boolean}\n    @experimental\n     */\n    canPushState = function() {\n      return u.isDefined(history.pushState) && up.protocol.initialRequestMethod() === 'get';\n    };\n\n    /***\n    Returns whether this browser supports animation using\n    [CSS transitions](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Transitions).\n    \n    When Unpoly is asked to animate history on a browser that doesn't support\n    CSS transitions (e.g. through [`up.animate()`](/up.animate)), it will skip the\n    animation by instantly jumping to the last frame.\n    \n    @function up.browser.canCssTransition\n    @return {boolean}\n    @internal\n     */\n    canCssTransition = u.memoize(function() {\n      return 'transition' in document.documentElement.style;\n    });\n\n    /***\n    Returns whether this browser supports the DOM event [`input`](https://developer.mozilla.org/de/docs/Web/Events/input).\n    \n    @function up.browser.canInputEvent\n    @return {boolean}\n    @internal\n     */\n    canInputEvent = u.memoize(function() {\n      return 'oninput' in document.createElement('input');\n    });\n\n    /***\n    Returns whether this browser supports promises.\n    \n    @function up.browser.canPromise\n    @return {boolean}\n    @internal\n     */\n    canPromise = u.memoize(function() {\n      return !!window.Promise;\n    });\n\n    /***\n    Returns whether this browser supports the [`FormData`](https://developer.mozilla.org/en-US/docs/Web/API/FormData)\n    interface.\n    \n    @function up.browser.canFormData\n    @return {boolean}\n    @experimental\n     */\n    canFormData = u.memoize(function() {\n      return !!window.FormData;\n    });\n\n    /***\n    @function up.browser.canInspectFormData\n    @return {boolean}\n    @internal\n     */\n    canInspectFormData = u.memoize(function() {\n      return canFormData() && !!FormData.prototype.entries;\n    });\n\n    /***\n    Returns whether this browser supports the [`DOMParser`](https://developer.mozilla.org/en-US/docs/Web/API/DOMParser)\n    interface.\n    \n    @function up.browser.canDOMParser\n    @return {boolean}\n    @internal\n     */\n    canDOMParser = u.memoize(function() {\n      return !!window.DOMParser;\n    });\n\n    /***\n    Returns whether this browser supports the [`debugging console`](https://developer.mozilla.org/en-US/docs/Web/API/Console).\n    \n    @function up.browser.canConsole\n    @return {boolean}\n    @internal\n     */\n    canConsole = u.memoize(function() {\n      return window.console && console.debug && console.info && console.warn && console.error && console.group && console.groupCollapsed && console.groupEnd;\n    });\n    canCustomElements = u.memoize(function() {\n      return !!window.customElements;\n    });\n    isRecentJQuery = u.memoize(function() {\n      var major, minor, parts, version;\n      version = $.fn.jquery;\n      parts = version.split('.');\n      major = parseInt(parts[0]);\n      minor = parseInt(parts[1]);\n      return major >= 2 || (major === 1 && minor >= 9);\n    });\n    popCookie = function(name) {\n      var ref, value;\n      value = (ref = document.cookie.match(new RegExp(name + \"=(\\\\w+)\"))) != null ? ref[1] : void 0;\n      if (u.isPresent(value)) {\n        document.cookie = name + '=; expires=Thu, 01-Jan-70 00:00:01 GMT; path=/';\n      }\n      return value;\n    };\n\n    /***\n    @function up,browser.whenConfirmed\n    @return {Promise}\n    @param {string} options.confirm\n    @param {boolean} options.preload\n    @internal\n     */\n    whenConfirmed = function(options) {\n      if (options.preload || u.isBlank(options.confirm) || window.confirm(options.confirm)) {\n        return Promise.resolve();\n      } else {\n        return Promise.reject(new Error('User canceled action'));\n      }\n    };\n\n    /***\n    Returns whether Unpoly supports the current browser.\n    \n    If this returns `false` Unpoly will prevent itself from [booting](/up.boot)\n    and ignores all registered [event handlers](/up.on) and [compilers](/up.compiler).\n    This leaves you with a classic server-side application.\n    This is usually a better fallback than loading incompatible Javascript and causing\n    many errors on load.\n    \n    @function up.browser.isSupported\n    @stable\n     */\n    isSupported = function() {\n      return !isIE10OrWorse() && isRecentJQuery() && canConsole() && canDOMParser() && canFormData() && canCssTransition() && canInputEvent() && canPromise();\n    };\n\n    /***\n    Return the [scrolling element](https://developer.mozilla.org/en-US/docs/Web/API/document/scrollingElement)\n    for the browser's main content area.\n    \n    @function up.browser.documentViewportSelector\n    @internal\n     */\n    documentViewportSelector = function() {\n      var element;\n      if (element = document.scrollingElement) {\n        return element.tagName;\n      } else {\n        return 'html';\n      }\n    };\n    return {\n      url: url,\n      navigate: navigate,\n      submitForm: submitForm,\n      canPushState: canPushState,\n      canFormData: canFormData,\n      canInspectFormData: canInspectFormData,\n      canCustomElements: canCustomElements,\n      documentViewportSelector: documentViewportSelector,\n      whenConfirmed: whenConfirmed,\n      isSupported: isSupported,\n      puts: puts,\n      sprintf: sprintf,\n      sprintfWithFormattedArgs: sprintfWithFormattedArgs,\n      popCookie: popCookie\n    };\n  })(jQuery);\n\n}).call(this);\n\n/***\nEvents\n======\n\nMost Unpoly interactions emit DOM events that are prefixed with `up:`.\n\n    $(document).on('up:modal:opened', function(event) {\n      console.log('A new modal has just opened!');\n    });\n\nEvents often have both present ([`up:modal:open`](/up:modal:open))\nand past forms ([`up:modal:opened`](/up:modal:opened)).\n\n\n\\#\\#\\# Preventing events\n\nYou can prevent most present form events by calling `preventDefault()`:\n\n    $(document).on('up:modal:open', function(event) {\n      if (event.url == '/evil') {\n        // Prevent the modal from opening\n        event.preventDefault();\n      }\n    });\n\n\n\\#\\#\\# A better way to bind event listeners\n\nInstead of using jQuery to bind  an event handler to `document`, you can also\nuse the more convenient [`up.on()`](/up.on):\n\n    up.on('click', 'button', function(event, $button) {\n      // $button is a jQuery collection containing\n      // the clicked <button> element\n    });\n\nThis improves jQuery's [`on`](http://api.jquery.com/on/) in multiple ways:\n\n- Event listeners on [unsupported browsers](/up.browser.isSupported) are silently discarded,\n  leaving you with an application without JavaScript. This is typically preferable to\n  a soup of randomly broken JavaScript in ancient browsers.\n- A jQuery object with the target element is automatically passed to the event handler\n  as a second argument. You no longer need to write `$(this)` in the handler function.\n- You use an [`up-data`](/up-data) attribute to [attach structured data](/up.on#attaching-structured-data)\n  to observed elements.\n\n@class up.bus\n */\n\n(function() {\n  var slice = [].slice;\n\n  up.bus = (function($) {\n    var boot, consumeAction, deprecateRenamedEvent, emit, emitReset, fixRenamedEvents, forgetUpDescription, haltEvent, live, liveUpDescriptions, logEmission, nextUpDescriptionNumber, nobodyPrevents, onEscape, rememberUpDescription, renamedEvents, resetBus, snapshot, u, unbind, upDescriptionNumber, upDescriptionToJqueryDescription, upListenerToJqueryListener, whenEmitted;\n    u = up.util;\n    liveUpDescriptions = {};\n    nextUpDescriptionNumber = 0;\n    renamedEvents = {};\n\n    /***\n    Convert an Unpoly style listener (second argument is the event target\n    as a jQuery collection) to a vanilla jQuery listener\n    \n    @function upListenerToJqueryListener\n    @internal\n     */\n    upListenerToJqueryListener = function(upListener) {\n      return function(event) {\n        var $me, args, expectedArgCount;\n        $me = event.$element || $(this);\n        args = [event, $me];\n        expectedArgCount = upListener.length;\n        if (!(expectedArgCount === 1 || expectedArgCount === 2)) {\n          args.push(up.syntax.data($me));\n        }\n        return upListener.apply($me.get(0), args);\n      };\n    };\n\n    /***\n    Converts an argument list for `up.on()` to an argument list for `jQuery.on`.\n    This involves rewriting the listener signature in the last argument slot.\n    \n    @function upDescriptionToJqueryDescription\n    @internal\n     */\n    upDescriptionToJqueryDescription = function(upDescription, isNew) {\n      var jqueryDescription, jqueryListener, upListener;\n      jqueryDescription = u.copy(upDescription);\n      fixRenamedEvents(jqueryDescription);\n      upListener = jqueryDescription.pop();\n      jqueryListener = void 0;\n      if (isNew) {\n        jqueryListener = upListenerToJqueryListener(upListener);\n        upListener._asJqueryListener = jqueryListener;\n        if (upListener._descriptionNumber) {\n          up.fail('up.on(): The callback %o cannot be registered more than once');\n        }\n        upListener._descriptionNumber = ++nextUpDescriptionNumber;\n      } else {\n        jqueryListener = upListener._asJqueryListener;\n        jqueryListener || up.fail('up.off(): The callback %o was never registered through up.on()', upListener);\n      }\n      jqueryDescription.push(jqueryListener);\n      return jqueryDescription;\n    };\n    fixRenamedEvents = function(description) {\n      var events;\n      events = u.splitValues(description[0]);\n      events = u.map(events, function(event) {\n        var newEvent;\n        if (newEvent = renamedEvents[event]) {\n          up.warn(\"Deprecated: \" + event + \" has been renamed to \" + newEvent);\n          return newEvent;\n        } else {\n          return event;\n        }\n      });\n      return description[0] = events.join(' ');\n    };\n\n    /***\n    Listens to an event on `document`.\n    \n    The given event listener which will be executed whenever the\n    given event is [triggered](/up.emit) on the given selector:\n    \n        up.on('click', '.button', function(event, $element) {\n          console.log(\"Someone clicked the button %o\", $element);\n        });\n    \n    This is roughly equivalent to binding an event listener to `document`:\n    \n        $(document).on('click', '.button', function(event) {\n          console.log(\"Someone clicked the button %o\", $(this));\n        });\n    \n    Other than jQuery, Unpoly will silently discard event listeners\n    on [unsupported browsers](/up.browser.isSupported).\n    \n    \\#\\#\\# Attaching structured data\n    \n    In case you want to attach structured data to the event you're observing,\n    you can serialize the data to JSON and put it into an `[up-data]` attribute:\n    \n        <span class='person' up-data='{ \"age\": 18, \"name\": \"Bob\" }'>Bob</span>\n        <span class='person' up-data='{ \"age\": 22, \"name\": \"Jim\" }'>Jim</span>\n    \n    The JSON will parsed and handed to your event handler as a third argument:\n    \n        up.on('click', '.person', function(event, $element, data) {\n          console.log(\"This is %o who is %o years old\", data.name, data.age);\n        });\n    \n    \\#\\#\\# Unbinding an event listener\n    \n    `up.on()` returns a function that unbinds the event listeners when called:\n    \n        // Define the listener\n        var listener =  function() { ... };\n    \n        // Binding the listener returns an unbind function\n        unbind = up.on('click', listener);\n    \n        // Unbind the listener\n        unbind()\n    \n    There is also a function [`up.off()`](/up.off) which you can use for the same purpose:\n    \n        // Define the listener\n        var listener =  function() { ... };\n    \n        // Bind the listener\n        up.on('click', listener);\n    \n        // Unbind the listener\n        up.off('click', listener)\n    \n    \\#\\#\\# Migrating jQuery event handlers to `up.on()`\n    \n    Within the event handler, Unpoly will bind `this` to the\n    native DOM element to help you migrate your existing jQuery code to\n    this new syntax.\n    \n    So if you had this before:\n    \n        $(document).on('click', '.button', function() {\n          $(this).something();\n        });\n    \n    ... you can simply copy the event handler to `up.on()`:\n    \n        up.on('click', '.button', function() {\n          $(this).something();\n        });\n    \n    @function up.on\n    @param {string} events\n      A space-separated list of event names to bind.\n    @param {string} [selector]\n      The selector of an element on which the event must be triggered.\n      Omit the selector to listen to all events with that name, regardless\n      of the event target.\n    @param {Function(event, $element, data)} behavior\n      The handler that should be called.\n      The function takes the affected element as the first argument (as a jQuery object).\n      If the element has an [`up-data`](/up-data) attribute, its value is parsed as JSON\n      and passed as a second argument.\n    @return {Function}\n      A function that unbinds the event listeners when called.\n    @stable\n     */\n    live = function() {\n      var jqueryDescription, ref, upDescription;\n      upDescription = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n      if (!up.browser.isSupported()) {\n        return (function() {});\n      }\n      jqueryDescription = upDescriptionToJqueryDescription(upDescription, true);\n      rememberUpDescription(upDescription);\n      (ref = $(document)).on.apply(ref, jqueryDescription);\n      return function() {\n        return unbind.apply(null, upDescription);\n      };\n    };\n\n    /***\n    Unbinds an event listener previously bound with [`up.on()`](/up.on).\n    \n    \\#\\#\\# Example\n    \n    Let's say you are listing to clicks on `.button` elements:\n    \n        var listener = function() { ... };\n        up.on('click', '.button', listener);\n    \n    You can stop listening to these events like this:\n    \n        up.off('click', '.button', listener);\n    \n    Note that you need to pass `up.off()` a reference to the same listener function\n    that was passed to `up.on()` earlier.\n    \n    @function up.off\n    @stable\n     */\n    unbind = function() {\n      var jqueryDescription, ref, upDescription;\n      upDescription = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n      jqueryDescription = upDescriptionToJqueryDescription(upDescription, false);\n      forgetUpDescription(upDescription);\n      return (ref = $(document)).off.apply(ref, jqueryDescription);\n    };\n    rememberUpDescription = function(upDescription) {\n      var number;\n      number = upDescriptionNumber(upDescription);\n      return liveUpDescriptions[number] = upDescription;\n    };\n    forgetUpDescription = function(upDescription) {\n      var number, upListener;\n      number = upDescriptionNumber(upDescription);\n      upListener = u.last(upDescription);\n      delete upListener._descriptionNumber;\n      delete upListener._asJqueryListener;\n      return delete liveUpDescriptions[number];\n    };\n    upDescriptionNumber = function(upDescription) {\n      return u.last(upDescription)._descriptionNumber;\n    };\n\n    /***\n    Emits a event with the given name and properties.\n    \n    The event will be triggered as a jQuery event on `document`.\n    \n    Other code can subscribe to events with that name using\n    [`up.on()`](/up.on) or by [binding a jQuery event listener](http://api.jquery.com/on/) to `document`.\n    \n    \\#\\#\\# Example\n    \n        up.on('my:event', function(event) {\n          console.log(event.foo);\n        });\n    \n        up.emit('my:event', { foo: 'bar' });\n         * Prints \"bar\" to the console\n    \n    @function up.emit\n    @param {string} eventName\n      The name of the event.\n    @param {Object} [eventProps={}]\n      A list of properties to become part of the event object\n      that will be passed to listeners. Note that the event object\n      will by default include properties like `preventDefault()`\n      or `stopPropagation()`.\n    @param {jQuery} [eventProps.$element=$(document)]\n      The element on which the event is triggered.\n    @param {string|Array} [eventProps.message]\n      A message to print to the console when the event is emitted.\n      If omitted, a default message is printed.\n      Set this to `false` to prevent any console output.\n    @experimental\n     */\n    emit = function(eventName, eventProps) {\n      var $target, event;\n      if (eventProps == null) {\n        eventProps = {};\n      }\n      event = $.Event(eventName, eventProps);\n      $target = eventProps.$target || eventProps.$element || $(document);\n      logEmission(eventName, eventProps);\n      $target.trigger(event);\n      return event;\n    };\n    logEmission = function(eventName, eventProps) {\n      var niceMessage, niceMessageArgs, ref;\n      if (eventProps.hasOwnProperty('message')) {\n        niceMessage = eventProps.message;\n        delete eventProps.message;\n        if (niceMessage !== false) {\n          if (u.isArray(niceMessage)) {\n            ref = niceMessage, niceMessage = ref[0], niceMessageArgs = 2 <= ref.length ? slice.call(ref, 1) : [];\n          } else {\n            niceMessageArgs = [];\n          }\n          if (niceMessage) {\n            if (u.isPresent(eventProps)) {\n              return up.puts.apply(up, [niceMessage + \" (%s (%o))\"].concat(slice.call(niceMessageArgs), [eventName], [eventProps]));\n            } else {\n              return up.puts.apply(up, [niceMessage + \" (%s)\"].concat(slice.call(niceMessageArgs), [eventName]));\n            }\n          }\n        }\n      } else {\n        if (u.isPresent(eventProps)) {\n          return up.puts('Emitted event %s (%o)', eventName, eventProps);\n        } else {\n          return up.puts('Emitted event %s', eventName);\n        }\n      }\n    };\n\n    /***\n    [Emits an event](/up.emit) and returns whether no listener\n    has prevented the default action.\n    \n    @function up.bus.nobodyPrevents\n    @param {string} eventName\n    @param {Object} eventProps\n    @param {string|Array} [eventProps.message]\n    @return {boolean}\n      whether no listener has prevented the default action\n    @experimental\n     */\n    nobodyPrevents = function() {\n      var args, event;\n      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n      event = emit.apply(null, args);\n      return !event.isDefaultPrevented();\n    };\n\n    /***\n    [Emits](/up.emit) the given event and returns a promise\n    that will be fulfilled if no listener has prevented the default action.\n    \n    If any listener prevented the default listener\n    the returned promise will never be resolved.\n    \n    @function up.bus.whenEmitted\n    @param {string} eventName\n    @param {Object} eventProps\n    @param {string|Array} [eventProps.message]\n    @return {Promise}\n    @internal\n     */\n    whenEmitted = function() {\n      var args;\n      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n      return new Promise(function(resolve, reject) {\n        if (nobodyPrevents.apply(null, args)) {\n          return resolve();\n        } else {\n          return reject(new Error(\"Event \" + args[0] + \" was prevented\"));\n        }\n      });\n    };\n\n    /***\n    Registers an event listener to be called when the user\n    presses the `Escape` key.\n    \n    @function up.bus.onEscape\n    @param {Function} listener\n      The listener function to register.\n    @return {Function}\n      A function that unbinds the event listeners when called.\n    @experimental\n     */\n    onEscape = function(listener) {\n      return live('keydown', 'body', function(event) {\n        if (u.escapePressed(event)) {\n          return listener(event);\n        }\n      });\n    };\n\n    /***\n    Stops the given event from propagating and prevents the default action.\n    \n    @function up.bus.haltEvent\n    @internal\n     */\n    haltEvent = function(event) {\n      event.stopImmediatePropagation();\n      event.stopPropagation();\n      return event.preventDefault();\n    };\n\n    /***\n    @function up.bus.consumeAction\n    @internal\n     */\n    consumeAction = function(event) {\n      haltEvent(event);\n      if (event.type !== 'up:action:consumed') {\n        return emit('up:action:consumed', {\n          $element: $(event.target),\n          message: false\n        });\n      }\n    };\n\n    /***\n    Makes a snapshot of the currently registered event listeners,\n    to later be restored through [`up.bus.reset()`](/up.bus.reset).\n    \n    @internal\n     */\n    snapshot = function() {\n      var description, number, results;\n      results = [];\n      for (number in liveUpDescriptions) {\n        description = liveUpDescriptions[number];\n        results.push(description.isDefault = true);\n      }\n      return results;\n    };\n    resetBus = function() {\n      var description, doomedDescriptions, i, len, number, results;\n      doomedDescriptions = [];\n      for (number in liveUpDescriptions) {\n        description = liveUpDescriptions[number];\n        if (!description.isDefault) {\n          doomedDescriptions.push(description);\n        }\n      }\n      results = [];\n      for (i = 0, len = doomedDescriptions.length; i < len; i++) {\n        description = doomedDescriptions[i];\n        results.push(unbind.apply(null, description));\n      }\n      return results;\n    };\n\n    /***\n    Resets Unpoly to the state when it was booted.\n    All custom event handlers, animations, etc. that have been registered\n    will be discarded.\n    \n    This is an internal method for to enable unit testing.\n    Don't use this in production.\n    \n    Emits event [`up:framework:reset`](/up:framework:reset).\n    \n    @function up.reset\n    @experimental\n     */\n    emitReset = function() {\n      emit('up:framework:reset', {\n        message: 'Resetting framework'\n      });\n      return up.protocol.reset();\n    };\n\n    /***\n    This event is [emitted](/up.emit) when Unpoly is [reset](/up.reset) during unit tests.\n    \n    @event up:framework:reset\n    @experimental\n     */\n    deprecateRenamedEvent = function(oldEvent, newEvent) {\n      return renamedEvents[oldEvent] = newEvent;\n    };\n\n    /***\n    Boots the Unpoly framework.\n    \n    **This is called automatically** by including the Unpoly JavaScript files.\n    \n    Unpoly will not boot if the current browser is [not supported](/up.browser.isSupported).\n    This leaves you with a classic server-side application on legacy browsers.\n    \n    @function up.boot\n    @internal\n     */\n    boot = function() {\n      if (up.browser.isSupported()) {\n        emit('up:framework:boot', {\n          message: 'Booting framework'\n        });\n        emit('up:framework:booted', {\n          message: 'Framework booted'\n        });\n        return u.nextFrame(function() {\n          return u.whenReady().then(function() {\n            emit('up:app:boot', {\n              message: 'Booting user application'\n            });\n            return emit('up:app:booted', {\n              message: 'User application booted'\n            });\n          });\n        });\n      } else {\n        return typeof console.log === \"function\" ? console.log(\"Unpoly doesn't support this browser. Framework was not booted.\") : void 0;\n      }\n    };\n\n    /***\n    This event is [emitted](/up.emit) when Unpoly [starts to boot](/up.boot).\n    \n    @event up:framework:boot\n    @internal\n     */\n    live('up:framework:booted', snapshot);\n    live('up:framework:reset', resetBus);\n    return {\n      on: live,\n      off: unbind,\n      emit: emit,\n      nobodyPrevents: nobodyPrevents,\n      whenEmitted: whenEmitted,\n      onEscape: onEscape,\n      emitReset: emitReset,\n      haltEvent: haltEvent,\n      consumeAction: consumeAction,\n      deprecateRenamedEvent: deprecateRenamedEvent,\n      boot: boot\n    };\n  })(jQuery);\n\n  up.on = up.bus.on;\n\n  up.off = up.bus.off;\n\n  up.emit = up.bus.emit;\n\n  up.reset = up.bus.emitReset;\n\n  up.boot = up.bus.boot;\n\n}).call(this);\n\n/***\nRequest parameters\n==================\n\nMethods like [`up.replace()`](/up.replace) accept request parameters (or form data values) as a `{ params }` option.\n\nThis module offers a consistent API to read and manipulate request parameters independent of their type.\n\n\n\\#\\#\\# Supported parameter types\n\nThe following types of parameters are supported:\n\n1. an object like `{ email: 'foo@bar.com' }`\n2. a [FormData](https://developer.mozilla.org/en-US/docs/Web/API/FormData) object\n3. a query string like `email=foo%40bar.com`\n4. an array of `{ name, value }` objects like `[{ name: 'email', value: 'foo@bar.com' }]`\n\n@class up.params\n */\n\n(function() {\n  up.params = (function($) {\n    var NATURE_ARRAY, NATURE_FORM_DATA, NATURE_MISSING, NATURE_OBJECT, NATURE_QUERY, add, arrayEntryToQuery, assign, buildArrayFromFormData, buildArrayFromObject, buildArrayFromQuery, buildFormDataFromArray, buildObjectFromArray, buildQueryFromArray, buildURL, fromField, fromForm, fromURL, get, isPrimitiveValue, merge, natureOf, safeGet, safeSet, submittingButton, toArray, toFormData, toObject, toQuery, u;\n    u = up.util;\n    NATURE_MISSING = 0;\n    NATURE_ARRAY = 1;\n    NATURE_QUERY = 2;\n    NATURE_FORM_DATA = 3;\n    NATURE_OBJECT = 4;\n    natureOf = function(params) {\n      if (u.isMissing(params)) {\n        return NATURE_MISSING;\n      } else if (u.isArray(params)) {\n        return NATURE_ARRAY;\n      } else if (u.isString(params)) {\n        return NATURE_QUERY;\n      } else if (u.isFormData(params)) {\n        return NATURE_FORM_DATA;\n      } else if (u.isObject(params)) {\n        return NATURE_OBJECT;\n      } else {\n        return up.fail(\"Unsupport params type: %o\", params);\n      }\n    };\n\n    /***\n    Returns an array representation of the given `params`.\n    \n    The given params value may be of any [supported type](/up.params).\n    \n    Each element in the returned array is an object with `{ name }` and `{ value }` properties.\n    \n    \\#\\#\\# Example\n    \n        var array = up.params.toArray('foo=bar&baz=bam')\n    \n        // array is now: [\n        //   { name: 'foo', value: 'bar' },\n        //   { name: 'baz', value: 'bam' },\n        // ]\n    \n    @function up.params.toArray\n    @param {Object|FormData|string|Array|undefined} params\n      the params to convert\n    @return {Array}\n      an array representation of the given params\n    @experimental\n     */\n    toArray = function(params) {\n      switch (natureOf(params)) {\n        case NATURE_MISSING:\n          return [];\n        case NATURE_ARRAY:\n          return params;\n        case NATURE_QUERY:\n          return buildArrayFromQuery(params);\n        case NATURE_FORM_DATA:\n          return buildArrayFromFormData(params);\n        case NATURE_OBJECT:\n          return buildArrayFromObject(params);\n      }\n    };\n\n    /***\n    Returns an object representation of the given `params`.\n    \n    The given params value may be of any [supported type](/up.params).\n    \n    The returned value is a simple JavaScript object whose properties correspond\n    to the key/values in the given `params`.\n    \n    \\#\\#\\# Example\n    \n        var object = up.params.toObject('foo=bar&baz=bam')\n    \n        // object is now: {\n        //   foo: 'bar',\n        //   baz: 'bam'\n        // ]\n    \n    @function up.params.toObject\n    @param {Object|FormData|string|Array|undefined} params\n      the params to convert\n    @return {Array}\n      an object representation of the given params\n    @experimental\n     */\n    toObject = function(params) {\n      switch (natureOf(params)) {\n        case NATURE_MISSING:\n          return {};\n        case NATURE_ARRAY:\n        case NATURE_QUERY:\n        case NATURE_FORM_DATA:\n          return buildObjectFromArray(toArray(params));\n        case NATURE_OBJECT:\n          return params;\n      }\n    };\n\n    /***\n    Returns [`FormData`](https://developer.mozilla.org/en-US/docs/Web/API/FormData) representation of the given `params`.\n    \n    The given params value may be of any [supported type](/up.params).\n    \n    \\#\\#\\# Example\n    \n        var formData = up.params.toFormData('foo=bar&baz=bam')\n    \n        formData.get('foo') // 'bar'\n        formData.get('baz') // 'bam'\n    \n    @function up.params.toFormData\n    @param {Object|FormData|string|Array|undefined} params\n      the params to convert\n    @return {FormData}\n      a [`FormData`](https://developer.mozilla.org/en-US/docs/Web/API/FormData) representation of the given params\n    @experimental\n     */\n    toFormData = function(params) {\n      switch (natureOf(params)) {\n        case NATURE_MISSING:\n          return new FormData();\n        case NATURE_ARRAY:\n        case NATURE_QUERY:\n        case NATURE_OBJECT:\n          return buildFormDataFromArray(toArray(params));\n        case NATURE_FORM_DATA:\n          return params;\n      }\n    };\n\n    /***\n    Returns an query string for the given `params`.\n    \n    The given params value may be of any [supported type](/up.params).\n    \n    The keys and values in the returned query string will be [percent-encoded](https://developer.mozilla.org/en-US/docs/Glossary/percent-encoding).\n    Non-primitive values (like [`File`](https://developer.mozilla.org/en-US/docs/Web/API/File) will be omitted from\n    the retuned query string.\n    \n    \\#\\#\\# Example\n    \n        var query = up.params.toQuery({ foo: 'bar', baz: 'bam' })\n    \n        // query is now: 'foo=bar&baz=bam'\n    \n    @function up.params.toQuery\n    @param {Object|FormData|string|Array|undefined} params\n      the params to convert\n    @return {string}\n      a query string built from the given params\n    @experimental\n     */\n    toQuery = function(params) {\n      switch (natureOf(params)) {\n        case NATURE_MISSING:\n          return '';\n        case NATURE_QUERY:\n          return params;\n        case NATURE_ARRAY:\n        case NATURE_FORM_DATA:\n        case NATURE_OBJECT:\n          return buildQueryFromArray(toArray(params));\n      }\n    };\n    arrayEntryToQuery = function(entry) {\n      var query, value;\n      value = entry.value;\n      if (!isPrimitiveValue(value)) {\n        return void 0;\n      }\n      query = encodeURIComponent(entry.name);\n      if (u.isGiven(value)) {\n        query += \"=\";\n        query += encodeURIComponent(value);\n      }\n      return query;\n    };\n\n    /***\n    Returns whether the given value can be encoded into a query string.\n    \n    We will have `File` values in our params when we serialize a form with a file input.\n    These entries will be filtered out when converting to a query string.\n     */\n    isPrimitiveValue = function(value) {\n      return u.isMissing(value) || u.isString(value) || u.isNumber(value) || u.isBoolean(value);\n    };\n    safeSet = function(obj, k, value) {\n      if (!u.isBasicObjectProperty(k)) {\n        return obj[k] = value;\n      }\n    };\n    safeGet = function(obj, k) {\n      if (!u.isBasicObjectProperty(k)) {\n        return obj[k];\n      }\n    };\n    buildQueryFromArray = function(array) {\n      var parts;\n      parts = u.map(array, arrayEntryToQuery);\n      parts = u.compact(parts);\n      return parts.join('&');\n    };\n    buildArrayFromQuery = function(query) {\n      var array, i, len, name, part, ref, ref1, value;\n      array = [];\n      ref = query.split('&');\n      for (i = 0, len = ref.length; i < len; i++) {\n        part = ref[i];\n        if (part) {\n          ref1 = part.split('='), name = ref1[0], value = ref1[1];\n          name = decodeURIComponent(name);\n          if (u.isGiven(value)) {\n            value = decodeURIComponent(value);\n          } else {\n            value = null;\n          }\n          array.push({\n            name: name,\n            value: value\n          });\n        }\n      }\n      return array;\n    };\n    buildArrayFromObject = function(object) {\n      var array, k, v;\n      array = [];\n      for (k in object) {\n        v = object[k];\n        array.push({\n          name: k,\n          value: v\n        });\n      }\n      return array;\n    };\n    buildObjectFromArray = function(array) {\n      var entry, i, len, obj;\n      obj = {};\n      for (i = 0, len = array.length; i < len; i++) {\n        entry = array[i];\n        safeSet(obj, entry.name, entry.value);\n      }\n      return obj;\n    };\n    buildArrayFromFormData = function(formData) {\n      var array;\n      array = [];\n      u.eachIterator(formData.entries(), function(value) {\n        var name, ref;\n        ref = value, name = ref[0], value = ref[1];\n        return array.push({\n          name: name,\n          value: value\n        });\n      });\n      return array;\n    };\n    buildFormDataFromArray = function(array) {\n      var entry, formData, i, len;\n      formData = new FormData();\n      for (i = 0, len = array.length; i < len; i++) {\n        entry = array[i];\n        formData.append(entry.name, entry.value);\n      }\n      return formData;\n    };\n    buildURL = function(base, params) {\n      var parts, separator;\n      parts = [base, toQuery(params)];\n      parts = u.select(parts, u.isPresent);\n      separator = u.contains(base, '?') ? '&' : '?';\n      return parts.join(separator);\n    };\n\n    /***\n    Adds to the given `params` a new  entry with the given `name` and `value`.\n    \n    The given params value may be of any [supported type](/up.params).\n    \n    The given `params` value is changed in-place, if possible. Some types, such as query strings,\n    cannot be changed in-place. The return value is always a params value that includes the new entry.\n    \n    \\#\\#\\# Example\n    \n        var obj = { foo: 'bar' }\n        up.params.add(obj, 'baz', 'bam')\n        // obj is now: { foo: 'bar', baz: 'bam' }\n    \n    @function up.params.add\n    @param {string|object|FormData|Array|undefined} params\n    @param {string} name\n    @param {any} value\n    @return {string|object|FormData|Array}\n    @experimental\n     */\n    add = function(params, name, value) {\n      var newEntry;\n      newEntry = [\n        {\n          name: name,\n          value: value\n        }\n      ];\n      return assign(params, newEntry);\n    };\n\n    /***\n    Returns a new params value that contains entries from both `params` and `otherParams`.\n    \n    The given params value may be of any [supported type](/up.params).\n    \n    This function creates a new params value. The given `params` argument is not changed.\n    \n    @function up.params.merge\n    @param {string|object|FormData|Array|undefined} params\n    @param {string|object|FormData|Array|undefined} otherParams\n    @return {string|object|FormData|Array}\n    @experimental\n     */\n    merge = function(params, otherParams) {\n      var formData, otherArray, otherQuery, parts;\n      switch (natureOf(params)) {\n        case NATURE_MISSING:\n          return merge({}, otherParams);\n        case NATURE_ARRAY:\n          otherArray = toArray(otherParams);\n          return params.concat(otherArray);\n        case NATURE_FORM_DATA:\n          formData = new FormData();\n          assign(formData, params);\n          assign(formData, otherParams);\n          return formData;\n        case NATURE_QUERY:\n          otherQuery = toQuery(otherParams);\n          parts = u.select([params, otherQuery], u.isPresent);\n          return parts.join('&');\n        case NATURE_OBJECT:\n          return u.merge(params, toObject(otherParams));\n      }\n    };\n\n    /***\n    Returns the first param value with the given `name` from the given `params`.\n    \n    The given params value may be of any [supported type](/up.params).\n    \n    \\#\\#\\# Example\n    \n        var array = [\n          { name: 'foo', value: 'bar' },\n          { name: 'baz', value: 'bam' }\n        }\n    \n        value = up.params.get(array, 'baz')\n        // value is now: 'bam'\n    \n    @function up.params.get\n    @experimental\n     */\n    get = function(params, name) {\n      var entry, value;\n      switch (natureOf(params)) {\n        case NATURE_MISSING:\n          return void 0;\n        case NATURE_ARRAY:\n          entry = u.detect(params, function(entry) {\n            return entry.name === name;\n          });\n          return entry != null ? entry.value : void 0;\n        case NATURE_FORM_DATA:\n          value = params.get(name);\n          if (u.isNull(value)) {\n            value = void 0;\n          }\n          return value;\n        case NATURE_QUERY:\n          return safeGet(toObject(params), name);\n        case NATURE_OBJECT:\n          return safeGet(params, name);\n      }\n    };\n\n    /***\n    Extends the given `params` with entries from the given `otherParams`.\n    \n    The given params value may be of any [supported type](/up.params).\n    \n    The given `params` is changed in-place, if possible. Some types, such as query strings,\n    cannot be changed in-place. The return value is always a params value that includes the new entries.\n    \n    @function up.params.assign\n    @param {string|object|FormData|Array|undefined} params\n    @param {string|object|FormData|Array|undefined} otherParams\n    @return {string|object|FormData|Array}\n    @experimental\n     */\n    assign = function(params, otherParams) {\n      var entry, i, len, otherArray;\n      switch (natureOf(params)) {\n        case NATURE_ARRAY:\n          otherArray = toArray(otherParams);\n          params.push.apply(params, otherArray);\n          return params;\n        case NATURE_FORM_DATA:\n          otherArray = toArray(otherParams);\n          for (i = 0, len = otherArray.length; i < len; i++) {\n            entry = otherArray[i];\n            params.append(entry.name, entry.value);\n          }\n          return params;\n        case NATURE_OBJECT:\n          return u.assign(params, toObject(otherParams));\n        case NATURE_QUERY:\n        case NATURE_MISSING:\n          return merge(params, otherParams);\n      }\n    };\n    submittingButton = function(form) {\n      var $activeElement, $form, submitButtonSelector;\n      $form = $(form);\n      submitButtonSelector = up.form.submitButtonSelector();\n      $activeElement = $(document.activeElement);\n      if ($activeElement.is(submitButtonSelector) && $form.has($activeElement)) {\n        return $activeElement[0];\n      } else {\n        return $form.find(submitButtonSelector)[0];\n      }\n    };\n\n    /***\n    Serializes request params from the given `<form>`.\n    \n    The returned params may be passed as `{ params }` option to\n    [`up.request()`](/up.request) or [`up.replace()`](/up.replace).\n    \n    The serialized params will include the form's submit button, if that\n    button as a `name` attribute.\n    \n    \\#\\#\\#\\# Example\n    \n    Given this HTML form:\n    \n        <form>\n          <input type=\"text\" name=\"name\" value=\"Foo Bar\">\n          <input type=\"text\" name=\"email\" value=\"foo@bar.com\">\n        </form>\n    \n    This would serialize the form into an array representation:\n    \n        var params = up.params.fromForm('input[name=email]')\n    \n        // params is now: [\n        //   { name: 'name', value: 'Foo Bar' },\n        //   { name: 'email', value: 'foo@bar.com' }\n        // ]\n    \n    @function up.params.fromForm\n    @param {Element|jQuery|string} form\n    @return {Array}\n    @experimental\n     */\n    fromForm = function(form) {\n      var button, fields;\n      if (form = u.element(form)) {\n        fields = form.querySelectorAll(up.form.fieldSelector());\n        if (button = submittingButton(form)) {\n          fields = u.toArray(fields);\n          fields.push(button);\n        }\n        return u.flatMap(fields, fromField);\n      }\n    };\n\n    /***\n    Serializes request params from a single [input field](/up.form.config#config.fields).\n    To serialize an entire form, use [`up.params.fromForm()`](/up.params.fromForm).\n    \n    Note that some fields may produce multiple params, such as `<select multiple>`.\n    \n    \\#\\#\\#\\# Example\n    \n    Given this HTML form:\n    \n        <form>\n          <input type=\"text\" name=\"email\" value=\"foo@bar.com\">\n          <input type=\"password\" name=\"password\">\n        </form>\n    \n    This would retrieve request parameters from the `email` field:\n    \n        var params = up.params.fromField('input[name=email]')\n    \n        // params is now: [{ name: 'email', value: 'foo@bar.com' }]\n    \n    @function up.params.fromField\n    @param {Element|jQuery|string} form\n    @return {Array}\n      an array of `{ name, value }` objects\n    @experimental\n     */\n    fromField = function(field) {\n      var file, i, j, len, len1, name, option, params, ref, ref1, tagName, type;\n      params = [];\n      if ((field = u.element(field)) && (name = field.name) && (!field.disabled)) {\n        tagName = field.tagName;\n        type = field.type;\n        if (tagName === 'SELECT') {\n          ref = field.querySelectorAll('option');\n          for (i = 0, len = ref.length; i < len; i++) {\n            option = ref[i];\n            if (option.selected) {\n              params.push({\n                name: name,\n                value: option.value\n              });\n            }\n          }\n        } else if (type === 'checkbox' || type === 'radio') {\n          if (field.checked) {\n            params.push({\n              name: name,\n              value: field.value\n            });\n          }\n        } else if (type === 'file') {\n          ref1 = field.files;\n          for (j = 0, len1 = ref1.length; j < len1; j++) {\n            file = ref1[j];\n            params.push({\n              name: name,\n              value: file\n            });\n          }\n        } else {\n          params.push({\n            name: name,\n            value: field.value\n          });\n        }\n      }\n      return params;\n    };\n\n    /***\n    Returns the [query string](https://en.wikipedia.org/wiki/Query_string) from the given URL.\n    \n    The query string is returned **without** a leading question mark (`?`).\n    Returns `undefined` if the given URL has no query component.\n    \n    You can access individual values from the returned query string using functions like\n    [`up.params.get()`](/up.params.get) or [`up.params.toObject()`](/up.params.toObject).\n    \n    \\#\\#\\# Example\n    \n        var query = up.params.fromURL('http://foo.com?bar=baz')\n    \n        // query is now: 'bar=baz'\n    \n    @function up.params.fromURL\n    @param {string} url\n      The URL from which to extract the query string.\n    @return {string|undefined}\n      The given URL's query string, or `undefined` if the URL has no query component.\n    @experimental\n     */\n    fromURL = function(url) {\n      var query, urlParts;\n      urlParts = u.parseUrl(url);\n      if (query = urlParts.search) {\n        query = query.replace(/^\\?/, '');\n        return query;\n      }\n    };\n    return {\n      toArray: toArray,\n      toObject: toObject,\n      toQuery: toQuery,\n      toFormData: toFormData,\n      buildURL: buildURL,\n      get: get,\n      add: add,\n      assign: assign,\n      merge: merge,\n      fromForm: fromForm,\n      fromURL: fromURL\n    };\n  })(jQuery);\n\n}).call(this);\n(function() {\n\n\n}).call(this);\n\n/***\nServer protocol\n===============\n\nYou rarely need to change server-side code\nin order to use Unpoly. There is no need to provide a JSON API, or add\nextra routes for AJAX requests. The server simply renders a series\nof full HTML pages, just like it would without Unpoly.\n\nThat said, there is an **optional** protocol your server can use to\nexchange additional information when Unpoly is [updating fragments](/up.link).\n\nWhile the protocol can help you optimize performance and handle some\nedge cases, implementing it is **entirely optional**. For instance,\n`unpoly.com` itself is a static site that uses Unpoly on the frontend\nand doesn't even have a server component.\n\n## Existing implementations\n\nYou should be able to implement the protocol in a very short time.\nThere are existing implementations for various web frameworks:\n\n- [Ruby on Rails](/install/rails)\n- [Roda](https://github.com/adam12/roda-unpoly)\n- [Rack](https://github.com/adam12/rack-unpoly) (Sinatra, Padrino, Hanami, Cuba, ...)\n- [Phoenix](https://elixirforum.com/t/unpoly-a-framework-like-turbolinks/3614/15) (Elixir)\n\n\n## Protocol details\n\n\\#\\#\\# Redirect detection for IE11\n\nOn Internet Explorer 11, Unpoly cannot detect the final URL after a redirect.\nYou can fix this edge case by delivering an additional HTTP header\nwith the *last* response in a series of redirects:\n\n```http\nX-Up-Location: /current-url\n```\n\nThe **simplest implementation** is to set these headers for every request.\n\n\n\\#\\#\\# Optimizing responses\n\nWhen [updating a fragment](/up.link), Unpoly will send an\nadditional HTTP header containing the CSS selector that is being replaced:\n\n```http\nX-Up-Target: .user-list\n```\n\nServer-side code is free to **optimize its response** by only returning HTML\nthat matches the selector. For example, you might prefer to not render an\nexpensive sidebar if the sidebar is not targeted.\n\nUnpoly will often update a different selector in case the request fails.\nThis selector is also included as a HTTP header:\n\n```\nX-Up-Fail-Target: body\n```\n\n\n\\#\\#\\# Pushing a document title to the client\n\nWhen [updating a fragment](/up.link), Unpoly will by default\nextract the `<title>` from the server response and update the document title accordingly.\n\nThe server can also force Unpoly to set a document title by passing a HTTP header:\n\n```http\nX-Up-Title: My server-pushed title\n```\n\nThis is useful when you [optimize your response](#optimizing-responses) and not render\nthe application layout unless it is targeted. Since your optimized response\nno longer includes a `<title>`, you can instead use the HTTP header to pass the document title.\n\n\n\\#\\#\\# Signaling failed form submissions\n\nWhen [submitting a form via AJAX](/form-up-target)\nUnpoly needs to know whether the form submission has failed (to update the form with\nvalidation errors) or succeeded (to update the `up-target` selector).\n\nFor Unpoly to be able to detect a failed form submission, the response must be\nreturn a non-200 HTTP status code. We recommend to use either\n400 (bad request) or 422 (unprocessable entity).\n\nTo do so in [Ruby on Rails](http://rubyonrails.org/), pass a [`:status` option to `render`](http://guides.rubyonrails.org/layouts_and_rendering.html#the-status-option):\n\n    class UsersController < ApplicationController\n\n      def create\n        user_params = params[:user].permit(:email, :password)\n        @user = User.new(user_params)\n        if @user.save?\n          sign_in @user\n        else\n          render 'form', status: :bad_request\n        end\n      end\n\n    end\n\n\n\\#\\#\\# Detecting live form validations\n\nWhen [validating a form](/input-up-validate), Unpoly will\nsend an additional HTTP header containing a CSS selector for the form that is\nbeing updated:\n\n```http\nX-Up-Validate: .user-form\n```\n\nWhen detecting a validation request, the server is expected to **validate (but not save)**\nthe form submission and render a new copy of the form with validation errors.\n\nBelow you will an example for a writing route that is aware of Unpoly's live form\nvalidations. The code is for [Ruby on Rails](http://rubyonrails.org/),\nbut you can adapt it for other languages:\n\n    class UsersController < ApplicationController\n\n      def create\n        user_params = params[:user].permit(:email, :password)\n        @user = User.new(user_params)\n        if request.headers['X-Up-Validate']\n          @user.valid?  # run validations, but don't save to the database\n          render 'form' # render form with error messages\n        elsif @user.save?\n          sign_in @user\n        else\n          render 'form', status: :bad_request\n        end\n      end\n\n    end\n\n\n\\#\\#\\# Signaling the initial request method\n\nIf the initial page was loaded  with a non-`GET` HTTP method, Unpoly prefers to make a full\npage load when you try to update a fragment. Once the next page was loaded with a `GET` method,\nUnpoly will restore its standard behavior.\n\nThis fixes two edge cases you might or might not care about:\n\n1. Unpoly replaces the initial page state so it can later restore it when the user\n   goes back to that initial URL. However, if the initial request was a POST,\n   Unpoly will wrongly assume that it can restore the state by reloading with GET.\n2. Some browsers have a bug where the initial request method is used for all\n   subsequently pushed states. That means if the user reloads the page on a later\n   GET state, the browser will wrongly attempt a POST request.\n   This issue affects Safari 9 and 10 (last tested in 2017-08).\n   Modern Firefoxes, Chromes and IE10+ don't have this behavior.\n\nIn order to allow Unpoly to detect the HTTP method of the initial page load,\nthe server must set a cookie:\n\n```http\nSet-Cookie: _up_method=POST\n```\n\nWhen Unpoly boots, it will look for this cookie and configure its behavior accordingly.\nThe cookie is then deleted in order to not affect following requests.\n\nThe **simplest implementation** is to set this cookie for every request that is neither\n`GET` nor contains an [`X-Up-Target` header](/#optimizing-responses). For all other requests\nan existing cookie should be deleted.\n\n\n@class up.protocol\n */\n\n(function() {\n  up.protocol = (function($) {\n    var config, csrfParam, csrfToken, initialRequestMethod, locationFromXhr, methodFromXhr, reset, titleFromXhr, u;\n    u = up.util;\n\n    /***\n    @function up.protocol.locationFromXhr\n    @internal\n     */\n    locationFromXhr = function(xhr) {\n      return xhr.getResponseHeader(config.locationHeader) || xhr.responseURL;\n    };\n\n    /***\n    @function up.protocol.titleFromXhr\n    @internal\n     */\n    titleFromXhr = function(xhr) {\n      return xhr.getResponseHeader(config.titleHeader);\n    };\n\n    /***\n    @function up.protocol.methodFromXhr\n    @internal\n     */\n    methodFromXhr = function(xhr) {\n      var method;\n      if (method = xhr.getResponseHeader(config.methodHeader)) {\n        return u.normalizeMethod(method);\n      }\n    };\n\n    /***\n    Server-side companion libraries like unpoly-rails set this cookie so we\n    have a way to detect the request method of the initial page load.\n    There is no JavaScript API for this.\n    \n    @function up.protocol.initialRequestMethod\n    @internal\n     */\n    initialRequestMethod = u.memoize(function() {\n      var methodFromServer;\n      methodFromServer = up.browser.popCookie(config.methodCookie);\n      return (methodFromServer || 'get').toLowerCase();\n    });\n    up.bus.on('up:framework:booted', initialRequestMethod);\n\n    /***\n    Configures strings used in the optional [server protocol](/up.protocol).\n    \n    @property up.protocol.config\n    @param {String} [config.targetHeader='X-Up-Target']\n    @param {String} [config.failTargetHeader='X-Up-Fail-Target']\n    @param {String} [config.locationHeader='X-Up-Location']\n    @param {String} [config.titleHeader='X-Up-Title']\n    @param {String} [config.validateHeader='X-Up-Validate']\n    @param {String} [config.methodHeader='X-Up-Method']\n    @param {String} [config.methodCookie='_up_method']\n      The name of the optional cookie the server can send to\n      [signal the initial request method](/up.protocol#signaling-the-initial-request-method).\n    @param {String} [config.methodParam='_method']\n      The name of the POST parameter when [wrapping HTTP methods](/up.proxy.config#config.wrapMethods)\n      in a `POST` request.\n    @param {String} [config.csrfHeader='X-CSRF-Token']\n      The name of the HTTP header that will include the\n      [CSRF token](https://en.wikipedia.org/wiki/Cross-site_request_forgery#Synchronizer_token_pattern)\n      for AJAX requests.\n    @param {String|Function} [config.csrfParam]\n      The `name` of the hidden `<input>` used for sending a\n      [CSRF token](https://en.wikipedia.org/wiki/Cross-site_request_forgery#Synchronizer_token_pattern) when\n      submitting a default, non-AJAX form. For AJAX request the token is sent as an HTTP header instead.\n    \n      The parameter name can be configured as a string or as function that returns the parameter name.\n      If no name is set, no token will be sent.\n    \n      Defaults to the `content` attribute of a `<meta>` tag named `csrf-token`:\n    \n          <meta name=\"csrf-param\" content=\"authenticity_token\" />\n    \n    @param {String|Function} [config.csrfToken]\n      The [CSRF token](https://en.wikipedia.org/wiki/Cross-site_request_forgery#Synchronizer_token_pattern)\n      to send for unsafe requests. The token will be sent as either a HTTP header (for AJAX requests)\n      or hidden form `<input>` (for default, non-AJAX form submissions).\n    \n      The token can either be configured as a string or as function that returns the token.\n      If no token is set, no token will be sent.\n    \n      Defaults to the `content` attribute of a `<meta>` tag named `csrf-token`:\n    \n          <meta name='csrf-token' content='secret12345'>\n    \n    @experimental\n     */\n    config = u.config({\n      targetHeader: 'X-Up-Target',\n      failTargetHeader: 'X-Up-Fail-Target',\n      locationHeader: 'X-Up-Location',\n      validateHeader: 'X-Up-Validate',\n      titleHeader: 'X-Up-Title',\n      methodHeader: 'X-Up-Method',\n      methodCookie: '_up_method',\n      methodParam: '_method',\n      csrfParam: function() {\n        return $('meta[name=\"csrf-param\"]').attr('content');\n      },\n      csrfToken: function() {\n        return $('meta[name=\"csrf-token\"]').attr('content');\n      },\n      csrfHeader: 'X-CSRF-Token'\n    });\n    csrfParam = function() {\n      return u.evalOption(config.csrfParam);\n    };\n    csrfToken = function() {\n      return u.evalOption(config.csrfToken);\n    };\n    reset = function() {\n      return config.reset();\n    };\n    return {\n      config: config,\n      reset: reset,\n      locationFromXhr: locationFromXhr,\n      titleFromXhr: titleFromXhr,\n      methodFromXhr: methodFromXhr,\n      csrfParam: csrfParam,\n      csrfToken: csrfToken,\n      initialRequestMethod: initialRequestMethod\n    };\n  })(jQuery);\n\n}).call(this);\n\n/***\nLogging\n=======\n\nUnpoly can print debugging information to the developer console, e.g.:\n\n- Which [events](/up.bus) are called\n- When we're [making requests to the network](/up.proxy)\n- Which [compilers](/up.syntax) are applied to which elements\n\nYou can activate logging by calling [`up.log.enable()`](/up.log.enable).\nThe output can be configured using the [`up.log.config`](/up.log.config) property.\n\n@class up.log\n */\n\n(function() {\n  var slice = [].slice;\n\n  up.log = (function($) {\n    var b, config, debug, disable, enable, error, group, prefix, printBanner, puts, reset, sessionStore, setEnabled, u, warn;\n    u = up.util;\n    b = up.browser;\n    sessionStore = new up.store.Session('up.log');\n\n    /***\n    Configures the logging output on the developer console.\n    \n    @property up.log.config\n    @param {boolean} [options.enabled=false]\n      Whether Unpoly will print debugging information to the developer console.\n    \n      Debugging information includes which elements are being [compiled](/up.syntax)\n      and which [events](/up.bus) are being emitted.\n      Note that errors will always be printed, regardless of this setting.\n    @param {boolean} [options.collapse=false]\n      Whether debugging information is printed as a collapsed tree.\n    \n      Set this to `true` if you are overwhelmed by the debugging information Unpoly\n      prints to the developer console.\n    @param {string} [options.prefix='[UP] ']\n      A string to prepend to Unpoly's logging messages so you can distinguish it from your own messages.\n    @stable\n     */\n    config = u.config({\n      prefix: '[UP] ',\n      enabled: sessionStore.get('enabled'),\n      collapse: false\n    });\n    reset = function() {\n      return config.reset();\n    };\n    prefix = function(message) {\n      return \"\" + config.prefix + message;\n    };\n\n    /***\n    Prints a debugging message to the browser console.\n    \n    @function up.log.debug\n    @param {string} message\n    @param {Array} args...\n    @internal\n     */\n    debug = function() {\n      var args, message;\n      message = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];\n      if (config.enabled && message) {\n        return b.puts.apply(b, ['debug', prefix(message)].concat(slice.call(args)));\n      }\n    };\n\n    /***\n    Prints a logging message to the browser console.\n    \n    @function up.puts\n    @param {string} message\n    @param {Array} args...\n    @internal\n     */\n    puts = function() {\n      var args, message;\n      message = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];\n      if (config.enabled && message) {\n        return b.puts.apply(b, ['log', prefix(message)].concat(slice.call(args)));\n      }\n    };\n\n    /***\n    @function up.warn\n    @internal\n     */\n    warn = function() {\n      var args, message;\n      message = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];\n      if (message) {\n        return b.puts.apply(b, ['warn', prefix(message)].concat(slice.call(args)));\n      }\n    };\n\n    /***\n    - Makes sure the group always closes\n    - Does not make a group if the message is nil\n    \n    @function up.log.group\n    @internal\n     */\n    group = function() {\n      var args, block, message, stream;\n      message = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];\n      block = args.pop();\n      if (config.enabled && message) {\n        stream = config.collapse ? 'groupCollapsed' : 'group';\n        b.puts.apply(b, [stream, prefix(message)].concat(slice.call(args)));\n        try {\n          return block();\n        } finally {\n          if (message) {\n            b.puts('groupEnd');\n          }\n        }\n      } else {\n        return block();\n      }\n    };\n\n    /***\n    @function up.log.error\n    @internal\n     */\n    error = function() {\n      var args, message;\n      message = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];\n      if (message) {\n        return b.puts.apply(b, ['error', prefix(message)].concat(slice.call(args)));\n      }\n    };\n    printBanner = function() {\n      var banner;\n      banner = \" __ _____  ___  ___  / /_ __\\n\" + (\"/ // / _ \\\\/ _ \\\\/ _ \\\\/ / // /  \" + up.version + \"\\n\") + \"\\\\___/_//_/ .__/\\\\___/_/\\\\_. / \\n\" + \"        / /            / /\\n\" + \"\\n\";\n      if (config.enabled) {\n        banner += \"Call `up.log.disable()` to disable logging for this session.\";\n      } else {\n        banner += \"Call `up.log.enable()` to enable logging for this session.\";\n      }\n      return b.puts('log', banner);\n    };\n    up.on('up:framework:boot', printBanner);\n    up.on('up:framework:reset', reset);\n    setEnabled = function(value) {\n      sessionStore.set('enabled', value);\n      return config.enabled = value;\n    };\n\n    /***\n    Makes future Unpoly events print vast amounts of debugging information to the developer console.\n    \n    Debugging information includes which elements are being [compiled](/up.syntax)\n    and which [events](/up.bus) are being emitted.\n    \n    @function up.log.enable\n    @stable\n     */\n    enable = function() {\n      return setEnabled(true);\n    };\n\n    /***\n    Prevents future Unpoly events from printing vast amounts of debugging information to the developer console.\n    \n    Errors will still be printed, even with logging disabled.\n    \n    @function up.log.disable\n    @stable\n     */\n    disable = function() {\n      return setEnabled(false);\n    };\n    return {\n      puts: puts,\n      debug: debug,\n      error: error,\n      warn: warn,\n      group: group,\n      config: config,\n      enable: enable,\n      disable: disable\n    };\n  })(jQuery);\n\n  up.puts = up.log.puts;\n\n  up.warn = up.log.warn;\n\n}).call(this);\n\n/***\nToast alerts\n============\n\n@class up.toast\n */\n\n(function() {\n  var slice = [].slice;\n\n  up.toast = (function($) {\n    var VARIABLE_FORMATTER, addAction, b, close, isOpen, messageToHtml, open, reset, state, u;\n    u = up.util;\n    b = up.browser;\n    VARIABLE_FORMATTER = function(arg) {\n      return \"<span class='up-toast-variable'>\" + (u.escapeHtml(arg)) + \"</span>\";\n    };\n    state = u.config({\n      $toast: null\n    });\n    reset = function() {\n      close();\n      return state.reset();\n    };\n    messageToHtml = function(message) {\n      if (u.isArray(message)) {\n        message[0] = u.escapeHtml(message[0]);\n        message = b.sprintfWithFormattedArgs.apply(b, [VARIABLE_FORMATTER].concat(slice.call(message)));\n      } else {\n        message = u.escapeHtml(message);\n      }\n      return message;\n    };\n    isOpen = function() {\n      return !!state.$toast;\n    };\n    addAction = function($actions, label, callback) {\n      var $action;\n      $action = $('<span class=\"up-toast-action\"></span>').text(label);\n      $action.on('click', callback);\n      return $action.appendTo($actions);\n    };\n    open = function(message, options) {\n      var $actions, $message, $toast, action;\n      if (options == null) {\n        options = {};\n      }\n      close();\n      $toast = $('<div class=\"up-toast\"></div>').prependTo('body');\n      $message = $('<div class=\"up-toast-message\"></div>').appendTo($toast);\n      $actions = $('<div class=\"up-toast-actions\"></div>').appendTo($toast);\n      message = messageToHtml(message);\n      $message.html(message);\n      if (action = options.action || options.inspect) {\n        addAction($actions, action.label, action.callback);\n      }\n      addAction($actions, 'Close', close);\n      return state.$toast = $toast;\n    };\n    close = function() {\n      if (isOpen()) {\n        state.$toast.remove();\n        return state.$toast = null;\n      }\n    };\n    up.on('up:framework:reset', reset);\n    return {\n      open: open,\n      close: close,\n      reset: reset,\n      isOpen: isOpen\n    };\n  })(jQuery);\n\n}).call(this);\n\n/***\nCustom JavaScript\n=================\n\nEvery app needs a way to pair JavaScript snippets with certain HTML elements,\nin order to integrate libraries or implement custom behavior.\n\nUnpoly lets you organize your JavaScript snippets using [compilers](/up.compiler).\n\nFor instance, to activate the [Masonry](http://masonry.desandro.com/) jQuery plugin for every element\nwith a `grid` class, use this compiler:\n\n    up.compiler('.grid', function($element) {\n      $element.masonry();\n    });\n\nThe compiler function will be called on matching elements when the page loads\nor when a matching fragment is [inserted via AJAX](/up.link) later.\n\n@class up.syntax\n */\n\n(function() {\n  var slice = [].slice;\n\n  up.syntax = (function($) {\n    var SYSTEM_MACRO_PRIORITIES, buildCompiler, clean, compile, compilers, detectSystemMacroPriority, insertCompiler, isBooting, macros, readData, registerCompiler, registerDestructor, registerMacro, reset, u;\n    u = up.util;\n    SYSTEM_MACRO_PRIORITIES = {\n      '[up-back]': -100,\n      '[up-drawer]': -200,\n      '[up-dash]': -200,\n      '[up-expand]': -300,\n      '[data-method]': -400,\n      '[data-confirm]': -400\n    };\n    isBooting = true;\n    compilers = [];\n    macros = [];\n\n    /***\n    Registers a function to be called whenever an element with\n    the given selector is inserted into the DOM.\n    \n    Use compilers to activate your custom Javascript behavior on matching\n    elements.\n    \n    You should migrate your [jQuery ready callbacks](https://api.jquery.com/ready/)\n    to compilers.\n    \n    \n    \\#\\#\\# Example\n    \n    Let's say that any element with the `action` class should alert a message when clicked.\n    We can implement this behavior as a compiler function that is called on all elements matching\n    the `.action` selector:\n    \n        up.compiler('.action', function($element) {\n          $element.on('click', function() {\n            alert('Action was clicked!');\n          });\n        });\n    \n    The compiler function will be called once for each matching element when\n    the page loads, or when a matching fragment is [inserted](/up.replace) later.\n    \n    \n    \\#\\#\\# Integrating jQuery plugins\n    \n    `up.compiler()` is a great way to integrate jQuery plugins.\n    Let's say your JavaScript plugin wants you to call `lightboxify()`\n    on links that should open a lightbox. You decide to\n    do this for all links with an `lightbox` class:\n    \n        <a href=\"river.png\" class=\"lightbox\">River</a>\n        <a href=\"ocean.png\" class=\"lightbox\">Ocean</a>\n    \n    This JavaScript will do exactly that:\n    \n        up.compiler('a.lightbox', function($element) {\n          $element.lightboxify();\n        });\n    \n    \n    \\#\\#\\# Custom elements\n    \n    You can use `up.compiler()` to implement custom elements like this:\n    \n        <clock></clock>\n    \n    Here is the JavaScript that inserts the current time into to these elements:\n    \n        up.compiler('clock', function($element) {\n          var now = new Date();\n          $element.text(now.toString()));\n        });\n    \n    \n    \\#\\#\\# Cleaning up after yourself\n    \n    If your compiler returns a function, Unpoly will use this as a *destructor* to\n    clean up if the element leaves the DOM. Note that in Unpoly the same DOM ad JavaScript environment\n    will persist through many page loads, so it's important to not create\n    [memory leaks](https://makandracards.com/makandra/31325-how-to-create-memory-leaks-in-jquery).\n    \n    You should clean up after yourself whenever your compilers have global\n    side effects, like a [`setInterval`](https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/setInterval)\n    or [event handlers bound to the document root](/up.on).\n    \n    Here is a version of `<clock>` that updates\n    the time every second, and cleans up once it's done. Note how it returns\n    a function that calls `clearInterval`:\n    \n        up.compiler('clock', function($element) {\n    \n          function update() {\n            var now = new Date();\n            $element.text(now.toString()));\n          }\n    \n          setInterval(update, 1000);\n    \n          return function() {\n            clearInterval(update);\n          };\n    \n        });\n    \n    If we didn't clean up after ourselves, we would have many ticking intervals\n    operating on detached DOM elements after we have created and removed a couple\n    of `<clock>` elements.\n    \n    \n    \\#\\#\\# Attaching structured data\n    \n    In case you want to attach structured data to the event you're observing,\n    you can serialize the data to JSON and put it into an `[up-data]` attribute.\n    For instance, a container for a [Google Map](https://developers.google.com/maps/documentation/javascript/tutorial)\n    might attach the location and names of its marker pins:\n    \n        <div class='google-map' up-data='[\n          { \"lat\": 48.36, \"lng\": 10.99, \"title\": \"Friedberg\" },\n          { \"lat\": 48.75, \"lng\": 11.45, \"title\": \"Ingolstadt\" }\n        ]'></div>\n    \n    The JSON will parsed and handed to your compiler as a second argument:\n    \n        up.compiler('.google-map', function($element, pins) {\n    \n          var map = new google.maps.Map($element);\n    \n          pins.forEach(function(pin) {\n            var position = new google.maps.LatLng(pin.lat, pin.lng);\n            new google.maps.Marker({\n              position: position,\n              map: map,\n              title: pin.title\n            });\n          });\n    \n        });\n    \n    \n    \\#\\#\\# Migrating jQuery event handlers to `up.compiler()`\n    \n    Within the compiler, Unpoly will bind `this` to the\n    native DOM element to help you migrate your existing jQuery code to\n    this new syntax.\n    \n    So if you had this before:\n    \n        $(function() {\n          $('.action').on('click', function() {\n            $(this).something();\n          });\n        });\n    \n    ... you can reuse the callback function like this:\n    \n        up.compiler('.action', function($element) {\n          $element.on('click', function() {\n            $(this).something();\n          });\n        });\n    \n    \n    @function up.compiler\n    @param {string} selector\n      The selector to match.\n    @param {number} [options.priority=0]\n      The priority of this compiler.\n      Compilers with a higher priority are run first.\n      Two compilers with the same priority are run in the order they were registered.\n    @param {boolean} [options.batch=false]\n      If set to `true` and a fragment insertion contains multiple\n      elements matching the selector, `compiler` is only called once\n      with a jQuery collection containing all matching elements. \n    @param {boolean} [options.keep=false]\n      If set to `true` compiled fragment will be [persisted](/up-keep) during\n      [page updates](/a-up-target).\n    \n      This has the same effect as setting an `up-keep` attribute on the element.\n    @param {Function($element, data)} compiler\n      The function to call when a matching element is inserted.\n      The function takes the new element as the first argument (as a jQuery object).\n      If the element has an [`up-data`](/up-data) attribute, its value is parsed as JSON\n      and passed as a second argument.\n    \n      The function may return a destructor function that destroys the compiled\n      object before it is removed from the DOM. The destructor is supposed to\n      [clear global state](/up.compiler#cleaning-up-after-yourself)\n      such as timeouts and event handlers bound to the document.\n      The destructor is *not* expected to remove the element from the DOM, which\n      is already handled by [`up.destroy()`](/up.destroy).\n    @stable\n     */\n    registerCompiler = function() {\n      var args, compiler;\n      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n      compiler = buildCompiler.apply(null, args);\n      return insertCompiler(compilers, compiler);\n    };\n\n    /***\n    Registers a [compiler](/up.compiler) that is run before all other compilers.\n    \n    You can use `up.macro()` to register a compiler that sets other UJS attributes.\n    \n    \\#\\#\\# Example\n    \n    You will sometimes find yourself setting the same combination of UJS attributes again and again:\n    \n        <a href=\"/page1\" up-target=\".content\" up-transition=\"cross-fade\" up-duration=\"300\">Page 1</a>\n        <a href=\"/page2\" up-target=\".content\" up-transition=\"cross-fade\" up-duration=\"300\">Page 2</a>\n        <a href=\"/page3\" up-target=\".content\" up-transition=\"cross-fade\" up-duration=\"300\">Page 3</a>\n    \n    We would much rather define a new `content-link` attribute that let's us\n    write the same links like this:\n    \n        <a href=\"/page1\" content-link>Page 1</a>\n        <a href=\"/page2\" content-link>Page 2</a>\n        <a href=\"/page3\" content-link>Page 3</a>\n    \n    We can define the `content-link` attribute by registering a macro that\n    sets the `up-target`, `up-transition` and `up-duration` attributes for us:\n    \n        up.macro('[content-link]', function($link) {\n          $link.attr('up-target', '.content');\n          $link.attr('up-transition', 'cross-fade');\n          $link.attr('up-duration', '300');\n        });\n    \n    Examples for built-in macros are [`a[up-dash]`](/a-up-dash) and [`[up-expand]`](/up-expand).\n    \n    @function up.macro\n    @param {string} selector\n      The selector to match.\n    @param {Object} options\n      See options for [`up.compiler()`](/up.compiler).\n    @param {Function($element, data)} macro\n      The function to call when a matching element is inserted.\n      See [`up.compiler()`](/up.compiler) for details.\n    @stable\n     */\n    registerMacro = function() {\n      var args, macro;\n      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n      macro = buildCompiler.apply(null, args);\n      if (isBooting) {\n        macro.priority = detectSystemMacroPriority(macro.selector) || up.fail('Unregistered priority for system macro %o', macro.selector);\n      }\n      return insertCompiler(macros, macro);\n    };\n    detectSystemMacroPriority = function(macroSelector) {\n      var priority, substr;\n      for (substr in SYSTEM_MACRO_PRIORITIES) {\n        priority = SYSTEM_MACRO_PRIORITIES[substr];\n        if (macroSelector.indexOf(substr) >= 0) {\n          return priority;\n        }\n      }\n    };\n    buildCompiler = function() {\n      var args, callback, options, selector;\n      selector = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];\n      callback = args.pop();\n      options = u.extractOptions(args);\n      options = u.options(options, {\n        selector: selector,\n        isSystem: isBooting,\n        priority: 0,\n        batch: false,\n        keep: false\n      });\n      return u.assign(callback, options);\n    };\n    insertCompiler = function(queue, newCompiler) {\n      var existingCompiler, index;\n      index = 0;\n      while ((existingCompiler = queue[index]) && (existingCompiler.priority >= newCompiler.priority)) {\n        index += 1;\n      }\n      return queue.splice(index, 0, newCompiler);\n    };\n\n    /***\n    Applies all compilers on the given element and its descendants.\n    Unlike [`up.hello()`](/up.hello), this doesn't emit any events.\n    \n    @function up.syntax.compile\n    @param {Array<Element>} [options.skip]\n      A list of elements whose subtrees should not be compiled.\n    @internal\n     */\n    compile = function($fragment, options) {\n      var compileRun, orderedCompilers;\n      orderedCompilers = macros.concat(compilers);\n      compileRun = new up.CompilePass($fragment, orderedCompilers, options);\n      return compileRun.compile();\n    };\n\n    /***\n    @function up.syntax.destructor\n    @internal\n     */\n    registerDestructor = function(element, destructor) {\n      var destructors;\n      element = u.element(element);\n      if (!(destructors = element.upDestructors)) {\n        destructors = [];\n        element.upDestructors = destructors;\n        element.classList.add('up-can-clean');\n      }\n      return destructors.push(destructor);\n    };\n\n    /***\n    Runs any destroyers on the given fragment and its descendants.\n    Unlike [`up.destroy()`](/up.destroy), this doesn't emit any events\n    and does not remove the element from the DOM.\n    \n    @function up.syntax.clean\n    @internal\n     */\n    clean = function($fragment) {\n      var cleanables;\n      cleanables = u.selectInSubtree($fragment, '.up-can-clean');\n      return u.each(cleanables, function(cleanable) {\n        var destructor, destructors, i, len, results;\n        if (destructors = cleanable.upDestructors) {\n          results = [];\n          for (i = 0, len = destructors.length; i < len; i++) {\n            destructor = destructors[i];\n            results.push(destructor());\n          }\n          return results;\n        }\n      });\n    };\n\n    /***\n    Checks if the given element has an [`up-data`](/up-data) attribute.\n    If yes, parses the attribute value as JSON and returns the parsed object.\n    \n    Returns `undefined` if the element has no `up-data` attribute.\n    \n    \\#\\#\\# Example\n    \n    You have an element with JSON data serialized into an `up-data` attribute:\n    \n        <span class='person' up-data='{ \"age\": 18, \"name\": \"Bob\" }'>Bob</span>\n    \n    Calling `up.syntax.data()` will deserialize the JSON string into a JavaScript object:\n    \n        up.syntax.data('.person') // returns { age: 18, name: 'Bob' }\n    \n    @function up.syntax.data\n    @param {string|Element|jQuery} elementOrSelector\n    @return\n      The JSON-decoded value of the `up-data` attribute.\n    \n      Returns `undefined` if the element has no (or an empty) `up-data` attribute.\n    @experimental\n     */\n\n    /***\n    If an element with an `up-data` attribute enters the DOM,\n    Unpoly will parse the JSON and pass the resulting object to any matching\n    [`up.compiler()`](/up.compiler) handlers.\n    \n    For instance, a container for a [Google Map](https://developers.google.com/maps/documentation/javascript/tutorial)\n    might attach the location and names of its marker pins:\n    \n        <div class='google-map' up-data='[\n          { \"lat\": 48.36, \"lng\": 10.99, \"title\": \"Friedberg\" },\n          { \"lat\": 48.75, \"lng\": 11.45, \"title\": \"Ingolstadt\" }\n        ]'></div>\n    \n    The JSON will parsed and handed to your compiler as a second argument:\n    \n        up.compiler('.google-map', function($element, pins) {\n    \n          var map = new google.maps.Map($element);\n    \n          pins.forEach(function(pin) {\n            var position = new google.maps.LatLng(pin.lat, pin.lng);\n            new google.maps.Marker({\n              position: position,\n              map: map,\n              title: pin.title\n            });\n          });\n    \n        });\n    \n    Similarly, when an event is triggered on an element annotated with\n    [`up-data`], the parsed object will be passed to any matching\n    [`up.on()`](/up.on) handlers.\n    \n        up.on('click', '.google-map', function(event, $element, pins) {\n          console.log(\"There are %d pins on the clicked map\", pins.length);\n        });\n    \n    @selector [up-data]\n    @param {JSON} up-data\n      A serialized JSON string\n    @stable\n     */\n    readData = function(elementOrSelector) {\n      var element;\n      if (element = u.element(elementOrSelector)) {\n        return u.jsonAttr(element, 'up-data') || {};\n      }\n    };\n\n    /***\n    Resets the list of registered compiler directives to the\n    moment when the framework was booted.\n    \n    @internal\n     */\n    reset = function() {\n      compilers = u.select(compilers, 'isSystem');\n      return macros = u.select(macros, 'isSystem');\n    };\n    up.on('up:framework:booted', function() {\n      return isBooting = false;\n    });\n    up.on('up:framework:reset', reset);\n    return {\n      compiler: registerCompiler,\n      macro: registerMacro,\n      destructor: registerDestructor,\n      compile: compile,\n      clean: clean,\n      data: readData\n    };\n  })(jQuery);\n\n  up.compiler = up.syntax.compiler;\n\n  up.destructor = up.syntax.destructor;\n\n  up.macro = up.syntax.macro;\n\n}).call(this);\n\n/***\nHistory\n========\n\nIn an Unpoly app, every page has an URL.\n\n[Fragment updates](/up.link) automatically update the URL.\n\n@class up.history\n */\n\n(function() {\n  up.history = (function($) {\n    var buildState, config, currentUrl, isCurrentUrl, manipulate, nextPreviousUrl, normalizeUrl, observeNewUrl, pop, previousUrl, push, register, replace, reset, restoreStateOnPop, u;\n    u = up.util;\n\n    /***\n    Configures behavior when the user goes back or forward in browser history.\n    \n    @property up.history.config\n    @param {Array} [config.popTargets=['body']]\n      An array of CSS selectors to replace when the user goes\n      back in history.\n    @param {boolean} [config.restoreScroll=true]\n      Whether to restore the known scroll positions\n      when the user goes back or forward in history.\n    @stable\n     */\n    config = u.config({\n      enabled: true,\n      popTargets: ['body'],\n      restoreScroll: true\n    });\n\n    /***\n    Returns the previous URL in the browser history.\n    \n    Note that this will only work reliably for history changes that\n    were applied by [`up.history.push()`](/up.history.replace) or\n    [`up.history.replace()`](/up.history.replace).\n    \n    @function up.history.previousUrl\n    @internal\n     */\n    previousUrl = void 0;\n    nextPreviousUrl = void 0;\n    reset = function() {\n      config.reset();\n      previousUrl = void 0;\n      return nextPreviousUrl = void 0;\n    };\n    normalizeUrl = function(url, normalizeOptions) {\n      normalizeOptions || (normalizeOptions = {});\n      normalizeOptions.hash = true;\n      return u.normalizeUrl(url, normalizeOptions);\n    };\n\n    /***\n    Returns a normalized URL for the current history entry.\n    \n    @function up.history.url\n    @experimental\n     */\n    currentUrl = function(normalizeOptions) {\n      return normalizeUrl(up.browser.url(), normalizeOptions);\n    };\n    isCurrentUrl = function(url) {\n      var normalizeOptions;\n      normalizeOptions = {\n        stripTrailingSlash: true\n      };\n      return normalizeUrl(url, normalizeOptions) === currentUrl(normalizeOptions);\n    };\n\n    /***\n    Remembers the given URL so we can offer `up.history.previousUrl()`.\n    \n    @function observeNewUrl\n    @internal\n     */\n    observeNewUrl = function(url) {\n      if (nextPreviousUrl) {\n        previousUrl = nextPreviousUrl;\n        nextPreviousUrl = void 0;\n      }\n      return nextPreviousUrl = url;\n    };\n\n    /***\n    Replaces the current history entry and updates the\n    browser's location bar with the given URL.\n    \n    When the user navigates to the replaced history entry at a later time,\n    Unpoly will [`replace`](/up.replace) the document body with\n    the body from that URL.\n    \n    Note that functions like [`up.replace()`](/up.replace) or\n    [`up.submit()`](/up.submit) will automatically update the\n    browser's location bar for you.\n    \n    @function up.history.replace\n    @param {string} url\n    @internal\n     */\n    replace = function(url) {\n      if (manipulate('replaceState', url)) {\n        return up.emit('up:history:replaced', {\n          url: url\n        });\n      }\n    };\n\n    /***\n    Adds a new history entry and updates the browser's\n    address bar with the given URL.\n    \n    When the user navigates to the added  history entry at a later time,\n    Unpoly will [`replace`](/up.replace) the document body with\n    the body from that URL.\n    \n    Note that functions like [`up.replace()`](/up.replace) or\n    [`up.submit()`](/up.submit) will automatically update the\n    browser's location bar for you.\n    \n    Emits events [`up:history:push`](/up:history:push) and [`up:history:pushed`](/up:history:pushed).\n    \n    @function up.history.push\n    @param {string} url\n      The URL for the history entry to be added.\n    @experimental\n     */\n    push = function(url, options) {\n      options = u.options(options, {\n        force: false\n      });\n      url = normalizeUrl(url);\n      if ((options.force || !isCurrentUrl(url)) && up.bus.nobodyPrevents('up:history:push', {\n        url: url,\n        message: \"Adding history entry for \" + url\n      })) {\n        if (manipulate('pushState', url)) {\n          return up.emit('up:history:pushed', {\n            url: url,\n            message: \"Advanced to location \" + url\n          });\n        } else {\n          return up.emit('up:history:muted', {\n            url: url,\n            message: \"Did not advance to \" + url + \" (history is unavailable)\"\n          });\n        }\n      }\n    };\n\n    /***\n    This event is [emitted](/up.emit) before a new history entry is added.\n    \n    @event up:history:push\n    @param {string} event.url\n      The URL for the history entry that is going to be added.\n    @param event.preventDefault()\n      Event listeners may call this method to prevent the history entry from being added.\n    @experimental\n     */\n\n    /***\n    This event is [emitted](/up.emit) after a new history entry has been added.\n    \n    @event up:history:pushed\n    @param {string} event.url\n      The URL for the history entry that has been added.\n    @experimental\n     */\n    manipulate = function(method, url) {\n      var state;\n      if (up.browser.canPushState() && config.enabled) {\n        state = buildState();\n        window.history[method](state, '', url);\n        observeNewUrl(currentUrl());\n        return true;\n      } else {\n        return false;\n      }\n    };\n    buildState = function() {\n      return {\n        fromUp: true\n      };\n    };\n    restoreStateOnPop = function(state) {\n      var popSelector, replaced, url;\n      if (state != null ? state.fromUp : void 0) {\n        url = currentUrl();\n        up.emit('up:history:restore', {\n          url: url,\n          message: \"Restoring location \" + url\n        });\n        popSelector = config.popTargets.join(', ');\n        replaced = up.replace(popSelector, url, {\n          history: false,\n          title: true,\n          reveal: false,\n          transition: 'none',\n          saveScroll: false,\n          restoreScroll: config.restoreScroll,\n          layer: 'page'\n        });\n        return replaced.then(function() {\n          url = currentUrl();\n          return up.emit('up:history:restored', {\n            url: url,\n            message: \"Restored location \" + url\n          });\n        });\n      } else {\n        return up.puts('Ignoring a state not pushed by Unpoly (%o)', state);\n      }\n    };\n    pop = function(event) {\n      var state;\n      observeNewUrl(currentUrl());\n      up.layout.saveScroll({\n        url: previousUrl\n      });\n      state = event.originalEvent.state;\n      return restoreStateOnPop(state);\n    };\n\n    /***\n    This event is [emitted](/up.emit) before a history entry will be restored.\n    \n    History entries are restored when the user uses the *Back* or *Forward* button.\n    \n    @event up:history:restore\n    @param {string} event.url\n      The URL for the history entry that has been restored.\n    @internal\n     */\n\n    /***\n    This event is [emitted](/up.emit) after a history entry has been restored.\n    \n    History entries are restored when the user uses the *Back* or *Forward* button.\n    \n    @event up:history:restored\n    @param {string} event.url\n      The URL for the history entry that has been restored.\n    @experimental\n     */\n    if (up.browser.canPushState()) {\n      register = function() {\n        $(window).on(\"popstate\", pop);\n        return replace(currentUrl(), {\n          force: true\n        });\n      };\n      if (typeof jasmine !== \"undefined\" && jasmine !== null) {\n        register();\n      } else {\n        setTimeout(register, 100);\n      }\n    }\n\n    /***\n    Changes the link's destination so it points to the previous URL.\n    \n    Note that this will *not* call `location.back()`, but will set\n    the link's `up-href` attribute to the actual, previous URL.\n    \n    If no previous URL is known, the link will not be changed.\n    \n    \\#\\#\\# Example\n    \n    This link ...\n    \n        <a href=\"/default\" up-back>\n          Go back\n        </a>\n    \n    ... will be transformed to:\n    \n        <a href=\"/default\" up-href=\"/previous-page\" up-restore-scroll up-follow>\n          Go back\n        </a>\n    \n    @selector a[up-back]\n    @stable\n     */\n    up.macro('a[up-back], [up-href][up-back]', function($link) {\n      if (u.isPresent(previousUrl)) {\n        u.setMissingAttrs($link, {\n          'up-href': previousUrl,\n          'up-restore-scroll': ''\n        });\n        $link.removeAttr('up-back');\n        return up.link.makeFollowable($link);\n      }\n    });\n    up.on('up:framework:reset', reset);\n    return {\n      config: config,\n      push: push,\n      replace: replace,\n      url: currentUrl,\n      isUrl: isCurrentUrl,\n      previousUrl: function() {\n        return previousUrl;\n      },\n      normalizeUrl: normalizeUrl\n    };\n  })(jQuery);\n\n}).call(this);\n\n/***\nApplication layout\n==================\n\nYou can [make Unpoly aware](/up.layout.config) of fixed elements in your\nlayout, such as navigation bars or headers. Unpoly will respect these sticky\nelements when [revealing elements](/up.reveal) or [opening a modal dialog](/a-up-modal).\n\nThis modules also contains functions to programmatically [scroll a viewport](/up.scroll)\nor [reveal an element within its viewport](/up.reveal).\n\nBootstrap integration\n---------------------\n\nWhen using Bootstrap integration (`unpoly-bootstrap3.js` and `unpoly-bootstrap3.css`)\nUnpoly will automatically be aware of sticky Bootstrap components such as\n[fixed navbar](https://getbootstrap.com/examples/navbar-fixed-top/).\n\n@class up.layout\n */\n\n(function() {\n  var slice = [].slice;\n\n  up.layout = (function($) {\n    var absolutize, anchoredRight, config, finishScrolling, firstHashTarget, fixedChildren, lastScrollTops, measureObstruction, pureHash, reset, restoreScroll, reveal, revealHash, saveScroll, scroll, scrollAbruptlyNow, scrollAfterInsertFragment, scrollTopKey, scrollTops, scrollWithAnimateNow, scrollingTracker, u, viewportOf, viewportSelector, viewports, viewportsWithin;\n    u = up.util;\n\n    /***\n    Configures the application layout.\n    \n    @property up.layout.config\n    @param {Array} [config.viewports]\n      An array of CSS selectors that find viewports\n      (containers that scroll their contents).\n    @param {Array} [config.fixedTop]\n      An array of CSS selectors that find elements fixed to the\n      top edge of the screen (using `position: fixed`).\n      See [`[up-fixed=\"top\"]`](/up-fixed-top) for details.\n    @param {Array} [config.fixedBottom]\n      An array of CSS selectors that find elements fixed to the\n      bottom edge of the screen (using `position: fixed`).\n      See [`[up-fixed=\"bottom\"]`](/up-fixed-bottom) for details.\n    @param {Array} [config.anchoredRight]\n      An array of CSS selectors that find elements anchored to the\n      right edge of the screen (using `right:0` with `position: fixed` or `position: absolute`).\n      See [`[up-anchored=\"right\"]`](/up-anchored-right) for details.\n    @param {number} [config.duration=0]\n      The duration of the scrolling animation in milliseconds.\n      Setting this to `0` will disable scrolling animations.\n    @param {string} [config.easing='swing']\n      The timing function that controls the animation's acceleration.\n      See [W3C documentation](http://www.w3.org/TR/css3-transitions/#transition-timing-function)\n      for a list of pre-defined timing functions.\n    @param {number} [config.snap=50]\n      When [revealing](/up.reveal) elements, Unpoly will scroll an viewport\n      to the top when the revealed element is closer to the top than `config.snap`.\n    @param {number} [config.substance=150]\n      A number indicating how many top pixel rows of an element to [reveal](/up.reveal).\n    @stable\n     */\n    config = u.config({\n      duration: 0,\n      viewports: ['.up-modal-viewport', '[up-viewport]'],\n      fixedTop: ['[up-fixed~=top]'],\n      fixedBottom: ['[up-fixed~=bottom]'],\n      anchoredRight: ['[up-anchored~=right]', '[up-fixed~=top]', '[up-fixed~=bottom]', '[up-fixed~=right]'],\n      snap: 50,\n      substance: 150,\n      easing: 'swing'\n    });\n    lastScrollTops = new up.Cache({\n      size: 30,\n      key: up.history.normalizeUrl\n    });\n    scrollingTracker = new up.MotionTracker('scrolling');\n    reset = function() {\n      config.reset();\n      lastScrollTops.clear();\n      return scrollingTracker.reset();\n    };\n\n    /***\n    Scrolls the given viewport to the given Y-position.\n    \n    A \"viewport\" is an element that has scrollbars, e.g. `<body>` or\n    a container with `overflow-x: scroll`.\n    \n    \\#\\#\\# Example\n    \n    This will scroll a `<div class=\"main\">...</div>` to a Y-position of 100 pixels:\n    \n        up.scroll('.main', 100);\n    \n    \\#\\#\\# Animating the scrolling motion\n    \n    The scrolling can (optionally) be animated.\n    \n        up.scroll('.main', 100, {\n          easing: 'swing',\n          duration: 250\n        });\n    \n    If the given viewport is already in a scroll animation when `up.scroll()`\n    is called a second time, the previous animation will instantly jump to the\n    last frame before the next animation is started.\n    \n    @function up.scroll\n    @param {string|Element|jQuery} viewport\n      The container element to scroll.\n    @param {number} scrollPos\n      The absolute number of pixels to set the scroll position to.\n    @param {number}[options.duration]\n      The number of miliseconds for the scrolling's animation.\n    @param {string}[options.easing]\n      The timing function that controls the acceleration for the scrolling's animation.\n    @return {Promise}\n      A promise that will be fulfilled when the scrolling ends.\n    @experimental\n     */\n    scroll = function(viewport, scrollTop, options) {\n      var $viewport;\n      $viewport = $(viewport);\n      options = u.options(options);\n      options.duration = u.option(options.duration, config.duration);\n      options.easing = u.option(options.easing, config.easing);\n      return finishScrolling($viewport).then(function() {\n        if (up.motion.isEnabled() && options.duration > 0) {\n          return scrollWithAnimateNow($viewport, scrollTop, options);\n        } else {\n          return scrollAbruptlyNow($viewport, scrollTop);\n        }\n      });\n    };\n    scrollWithAnimateNow = function($scrollable, scrollTop, animateOptions) {\n      var start;\n      start = function() {\n        var finish, scrollDone;\n        finish = function() {\n          return $scrollable.finish();\n        };\n        $scrollable.on(scrollingTracker.eventName, finish);\n        scrollDone = $scrollable.animate({\n          scrollTop: scrollTop\n        }, animateOptions).promise();\n        scrollDone.then(function() {\n          return $scrollable.off(scrollingTracker.eventName);\n        });\n        return scrollDone;\n      };\n      return scrollingTracker.claim($scrollable, start);\n    };\n    scrollAbruptlyNow = function($scrollable, scrollTop) {\n      $scrollable.scrollTop(scrollTop);\n      return Promise.resolve();\n    };\n\n    /***\n    Finishes scrolling animations in the given element, its ancestors or its descendants.\n    \n    @function up.layout.finishScrolling\n    @param {string|Element|jQuery}\n    @return {Promise}\n    @internal\n     */\n    finishScrolling = function(element) {\n      var $scrollable;\n      if (!up.motion.isEnabled()) {\n        return Promise.resolve();\n      }\n      $scrollable = viewportOf(element);\n      return scrollingTracker.finish($scrollable);\n    };\n\n    /***\n    @function up.layout.anchoredRight\n    @internal\n     */\n    anchoredRight = function() {\n      var selector;\n      selector = config.anchoredRight.join(',');\n      return $(selector);\n    };\n\n    /***\n    @function measureObstruction\n    @return {Object}\n    @internal\n     */\n    measureObstruction = function(viewportHeight) {\n      var $bottomObstructors, $topObstructors, bottomObstructions, composeHeight, measureBottomObstructor, measureTopObstructor, topObstructions;\n      composeHeight = function(obstructor, distanceFromEdgeProps) {\n        var distanceFromEdge;\n        distanceFromEdge = u.sum(distanceFromEdgeProps, function(prop) {\n          return u.readComputedStyleNumber(obstructor, prop);\n        }) || 0;\n        return distanceFromEdge + obstructor.offsetHeight;\n      };\n      measureTopObstructor = function(obstructor) {\n        return composeHeight(obstructor, ['top', 'margin-top']);\n      };\n      measureBottomObstructor = function(obstructor) {\n        return composeHeight(obstructor, ['bottom', 'margin-bottom']);\n      };\n      $topObstructors = $(config.fixedTop.join(', '));\n      $bottomObstructors = $(config.fixedBottom.join(', '));\n      topObstructions = u.map($topObstructors, measureTopObstructor);\n      bottomObstructions = u.map($bottomObstructors, measureBottomObstructor);\n      return {\n        top: Math.max.apply(Math, [0].concat(slice.call(topObstructions))),\n        bottom: Math.max.apply(Math, [0].concat(slice.call(bottomObstructions)))\n      };\n    };\n\n    /***\n    Scroll's the given element's viewport so the first rows of the\n    element are visible for the user.\n    \n    By default Unpoly will always reveal an element before\n    updating it with JavaScript functions like [`up.replace()`](/up.replace)\n    or UJS behavior like [`[up-target]`](/a-up-target).\n    \n    \\#\\#\\# How Unpoly finds the viewport\n    \n    The viewport (the container that is going to be scrolled)\n    is the closest parent of the element that is either:\n    \n    - the currently open [modal](/up.modal)\n    - an element with the attribute `[up-viewport]`\n    - the `<body>` element\n    - an element matching the selector you have configured using `up.layout.config.viewports.push('my-custom-selector')`\n    \n    \\#\\#\\# Fixed elements obstruction the viewport\n    \n    Many applications have a navigation bar fixed to the top or bottom,\n    obstructing the view on an element.\n    \n    You can make `up.reveal()` aware of these fixed elements\n    so it can scroll the viewport far enough so the revealed element is fully visible.\n    To make `up.reveal()` aware fixed elements you can either:\n    \n    - give the element an attribute [`up-fixed=\"top\"`](/up-fixed-top) or [`up-fixed=\"bottom\"`](up-fixed-bottom)\n    - [configure default options](/up.layout.config) for `fixedTop` or `fixedBottom`\n    \n    @function up.reveal\n    @param {string|Element|jQuery} element\n    @param {number} [options.duration]\n    @param {string} [options.easing]\n    @param {string} [options.snap]\n    @param {string|Element|jQuery} [options.viewport]\n    @param {boolean} [options.top=false]\n      Whether to scroll the viewport so that the first element row aligns\n      with the top edge of the viewport.\n    @return {Promise}\n      A promise that fulfills when the element is revealed.\n    @stable\n     */\n    reveal = function(elementOrSelector, options) {\n      var $element;\n      $element = $(elementOrSelector).first();\n      up.puts('Revealing fragment %o', $element.get(0));\n      options = u.options(options);\n      return u.rejectOnError(function() {\n        var $viewport, elementDims, firstElementRow, lastElementRow, newScrollPos, obstruction, offsetShift, originalScrollPos, predictFirstVisibleRow, predictLastVisibleRow, snap, viewportHeight, viewportIsDocument;\n        $viewport = options.viewport ? $(options.viewport) : viewportOf($element);\n        snap = u.option(options.snap, config.snap);\n        viewportIsDocument = $viewport.is(up.browser.documentViewportSelector());\n        viewportHeight = viewportIsDocument ? u.clientSize().height : $viewport.outerHeight();\n        originalScrollPos = $viewport.scrollTop();\n        newScrollPos = originalScrollPos;\n        offsetShift = void 0;\n        obstruction = void 0;\n        if (viewportIsDocument) {\n          obstruction = measureObstruction(viewportHeight);\n          offsetShift = 0;\n        } else {\n          obstruction = {\n            top: 0,\n            bottom: 0\n          };\n          offsetShift = originalScrollPos;\n        }\n        predictFirstVisibleRow = function() {\n          return newScrollPos + obstruction.top;\n        };\n        predictLastVisibleRow = function() {\n          return newScrollPos + viewportHeight - obstruction.bottom;\n        };\n        elementDims = u.measure($element, {\n          relative: $viewport,\n          includeMargin: true\n        });\n        firstElementRow = elementDims.top + offsetShift;\n        lastElementRow = firstElementRow + Math.min(elementDims.height, config.substance);\n        if (lastElementRow > predictLastVisibleRow()) {\n          newScrollPos += lastElementRow - predictLastVisibleRow();\n        }\n        if (firstElementRow < predictFirstVisibleRow() || options.top) {\n          newScrollPos = firstElementRow - obstruction.top;\n        }\n        if (newScrollPos < snap && elementDims.top < (0.5 * viewportHeight)) {\n          newScrollPos = 0;\n        }\n        if (newScrollPos !== originalScrollPos) {\n          return scroll($viewport, newScrollPos, options);\n        } else {\n          return Promise.resolve();\n        }\n      });\n    };\n\n    /***\n    @function up.layout.scrollAfterInsertFragment\n    @param {boolean|object} [options.restoreScroll]\n    @param {boolean|string|jQuery|Element} [options.reveal]\n    @param {boolean|string} [options.reveal]\n    @return {Promise}\n      A promise that is fulfilled when the scrolling has finished.\n    @internal\n     */\n    scrollAfterInsertFragment = function(selectorOrElement, options) {\n      var $element, durationOptions, givenTops, hashOpt, restoreScrollOpt, revealOpt, selector;\n      options = u.options(options);\n      $element = $(selectorOrElement);\n      hashOpt = options.hash;\n      revealOpt = options.reveal;\n      restoreScrollOpt = options.restoreScroll;\n      durationOptions = u.only(options, 'duration');\n      if (restoreScrollOpt) {\n        givenTops = u.presence(restoreScrollOpt, u.isObject);\n        return restoreScroll({\n          around: $element,\n          scrollTops: givenTops\n        });\n      } else if (hashOpt && revealOpt === true) {\n        return revealHash(hashOpt, durationOptions);\n      } else if (revealOpt) {\n        if (u.isElement(revealOpt) || u.isJQuery(revealOpt)) {\n          $element = $(revealOpt);\n        } else if (u.isString(revealOpt)) {\n          selector = up.dom.resolveSelector(revealOpt, options.origin);\n          $element = up.first(selector);\n        } else {\n\n        }\n        if ($element.length) {\n          return reveal($element, durationOptions);\n        }\n      } else {\n        return Promise.resolve();\n      }\n    };\n\n    /***\n    [Reveals](/up.reveal) an element matching the given `#hash` anchor.\n    \n    Other than the default behavior found in browsers, `up.revealHash` works with\n    [multiple viewports](/up-viewport) and honors [fixed elements](/up-fixed-top) obstructing the user's\n    view of the viewport.\n    \n    When the page loads initially, this function is automatically called with the hash from\n    the current URL.\n    \n    If no element matches the given `#hash` anchor, a resolved promise is returned.\n    \n    @function up.layout.revealHash\n    @return {Promise}\n      A promise that is fulfilled when scroll position has changed to match the location hash.\n    @experimental\n     */\n    revealHash = function(hash) {\n      var $match;\n      if (hash && ($match = firstHashTarget(hash))) {\n        return reveal($match, {\n          top: true\n        });\n      } else {\n        return Promise.resolve();\n      }\n    };\n    viewportSelector = function() {\n      return [up.browser.documentViewportSelector()].concat(slice.call(config.viewports)).join(',');\n    };\n\n    /***\n    Returns the viewport for the given element.\n    \n    Returns the [document's scrolling element](https://developer.mozilla.org/en-US/docs/Web/API/Document/scrollingElement)\n    if no closer viewpoint exists.\n    \n    @function up.layout.viewportOf\n    @param {string|Element|jQuery} selectorOrElement\n    @return {jQuery}\n    @internal\n     */\n    viewportOf = function(selectorOrElement, options) {\n      var $element;\n      if (options == null) {\n        options = {};\n      }\n      $element = $(selectorOrElement);\n      return $element.closest(viewportSelector());\n    };\n\n    /***\n    Returns a jQuery collection of all the viewports contained within the\n    given selector or element.\n    \n    @function up.layout.viewportsWithin\n    @param {string|Element|jQuery} selectorOrElement\n    @return jQuery\n    @internal\n     */\n    viewportsWithin = function(selectorOrElement) {\n      var $element;\n      $element = $(selectorOrElement);\n      return u.selectInSubtree($element, viewportSelector());\n    };\n\n    /***\n    Returns a jQuery collection of all the viewports on the screen.\n    \n    @function up.layout.viewports\n    @internal\n     */\n    viewports = function() {\n      return $(viewportSelector());\n    };\n    scrollTopKey = function(viewport) {\n      return u.selectorForElement(viewport);\n    };\n\n    /***\n    Returns a hash with scroll positions.\n    \n    Each key in the hash is a viewport selector. The corresponding\n    value is the viewport's top scroll position:\n    \n        up.layout.scrollTops()\n        => { '.main': 0, '.sidebar': 73 }\n    \n    @function up.layout.scrollTops\n    @return Object<string, number>\n    @internal\n     */\n    scrollTops = function() {\n      var group, i, len, ref, topsBySelector;\n      topsBySelector = {};\n      ref = config.viewports;\n      for (i = 0, len = ref.length; i < len; i++) {\n        group = ref[i];\n        $(group).each(function() {\n          var $viewport, key, top;\n          $viewport = $(this);\n          key = scrollTopKey($viewport);\n          top = $viewport.scrollTop();\n          return topsBySelector[key] = top;\n        });\n      }\n      return topsBySelector;\n    };\n\n    /***\n    @function up.layout.fixedChildren\n    @internal\n     */\n    fixedChildren = function(root) {\n      var $elements, $root;\n      if (root == null) {\n        root = void 0;\n      }\n      root || (root = document.body);\n      $root = $(root);\n      $elements = $root.find('[up-fixed]');\n      if (u.isPresent(config.fixedTop)) {\n        $elements = $elements.add($root.find(config.fixedTop.join(', ')));\n      }\n      if (u.isPresent(config.fixedBottom)) {\n        $elements = $elements.add($root.find(config.fixedBottom.join(', ')));\n      }\n      return $elements;\n    };\n\n    /***\n    Saves the top scroll positions of all the\n    viewports configured in [`up.layout.config.viewports`](/up.layout.config).\n    \n    The scroll positions will be associated with the current URL.\n    They can later be restored by calling [`up.layout.restoreScroll()`](/up.layout.restoreScroll)\n    at the same URL.\n    \n    Unpoly automatically saves scroll positions whenever a fragment was updated on the page.\n    \n    @function up.layout.saveScroll\n    @param {string} [options.url]\n    @param {Object<string, number>} [options.tops]\n    @experimental\n     */\n    saveScroll = function(options) {\n      var tops, url;\n      if (options == null) {\n        options = {};\n      }\n      url = u.option(options.url, up.history.url());\n      tops = u.option(options.tops, scrollTops());\n      return lastScrollTops.set(url, tops);\n    };\n\n    /***\n    Restores [previously saved](/up.layout.saveScroll) scroll positions of viewports\n    viewports configured in [`up.layout.config.viewports`](/up.layout.config).\n    \n    Unpoly automatically restores scroll positions when the user presses the back button.\n    You can disable this behavior by setting [`up.history.config.restoreScroll = false`](/up.history.config).\n    \n    @function up.layout.restoreScroll\n    @param {jQuery} [options.around]\n      If set, only restores viewports that are either an ancestor\n      or descendant of the given element.\n    @return {Promise}\n      A promise that will be fulfilled once scroll positions have been restored.\n    @experimental\n     */\n    restoreScroll = function(options) {\n      var $ancestorViewports, $descendantViewports, $viewports, scrollTopsForUrl, url;\n      if (options == null) {\n        options = {};\n      }\n      url = up.history.url();\n      $viewports = void 0;\n      if (options.around) {\n        $descendantViewports = viewportsWithin(options.around);\n        $ancestorViewports = viewportOf(options.around);\n        $viewports = $ancestorViewports.add($descendantViewports);\n      } else {\n        $viewports = viewports();\n      }\n      scrollTopsForUrl = options.scrollTops || lastScrollTops.get(url) || {};\n      return up.log.group('Restoring scroll positions for URL %s to %o', url, scrollTopsForUrl, function() {\n        var allScrollPromises;\n        allScrollPromises = u.map($viewports, function(viewport) {\n          var key, scrollTop;\n          key = scrollTopKey(viewport);\n          scrollTop = scrollTopsForUrl[key] || 0;\n          return scroll(viewport, scrollTop, {\n            duration: 0\n          });\n        });\n        return Promise.all(allScrollPromises);\n      });\n    };\n\n    /***\n    @internal\n     */\n    absolutize = function($element, options) {\n      var $bounds, $fixedElements, $viewport, boundsStyle, fixedElement, i, len, moveTop, originalDims, originalOffset, top;\n      options = u.options(options, {\n        afterMeasure: u.noop\n      });\n      $viewport = up.layout.viewportOf($element);\n      originalDims = u.measure($element, {\n        relative: true,\n        inner: true\n      });\n      originalOffset = $element.offset();\n      options.afterMeasure();\n      u.writeInlineStyle($element, {\n        position: u.readComputedStyle($element, 'position') === 'static' ? 'static' : 'relative',\n        top: 'auto',\n        right: 'auto',\n        bottom: 'auto',\n        left: 'auto',\n        width: '100%',\n        height: '100%'\n      });\n      $bounds = $('<div class=\"up-bounds\"></div>');\n      boundsStyle = u.merge(originalDims, {\n        position: 'absolute'\n      });\n      u.writeInlineStyle($bounds, boundsStyle);\n      $bounds.insertBefore($element);\n      $element.appendTo($bounds);\n      top = originalDims.top;\n      moveTop = function(diff) {\n        if (diff !== 0) {\n          top += diff;\n          return u.writeInlineStyle($bounds, {\n            top: top\n          });\n        }\n      };\n      moveTop(originalOffset.top - $element.offset().top);\n      $fixedElements = up.layout.fixedChildren($element);\n      for (i = 0, len = $fixedElements.length; i < len; i++) {\n        fixedElement = $fixedElements[i];\n        u.fixedToAbsolute(fixedElement, $viewport);\n      }\n      return {\n        $element: $element,\n        $bounds: $bounds,\n        moveTop: moveTop\n      };\n    };\n\n    /***\n    Marks this element as a scrolling container (\"viewport\").\n    \n    Apply this attribute if your app uses a custom panel layout with fixed positioning\n    instead of scrolling `<body>`. As an alternative you can also push a selector\n    matching your custom viewport to the [`up.layout.config.viewports`](/up.layout.config) array.\n    \n    [`up.reveal()`](/up.reveal) will always try to scroll the viewport closest\n    to the element that is being revealed. By default this is the `<body>` element.\n    \n    \\#\\#\\# Example\n    \n    Here is an example for a layout for an e-mail client, showing a list of e-mails\n    on the left side and the e-mail text on the right side:\n    \n        .side {\n          position: fixed;\n          top: 0;\n          bottom: 0;\n          left: 0;\n          width: 100px;\n          overflow-y: scroll;\n        }\n    \n        .main {\n          position: fixed;\n          top: 0;\n          bottom: 0;\n          left: 100px;\n          right: 0;\n          overflow-y: scroll;\n        }\n    \n    This would be the HTML (notice the `up-viewport` attribute):\n    \n        <div class=\".side\" up-viewport>\n          <a href=\"/emails/5001\" up-target=\".main\">Re: Your invoice</a>\n          <a href=\"/emails/2023\" up-target=\".main\">Quote for services</a>\n          <a href=\"/emails/9002\" up-target=\".main\">Fwd: Room reservation</a>\n        </div>\n    \n        <div class=\"main\" up-viewport>\n          <h1>Re: Your Invoice</h1>\n          <p>\n            Lorem ipsum dolor sit amet, consetetur sadipscing elitr.\n            Stet clita kasd gubergren, no sea takimata sanctus est.\n          </p>\n        </div>\n    \n    @selector [up-viewport]\n    @stable\n     */\n\n    /***\n    Marks this element as being fixed to the top edge of the screen\n    using `position: fixed`.\n    \n    When [following a fragment link](/a-up-target), the viewport is scrolled\n    so the targeted element becomes visible. By using this attribute you can make\n    Unpoly aware of fixed elements that are obstructing the viewport contents.\n    Unpoly will then scroll the viewport far enough that the revealed element is fully visible.\n    \n    Instead of using this attribute,\n    you can also configure a selector in [`up.layout.config.fixedTop`](/up.layout.config#config.fixedTop).\n    \n    \\#\\#\\# Example\n    \n        <div class=\"top-nav\" up-fixed=\"top\">...</div>\n    \n    @selector [up-fixed=top]\n    @stable\n     */\n\n    /***\n    Marks this element as being fixed to the bottom edge of the screen\n    using `position: fixed`.\n    \n    When [following a fragment link](/a-up-target), the viewport is scrolled\n    so the targeted element becomes visible. By using this attribute you can make\n    Unpoly aware of fixed elements that are obstructing the viewport contents.\n    Unpoly will then scroll the viewport far enough that the revealed element is fully visible.\n    \n    Instead of using this attribute,\n    you can also configure a selector in [`up.layout.config.fixedBottom`](/up.layout.config#config.fixedBottom).\n    \n    \\#\\#\\# Example\n    \n        <div class=\"bottom-nav\" up-fixed=\"bottom\">...</div>\n    \n    @selector [up-fixed=bottom]\n    @stable\n     */\n\n    /***\n    Marks this element as being anchored to the right edge of the screen,\n    typically fixed navigation bars.\n    \n    Since [modal dialogs](/up.modal) hide the document scroll bar,\n    elements anchored to the right appear to jump when the dialog opens or\n    closes. Applying this attribute to anchored elements will make Unpoly\n    aware of the issue and adjust the `right` property accordingly.\n    \n    You should give this attribute to layout elements\n    with a CSS of `right: 0` with `position: fixed` or `position:absolute`.\n    \n    Instead of giving this attribute to any affected element,\n    you can also configure a selector in [`up.layout.config.anchoredRight`](/up.layout.config#config.anchoredRight).\n    \n    \\#\\#\\# Example\n    \n    Here is the CSS for a navigation bar that is anchored to the top edge of the screen:\n    \n        .top-nav {\n           position: fixed;\n           top: 0;\n           left: 0;\n           right: 0;\n         }\n    \n    By adding an `up-anchored=\"right\"` attribute to the element, we can prevent the\n    `right` edge from jumping when a [modal dialog](/up.modal) opens or closes:\n    \n        <div class=\"top-nav\" up-anchored=\"right\">...</div>\n    \n    @selector [up-anchored=right]\n    @stable\n     */\n\n    /***\n    @function up.layout.firstHashTarget\n    @internal\n     */\n    firstHashTarget = function(hash) {\n      var byID, byName;\n      if (hash = pureHash(hash)) {\n        byID = u.attributeSelector('id', hash);\n        byName = 'a' + u.attributeSelector('name', hash);\n        return up.first(byID + \",\" + byName);\n      }\n    };\n\n    /***\n    Returns `'foo'` if the hash is `'#foo'`.\n    \n    Returns undefined if the hash is `'#'`, `''` or `undefined`.\n    \n    @function up.browser.hash\n    @internal\n     */\n    pureHash = function(value) {\n      if (value && value[0] === '#') {\n        value = value.substr(1);\n      }\n      return u.presence(value);\n    };\n    up.on('up:app:booted', function() {\n      return revealHash(location.hash);\n    });\n    up.on('up:framework:reset', reset);\n    return {\n      reveal: reveal,\n      revealHash: revealHash,\n      firstHashTarget: firstHashTarget,\n      scroll: scroll,\n      config: config,\n      viewportOf: viewportOf,\n      viewportsWithin: viewportsWithin,\n      viewports: viewports,\n      scrollTops: scrollTops,\n      saveScroll: saveScroll,\n      restoreScroll: restoreScroll,\n      scrollAfterInsertFragment: scrollAfterInsertFragment,\n      anchoredRight: anchoredRight,\n      fixedChildren: fixedChildren,\n      absolutize: absolutize\n    };\n  })(jQuery);\n\n  up.scroll = up.layout.scroll;\n\n  up.reveal = up.layout.reveal;\n\n  up.revealHash = up.layout.revealHash;\n\n}).call(this);\n\n/***\nFragment update API\n===================\n  \nThis module exposes a low-level Javascript API to [change](/up.replace) or\n[destroy](/up.destroy) page fragments.\n\nMost of Unpoly's functionality (like [fragment links](/up.link) or [modals](/up.modal))\nis built from these functions. You can use them to extend Unpoly from your\n[custom Javascript](/up.syntax).\n\n@class up.dom\n */\n\n(function() {\n  up.dom = (function($) {\n    var all, bestMatchingSteps, bestPreflightSelector, config, destroy, emitFragmentDestroy, emitFragmentDestroyed, emitFragmentInserted, emitFragmentKept, extract, findKeepPlan, first, firstInLayer, firstInPriority, hello, isRealElement, layerOf, markElementAsDestroying, matchesLayer, processResponse, reload, replace, reset, resolveSelector, setSource, shouldExtractTitle, shouldLogDestruction, source, swapElements, transferKeepableElements, u, updateHistoryAndTitle;\n    u = up.util;\n\n    /***\n    Configures defaults for fragment insertion.\n    \n    @property up.dom.config\n    @param {string} [options.fallbacks=['body']]\n      When a fragment updates cannot find the requested element, Unpoly will try this list of alternative selectors.\n    \n      The first selector that matches an element in the current page (or response) will be used.\n      If the response contains none of the selectors, an error message will be shown.\n    \n      It is recommend to always keep `'body'` as the last selector in the last in the case\n      your server or load balancer renders an error message that does not contain your\n      application layout.\n    @param {string} [options.fallbackTransition=null]\n      The transition to use when using a [fallback target](/#options.fallbacks).\n    \n      By default this is not set and the original replacement's transition is used.\n    @stable\n     */\n    config = u.config({\n      fallbacks: ['body'],\n      fallbackTransition: null\n    });\n    reset = function() {\n      return config.reset();\n    };\n    setSource = function(element, sourceUrl) {\n      var $element;\n      if (sourceUrl !== false) {\n        $element = $(element);\n        if (u.isPresent(sourceUrl)) {\n          sourceUrl = u.normalizeUrl(sourceUrl);\n        }\n        return $element.attr(\"up-source\", sourceUrl);\n      }\n    };\n\n    /***\n    Returns the URL the given element was retrieved from.\n    \n    @method up.dom.source\n    @param {string|Element|jQuery} selectorOrElement\n    @experimental\n     */\n    source = function(selectorOrElement) {\n      var $element;\n      $element = $(selectorOrElement).closest('[up-source]');\n      return u.presence($element.attr(\"up-source\")) || up.browser.url();\n    };\n\n    /***\n    Resolves the given CSS selector (which might contain `&` references)\n    to a full CSS selector without ampersands.\n    \n    If passed an `Element` or `jQuery` element, returns a CSS selector string\n    for that element.\n    \n    @function up.dom.resolveSelector\n    @param {string|Element|jQuery} selectorOrElement\n    @param {string|Element|jQuery} origin\n      The element that this selector resolution is relative to.\n      That element's selector will be substituted for `&` ([like in Sass](https://sass-lang.com/documentation/file.SASS_REFERENCE.html#parent-selector)).\n    @return {string}\n    @internal\n     */\n    resolveSelector = function(selectorOrElement, origin) {\n      var originSelector, selector;\n      if (u.isString(selectorOrElement)) {\n        selector = selectorOrElement;\n        if (u.contains(selector, '&')) {\n          if (u.isPresent(origin)) {\n            originSelector = u.selectorForElement(origin);\n            selector = selector.replace(/\\&/, originSelector);\n          } else {\n            up.fail(\"Found origin reference (%s) in selector %s, but no origin was given\", '&', selector);\n          }\n        }\n      } else {\n        selector = u.selectorForElement(selectorOrElement);\n      }\n      return selector;\n    };\n\n    /***\n    Replaces elements on the current page with corresponding elements\n    from a new page fetched from the server.\n    \n    The current and new elements must both match the given CSS selector.\n    \n    The unobtrusive variant of this is the [`a[up-target]`](/a-up-target) selector.\n    \n    \\#\\#\\# Example\n    \n    Let's say your curent HTML looks like this:\n    \n        <div class=\"one\">old one</div>\n        <div class=\"two\">old two</div>\n    \n    We now replace the second `<div>`:\n    \n        up.replace('.two', '/new');\n    \n    The server renders a response for `/new`:\n    \n        <div class=\"one\">new one</div>\n        <div class=\"two\">new two</div>\n    \n    Unpoly looks for the selector `.two` in the response and [implants](/up.extract) it into\n    the current page. The current page now looks like this:\n    \n        <div class=\"one\">old one</div>\n        <div class=\"two\">new two</div>\n    \n    Note how only `.two` has changed. The update for `.one` was\n    discarded, since it didn't match the selector.\n    \n    \\#\\#\\# Appending or prepending instead of replacing\n    \n    By default Unpoly will replace the given selector with the same\n    selector from a freshly fetched page. Instead of replacing you\n    can *append* the loaded content to the existing content by using the\n    `:after` pseudo selector. In the same fashion, you can use `:before`\n    to indicate that you would like the *prepend* the loaded content.\n    \n    A practical example would be a paginated list of items:\n    \n        <ul class=\"tasks\">\n          <li>Wash car</li>\n          <li>Purchase supplies</li>\n          <li>Fix tent</li>\n        </ul>\n    \n    In order to append more items from a URL, replace into\n    the `.tasks:after` selector:\n    \n        up.replace('.tasks:after', '/page/2')\n    \n    \\#\\#\\# Setting the window title from the server\n    \n    If the `replace` call changes history, the document title will be set\n    to the contents of a `<title>` tag in the response.\n    \n    The server can also change the document title by setting\n    an `X-Up-Title` header in the response.\n    \n    \\#\\#\\# Optimizing response rendering\n    \n    The server is free to optimize Unpoly requests by only rendering the HTML fragment\n    that is being updated. The request's `X-Up-Target` header will contain\n    the CSS selector for the updating fragment.\n    \n    If you are using the `unpoly-rails` gem you can also access the selector via\n    `up.target` in all controllers, views and helpers.\n    \n    \\#\\#\\# Events\n    \n    Unpoly will emit [`up:fragment:destroyed`](/up:fragment:destroyed) on the element\n    that was replaced and [`up:fragment:inserted`](/up:fragment:inserted) on the new\n    element that replaces it.\n    \n    @function up.replace\n    @param {string|Element|jQuery} selectorOrElement\n      The CSS selector to update. You can also pass a DOM element or jQuery element\n      here, in which case a selector will be inferred from the element's class and ID.\n    @param {string} url\n      The URL to fetch from the server.\n    @param {string} [options.failTarget]\n      The CSS selector to update if the server sends a non-200 status code.\n    @param {string} [options.fallback]\n      The selector to update when the original target was not found in the page.\n    @param {string} [options.title]\n      The document title after the replacement.\n    \n      If the call pushes an history entry and this option is missing, the title is extracted from the response's `<title>` tag.\n      You can also pass `false` to explicitly prevent the title from being updated.\n    @param {string} [options.method='get']\n      The HTTP method to use for the request.\n    @param {Object|FormData|string|Array} [options.params]\n      [Parameters](/up.params) that should be sent as the request's payload.\n    @param {string} [options.transition='none']\n    @param {string|boolean} [options.history=true]\n      If a string is given, it is used as the URL the browser's location bar and history.\n      If omitted or true, the `url` argument will be used.\n      If set to `false`, the history will remain unchanged.\n    @param {boolean|string} [options.source=true]\n    @param {boolean|string} [options.reveal=false]\n      Whether to [reveal](/up.reveal) the new fragment.\n    \n      You can also pass a CSS selector for the element to reveal.\n    @param {boolean|string} [options.failReveal=false]\n      Whether to [reveal](/up.reveal) the new fragment when the server responds with an error.\n    \n      You can also pass a CSS selector for the element to reveal.\n    @param {boolean} [options.restoreScroll=false]\n      If set to true, Unpoly will try to restore the scroll position\n      of all the viewports around or below the updated element. The position\n      will be reset to the last known top position before a previous\n      history change for the current URL.\n    @param {boolean} [options.cache]\n      Whether to use a [cached response](/up.proxy) if available.\n    @param {string} [options.historyMethod='push']\n    @param {Object} [options.headers={}]\n      An object of additional header key/value pairs to send along\n      with the request.\n    @param {Element|jQuery} [options.origin]\n      The element that triggered the replacement.\n    \n      The element's selector will be substituted for the `&` shorthand in the target selector ([like in Sass](https://sass-lang.com/documentation/file.SASS_REFERENCE.html#parent-selector)).\n    @param {string} [options.layer='auto']\n      The name of the layer that ought to be updated. Valid values are\n      `'auto'`, `'page'`, `'modal'` and `'popup'`.\n    \n      If set to `'auto'` (default), Unpoly will try to find a match in the\n      same layer as the element that triggered the replacement (see `options.origin`).\n      If that element is not known, or no match was found in that layer,\n      Unpoly will search in other layers, starting from the topmost layer.\n    @param {string} [options.failLayer='auto']\n      The name of the layer that ought to be updated if the server sends a non-200 status code.\n    @param {boolean} [options.keep=true]\n      Whether this replacement will preserve [`[up-keep]`](/up-keep) elements.\n    @param {boolean} [options.hungry=true]\n      Whether this replacement will update [`[up-hungry]`](/up-hungry) elements.\n    \n    @return {Promise}\n      A promise that will be fulfilled when the page has been updated.\n    @stable\n     */\n    replace = function(selectorOrElement, url, options) {\n      var e, failureOptions, fullLoad, improvedFailTarget, improvedTarget, onFailure, onSuccess, promise, request, successOptions;\n      options = u.options(options);\n      options.inspectResponse = fullLoad = function() {\n        return up.browser.navigate(url, u.only(options, 'method', 'params'));\n      };\n      if (!up.browser.canPushState() && options.history !== false) {\n        if (!options.preload) {\n          fullLoad();\n        }\n        return u.unresolvablePromise();\n      }\n      successOptions = u.merge(options, {\n        humanizedTarget: 'target'\n      });\n      failureOptions = u.merge(options, {\n        humanizedTarget: 'failure target',\n        provideTarget: void 0,\n        restoreScroll: false\n      });\n      u.renameKey(failureOptions, 'failTransition', 'transition');\n      u.renameKey(failureOptions, 'failLayer', 'layer');\n      u.renameKey(failureOptions, 'failReveal', 'reveal');\n      try {\n        improvedTarget = bestPreflightSelector(selectorOrElement, successOptions);\n        improvedFailTarget = bestPreflightSelector(options.failTarget, failureOptions);\n      } catch (error) {\n        e = error;\n        return Promise.reject(e);\n      }\n      request = new up.Request({\n        url: url,\n        method: options.method,\n        data: options.data,\n        params: options.params,\n        target: improvedTarget,\n        failTarget: improvedFailTarget,\n        cache: options.cache,\n        preload: options.preload,\n        headers: options.headers,\n        timeout: options.timeout\n      });\n      onSuccess = function(response) {\n        return processResponse(true, improvedTarget, request, response, successOptions);\n      };\n      onFailure = function(response) {\n        var promise, rejection;\n        rejection = function() {\n          return Promise.reject(response);\n        };\n        if (response.isFatalError()) {\n          return rejection();\n        } else {\n          promise = processResponse(false, improvedFailTarget, request, response, failureOptions);\n          return u.always(promise, rejection);\n        }\n      };\n      promise = up.request(request);\n      if (!options.preload) {\n        promise = promise.then(onSuccess, onFailure);\n      }\n      return promise;\n    };\n\n    /***\n    @internal\n     */\n    processResponse = function(isSuccess, selector, request, response, options) {\n      var hash, historyUrl, isReloadable, sourceUrl;\n      sourceUrl = response.url;\n      historyUrl = sourceUrl;\n      if (hash = request.hash) {\n        options.hash = hash;\n        historyUrl += hash;\n      }\n      isReloadable = response.method === 'GET';\n      if (isSuccess) {\n        if (isReloadable) {\n          if (!(options.history === false || u.isString(options.history))) {\n            options.history = historyUrl;\n          }\n          if (!(options.source === false || u.isString(options.source))) {\n            options.source = sourceUrl;\n          }\n        } else {\n          if (!u.isString(options.history)) {\n            options.history = false;\n          }\n          if (!u.isString(options.source)) {\n            options.source = 'keep';\n          }\n        }\n      } else {\n        if (isReloadable) {\n          if (options.history !== false) {\n            options.history = historyUrl;\n          }\n          if (options.source !== false) {\n            options.source = sourceUrl;\n          }\n        } else {\n          options.history = false;\n          options.source = 'keep';\n        }\n      }\n      if (shouldExtractTitle(options) && response.title) {\n        options.title = response.title;\n      }\n      return extract(selector, response.text, options);\n    };\n    shouldExtractTitle = function(options) {\n      return !(options.title === false || u.isString(options.title) || (options.history === false && options.title !== true));\n    };\n\n    /***\n    Updates a selector on the current page with the\n    same selector from the given HTML string.\n    \n    \\#\\#\\# Example\n    \n    Let's say your curent HTML looks like this:\n    \n        <div class=\"one\">old one</div>\n        <div class=\"two\">old two</div>\n    \n    We now replace the second `<div>`, using an HTML string\n    as the source:\n    \n        html = '<div class=\"one\">new one</div>' +\n               '<div class=\"two\">new two</div>';\n    \n        up.extract('.two', html);\n    \n    Unpoly looks for the selector `.two` in the strings and updates its\n    contents in the current page. The current page now looks like this:\n    \n        <div class=\"one\">old one</div>\n        <div class=\"two\">new two</div>\n    \n    Note how only `.two` has changed. The update for `.one` was\n    discarded, since it didn't match the selector.\n    \n    @function up.extract\n    @param {string|Element|jQuery} selectorOrElement\n    @param {string} html\n    @param {Object} [options]\n      See options for [`up.replace()`](/up.replace).\n    @return {Promise}\n      A promise that will be fulfilled then the selector was updated\n      and all animation has finished.\n    @stable\n     */\n    extract = function(selectorOrElement, html, options) {\n      return up.log.group('Extracting %s from %d bytes of HTML', selectorOrElement, html != null ? html.length : void 0, function() {\n        options = u.options(options, {\n          historyMethod: 'push',\n          keep: true,\n          layer: 'auto'\n        });\n        if (options.saveScroll !== false) {\n          up.layout.saveScroll();\n        }\n        return u.rejectOnError(function() {\n          var extractSteps, i, len, responseDoc, responseTitle, step, swapPromises;\n          if (typeof options.provideTarget === \"function\") {\n            options.provideTarget();\n          }\n          responseDoc = new up.HtmlParser(html);\n          extractSteps = bestMatchingSteps(selectorOrElement, responseDoc, options);\n          if (shouldExtractTitle(options) && (responseTitle = responseDoc.title())) {\n            options.title = responseTitle;\n          }\n          updateHistoryAndTitle(options);\n          swapPromises = [];\n          for (i = 0, len = extractSteps.length; i < len; i++) {\n            step = extractSteps[i];\n            up.log.group('Swapping fragment %s', step.selector, function() {\n              var swapOptions, swapPromise;\n              swapOptions = u.merge(options, u.only(step, 'origin', 'reveal'));\n              responseDoc.prepareForInsertion(step.$new);\n              swapPromise = swapElements(step.$old, step.$new, step.pseudoClass, step.transition, swapOptions);\n              return swapPromises.push(swapPromise);\n            });\n          }\n          return Promise.all(swapPromises);\n        });\n      });\n    };\n    bestPreflightSelector = function(selector, options) {\n      var cascade;\n      cascade = new up.ExtractCascade(selector, options);\n      return cascade.bestPreflightSelector();\n    };\n    bestMatchingSteps = function(selector, response, options) {\n      var cascade;\n      options = u.merge(options, {\n        response: response\n      });\n      cascade = new up.ExtractCascade(selector, options);\n      return cascade.bestMatchingSteps();\n    };\n    updateHistoryAndTitle = function(options) {\n      options = u.options(options, {\n        historyMethod: 'push'\n      });\n      if (options.history) {\n        up.history[options.historyMethod](options.history);\n      }\n      if (u.isString(options.title)) {\n        return document.title = options.title;\n      }\n    };\n    swapElements = function($old, $new, pseudoClass, transition, options) {\n      var $parent, $wrapper, keepPlan, morphOptions, promise;\n      transition || (transition = 'none');\n      if (options.source === 'keep') {\n        options = u.merge(options, {\n          source: source($old)\n        });\n      }\n      setSource($new, options.source);\n      if (pseudoClass) {\n        $wrapper = $new.contents().wrapAll('<div class=\"up-insertion\"></div>').parent();\n        if (pseudoClass === 'before') {\n          $old.prepend($wrapper);\n        } else {\n          $old.append($wrapper);\n        }\n        hello($wrapper.children(), options);\n        promise = up.layout.scrollAfterInsertFragment($wrapper, options);\n        promise = promise.then(function() {\n          return up.animate($wrapper, transition, options);\n        });\n        promise = promise.then(function() {\n          return u.unwrapElement($wrapper);\n        });\n        return promise;\n      } else if (keepPlan = findKeepPlan($old, $new, options)) {\n        emitFragmentKept(keepPlan);\n        return Promise.resolve();\n      } else {\n        options.keepPlans = transferKeepableElements($old, $new, options);\n        $parent = $old.parent();\n        morphOptions = u.merge(options, {\n          beforeStart: function() {\n            markElementAsDestroying($old);\n            return emitFragmentDestroy($old, {\n              log: false\n            });\n          },\n          afterInsert: function() {\n            return up.hello($new, options);\n          },\n          beforeDetach: function() {\n            return up.syntax.clean($old);\n          },\n          afterDetach: function() {\n            $old.remove();\n            return emitFragmentDestroyed($old, {\n              $parent: $parent,\n              log: false\n            });\n          }\n        });\n        return up.morph($old, $new, transition, morphOptions);\n      }\n    };\n    transferKeepableElements = function($old, $new, options) {\n      var $keepable, $keepableClone, i, keepPlans, keepable, len, plan, ref;\n      keepPlans = [];\n      if (options.keep) {\n        ref = $old.find('[up-keep]');\n        for (i = 0, len = ref.length; i < len; i++) {\n          keepable = ref[i];\n          $keepable = $(keepable);\n          if (plan = findKeepPlan($keepable, $new, u.merge(options, {\n            descendantsOnly: true\n          }))) {\n            $keepableClone = $keepable.clone();\n            u.detachWith($keepable, $keepableClone);\n            plan.$newElement.replaceWith($keepable);\n            keepPlans.push(plan);\n          }\n        }\n      }\n      return keepPlans;\n    };\n    findKeepPlan = function($element, $new, options) {\n      var $keepable, $partner, keepEventArgs, partnerSelector, plan;\n      if (options.keep) {\n        $keepable = $element;\n        if (partnerSelector = u.castedAttr($keepable, 'up-keep')) {\n          u.isString(partnerSelector) || (partnerSelector = '&');\n          partnerSelector = resolveSelector(partnerSelector, $keepable);\n          if (options.descendantsOnly) {\n            $partner = $new.find(partnerSelector);\n          } else {\n            $partner = u.selectInSubtree($new, partnerSelector);\n          }\n          $partner = $partner.first();\n          if ($partner.length && $partner.is('[up-keep]')) {\n            plan = {\n              $element: $keepable,\n              $newElement: $partner,\n              newData: up.syntax.data($partner)\n            };\n            keepEventArgs = u.merge(plan, {\n              message: ['Keeping element %o', $keepable.get(0)]\n            });\n            if (up.bus.nobodyPrevents('up:fragment:keep', keepEventArgs)) {\n              return plan;\n            }\n          }\n        }\n      }\n    };\n\n    /***\n    Elements with an `up-keep` attribute will be persisted during\n    [fragment updates](/a-up-target).\n    \n    For example:\n    \n        <audio up-keep src=\"song.mp3\"></audio>\n    \n    The element you're keeping should have an umambiguous class name, ID or `up-id`\n    attribute so Unpoly can find its new position within the page update.\n    \n    Emits events [`up:fragment:keep`](/up:fragment:keep) and [`up:fragment:kept`](/up:fragment:kept).\n    \n    \\#\\#\\# Controlling if an element will be kept\n    \n    Unpoly will **only** keep an existing element if:\n    \n    - The existing element has an `up-keep` attribute\n    - The response contains an element matching the CSS selector of the existing element\n    - The matching element *also* has an `up-keep` attribute\n    - The [`up:fragment:keep`](/up:fragment:keep) event that is [emitted](/up.emit) on the existing element\n      is not prevented by a event listener.\n    \n    Let's say we want only keep an `<audio>` element as long as it plays\n    the same song (as identified by the tag's `src` attribute).\n    \n    On the client we can achieve this by listening to an `up:keep:fragment` event\n    and preventing it if the `src` attribute of the old and new element differ:\n    \n        up.compiler('audio', function($element) {\n          $element.on('up:fragment:keep', function(event) {\n            if $element.attr('src') !== event.$newElement.attr('src') {\n              event.preventDefault();\n            }\n          });\n        });\n    \n    If we don't want to solve this on the client, we can achieve the same effect\n    on the server. By setting the value of the `up-keep` attribute we can\n    define the CSS selector used for matching elements.\n    \n        <audio up-keep=\"audio[src='song.mp3']\" src=\"song.mp3\"></audio>\n    \n    Now, if a response no longer contains an `<audio src=\"song.mp3\">` tag, the existing\n    element will be destroyed and replaced by a fragment from the response.\n    \n    @selector [up-keep]\n    @stable\n     */\n\n    /***\n    This event is [emitted](/up.emit) before an existing element is [kept](/up-keep) during\n    a page update.\n    \n    Event listeners can call `event.preventDefault()` on an `up:fragment:keep` event\n    to prevent the element from being persisted. If the event is prevented, the element\n    will be replaced by a fragment from the response.\n    \n    @event up:fragment:keep\n    @param event.preventDefault()\n      Event listeners may call this method to prevent the element from being preserved.\n    @param {jQuery} event.$element\n      The fragment that will be kept.\n    @param {jQuery} event.$newElement\n      The discarded element.\n    @param {Object} event.newData\n      The value of the [`up-data`](/up-data) attribute of the discarded element,\n      parsed as a JSON object.\n    @stable\n     */\n\n    /***\n    This event is [emitted](/up.emit) when an existing element has been [kept](/up-keep)\n    during a page update.\n    \n    Event listeners can inspect the discarded update through `event.$newElement`\n    and `event.newData` and then modify the preserved element when necessary.\n    \n    @event up:fragment:kept\n    @param {jQuery} event.$element\n      The fragment that has been kept.\n    @param {jQuery} event.$newElement\n      The discarded element.\n    @param {Object} event.newData\n      The value of the [`up-data`](/up-data) attribute of the discarded element,\n      parsed as a JSON object.\n    @stable\n     */\n\n    /***\n    Compiles a page fragment that has been inserted into the DOM\n    by external code.\n    \n    **As long as you manipulate the DOM using Unpoly, you will never\n    need to call this method.** You only need to use `up.hello()` if the\n    DOM is manipulated without Unpoly' involvement, e.g. by setting\n    the `innerHTML` property or calling jQuery methods like\n    `html`, `insertAfter` or `appendTo`:\n    \n        $element = $('.element');\n        $element.html('<div>...</div>');\n        up.hello($element);\n    \n    This function emits the [`up:fragment:inserted`](/up:fragment:inserted)\n    event.\n    \n    @function up.hello\n    @param {string|Element|jQuery} selectorOrElement\n    @param {string|Element|jQuery} [options.origin]\n    @param {string|Element|jQuery} [options.kept]\n    @return {jQuery}\n      The compiled element\n    @stable\n     */\n    hello = function(selectorOrElement, options) {\n      var $element, i, keptElements, len, plan, ref;\n      $element = $(selectorOrElement);\n      options = u.options(options, {\n        keepPlans: []\n      });\n      keptElements = [];\n      ref = options.keepPlans;\n      for (i = 0, len = ref.length; i < len; i++) {\n        plan = ref[i];\n        emitFragmentKept(plan);\n        keptElements.push(plan.$element[0]);\n      }\n      up.syntax.compile($element, {\n        skip: keptElements\n      });\n      emitFragmentInserted($element, options);\n      return $element;\n    };\n\n    /***\n    When a page fragment has been [inserted or updated](/up.replace),\n    this event is [emitted](/up.emit) on the fragment.\n    \n    \\#\\#\\# Example\n    \n        up.on('up:fragment:inserted', function(event, $fragment) {\n          console.log(\"Looks like we have a new %o!\", $fragment);\n        });\n    \n    @event up:fragment:inserted\n    @param {jQuery} event.$element\n      The fragment that has been inserted or updated.\n    @stable\n     */\n    emitFragmentInserted = function($element, options) {\n      return up.emit('up:fragment:inserted', {\n        $element: $element,\n        message: ['Inserted fragment %o', $element.get(0)],\n        origin: options.origin\n      });\n    };\n    emitFragmentKept = function(keepPlan) {\n      var eventAttrs;\n      eventAttrs = u.merge(keepPlan, {\n        message: ['Kept fragment %o', keepPlan.$element.get(0)]\n      });\n      return up.emit('up:fragment:kept', eventAttrs);\n    };\n    emitFragmentDestroy = function($element, options) {\n      var message;\n      if (shouldLogDestruction($element, options)) {\n        message = ['Destroying fragment %o', $element.get(0)];\n      }\n      return up.emit('up:fragment:destroy', {\n        $element: $element,\n        message: message\n      });\n    };\n    emitFragmentDestroyed = function($element, options) {\n      var $parent, message;\n      if (shouldLogDestruction($element, options)) {\n        message = ['Destroyed fragment %o', $element.get(0)];\n      }\n      $parent = options.$parent || up.fail(\"Missing { $parent } option\");\n      return up.emit('up:fragment:destroyed', {\n        $target: $parent,\n        $parent: $parent,\n        $element: $element,\n        message: message\n      });\n    };\n    isRealElement = function($element) {\n      var unreal;\n      unreal = '.up-destroying';\n      return $element.closest(unreal).length === 0;\n    };\n\n    /***\n    Returns the first element matching the given selector, but\n    ignores elements that are being [destroyed](/up.destroy) or that are being\n    removed by a [transition](/up.morph).\n    \n    If the given argument is already a jQuery collection (or an array\n    of DOM elements), the first element matching these conditions\n    is returned.\n    \n    Returns `undefined` if no element matches these conditions.\n    \n    Also see the [`.up-destroying`](/up-destroying) class.\n    \n    @function up.first\n    @param {string|Element|jQuery|Array<Element>} selectorOrElement\n    @param {string} [options.layer='auto']\n      The name of the layer in which to find the element.\n    \n      Valid values are `'auto'`, `'page'`, `'modal'` and `'popup'`.\n    @param {string|Element|jQuery} [options.origin]\n      An second element or selector that can be referenced as `&` in the first selector:\n    \n          $input = $('input.email');\n          up.first('.field:has(&)', $input); // returns the .field containing $input\n    @return {jQuery|undefined}\n      The first element that is neither a ghost or being destroyed,\n      or `undefined` if no such element was found.\n    @experimental\n     */\n    first = function(selectorOrElement, options) {\n      var resolved;\n      options = u.options(options, {\n        layer: 'auto'\n      });\n      resolved = resolveSelector(selectorOrElement, options.origin);\n      if (options.layer === 'auto') {\n        return firstInPriority(resolved, options.origin);\n      } else {\n        return firstInLayer(resolved, options.layer);\n      }\n    };\n    firstInPriority = function(selectorOrElement, origin) {\n      var $match, i, layer, layers, len, originLayer;\n      layers = ['popup', 'modal', 'page'];\n      $match = void 0;\n      if (u.isPresent(origin)) {\n        originLayer = layerOf(origin);\n        u.remove(layers, originLayer);\n        layers.unshift(originLayer);\n      }\n      for (i = 0, len = layers.length; i < len; i++) {\n        layer = layers[i];\n        if ($match = firstInLayer(selectorOrElement, layer)) {\n          break;\n        }\n      }\n      return $match;\n    };\n    firstInLayer = function(selectorOrElement, layer) {\n      var $element, $elements, $match, element, i, len;\n      $elements = $(selectorOrElement);\n      $match = void 0;\n      for (i = 0, len = $elements.length; i < len; i++) {\n        element = $elements[i];\n        $element = $(element);\n        if (isRealElement($element) && matchesLayer($element, layer)) {\n          $match = $element;\n          break;\n        }\n      }\n      return $match;\n    };\n\n    /***\n    @function up.dom.layerOf\n    @internal\n     */\n    layerOf = function(selectorOrElement) {\n      var $element;\n      $element = $(selectorOrElement);\n      if ($element.length) {\n        if (up.popup.contains($element)) {\n          return 'popup';\n        } else if (up.modal.contains($element)) {\n          return 'modal';\n        } else {\n          return 'page';\n        }\n      }\n    };\n    matchesLayer = function(selectorOrElement, layer) {\n      return !layer || layerOf(selectorOrElement) === layer;\n    };\n\n    /***\n    Returns all elements matching the given selector, but\n    ignores elements that are being [destroyed](/up.destroy) or [transitioned](/up.morph).\n    \n    If the given argument is already a jQuery collection (or an array\n    of DOM elements), returns the subset of the given list that is matching these conditions.\n    \n    @function up.all\n    @param {string|jQuery|Array<Element>} selectorOrElements\n    @param {string|Element|jQuery} [options.origin]\n      An second element or selector that can be referenced as `&` in the first selector.\n    @param {string} [options.layer]\n      The name of the layer in which to find the element. Valid values are\n      `'page'`, `'modal'` and `'popup'`.\n    @return {jQuery}\n      A jQuery collection of matching elements.\n    @experimental\n     */\n    all = function(selectorOrElements, options) {\n      var $root, resolved;\n      options = u.options(options);\n      resolved = resolveSelector(selectorOrElements, options.origin);\n      $root = $(u.option(options.root, document));\n      return $root.find(resolved).filter(function(index, element) {\n        var $element;\n        $element = $(element);\n        return isRealElement($element) && matchesLayer($element, options.layer);\n      });\n    };\n\n    /***\n    Destroys the given element or selector.\n    \n    Takes care that all [`up.compiler()`](/up.compiler) destructors, if any, are called.\n    \n    The element is removed from the DOM.\n    Note that if you choose to animate the element removal using `options.animate`,\n    the element won't be removed until after the animation has completed.\n    \n    Emits events [`up:fragment:destroy`](/up:fragment:destroy) and [`up:fragment:destroyed`](/up:fragment:destroyed).\n    \n    @function up.destroy\n    @param {string|Element|jQuery} selectorOrElement\n    @param {string} [options.history]\n      A URL that will be pushed as a new history entry when the element begins destruction.\n    @param {string} [options.title]\n      The document title to set when the element begins destruction.\n    @param {string|Function} [options.animation='none']\n      The animation to use before the element is removed from the DOM.\n    @param {number} [options.duration]\n      The duration of the animation. See [`up.animate()`](/up.animate).\n    @param {number} [options.delay]\n      The delay before the animation starts. See [`up.animate()`](/up.animate).\n    @param {string} [options.easing]\n      The timing function that controls the animation's acceleration. [`up.animate()`](/up.animate).\n    @return {Promise}\n      A promise that will be fulfilled once the element has been removed from the DOM.\n    @stable\n     */\n    destroy = function(selectorOrElement, options) {\n      var $element, animate, wipe;\n      $element = $(selectorOrElement);\n      options = u.options(options, {\n        animation: false\n      });\n      if ($element.length === 0) {\n        return Promise.resolve();\n      }\n      markElementAsDestroying($element);\n      emitFragmentDestroy($element, options);\n      updateHistoryAndTitle(options);\n      animate = function() {\n        var animateOptions;\n        animateOptions = up.motion.animateOptions(options);\n        return up.motion.animate($element, options.animation, animateOptions);\n      };\n      wipe = function() {\n        var $parent;\n        $parent = $element.parent();\n        up.syntax.clean($element);\n        $element.remove();\n        return emitFragmentDestroyed($element, {\n          $parent: $parent\n        });\n      };\n      return animate().then(wipe);\n    };\n    shouldLogDestruction = function($element, options) {\n      return options.log !== false && !$element.is('.up-placeholder, .up-tooltip, .up-modal, .up-popup');\n    };\n\n    /***\n    Elements are assigned the `.up-destroying` class before they are [destroyed](/up.destroy)\n    or while they are being removed by a [transition](/up.morph).\n    \n    If the removal is animated, the class is assigned before the animation.\n    \n    Also see the [`up.first()`](/up.first) function.\n    \n    @selector .up-destroying\n    @stable\n     */\n    markElementAsDestroying = function($element) {\n      return $element.addClass('up-destroying');\n    };\n\n    /***\n    Before a page fragment is being [destroyed](/up.destroy), this\n    event is [emitted](/up.emit) on the fragment.\n    \n    If the destruction is animated, this event is emitted before the\n    animation begins.\n    \n    @event up:fragment:destroy\n    @param {jQuery} event.$element\n      The page fragment that is about to be destroyed.\n    @stable\n     */\n\n    /***\n    This event is [emitted](/up.emit) after a page fragment was [destroyed](/up.destroy) and removed from the DOM.\n    \n    If the destruction is animated, this event is emitted after the animation has ended.\n    \n    The event is emitted on the parent element of the fragment that was removed.\n    \n    @event up:fragment:destroyed\n    @param {jQuery} event.$element\n      The page fragment that has been removed from the DOM.\n    @param {jQuery} event.$parent\n      The parent element of the fragment that has been removed from the DOM.\n    @stable\n     */\n\n    /***\n    Replaces the given element with a fresh copy fetched from the server.\n    \n    \\#\\#\\# Example\n    \n        up.on('new-mail', function() {\n          up.reload('.inbox');\n        });\n    \n    Unpoly remembers the URL from which a fragment was loaded, so you\n    don't usually need to give an URL when reloading.\n    \n    @function up.reload\n    @param {string|Element|jQuery} selectorOrElement\n    @param {Object} [options]\n      See options for [`up.replace()`](/up.replace)\n    @param {string} [options.url]\n      The URL from which to reload the fragment.\n      This defaults to the URL from which the fragment was originally loaded.\n    @stable\n     */\n    reload = function(selectorOrElement, options) {\n      var sourceUrl;\n      options = u.options(options, {\n        cache: false\n      });\n      sourceUrl = options.url || source(selectorOrElement);\n      return replace(selectorOrElement, sourceUrl, options);\n    };\n    up.on('up:app:boot', function() {\n      var $body;\n      $body = $(document.body);\n      setSource($body, up.browser.url());\n      return hello($body);\n    });\n    up.on('up:framework:reset', reset);\n    return {\n      replace: replace,\n      reload: reload,\n      destroy: destroy,\n      extract: extract,\n      first: first,\n      all: all,\n      source: source,\n      resolveSelector: resolveSelector,\n      hello: hello,\n      config: config,\n      layerOf: layerOf\n    };\n  })(jQuery);\n\n  up.replace = up.dom.replace;\n\n  up.extract = up.dom.extract;\n\n  up.reload = up.dom.reload;\n\n  up.destroy = up.dom.destroy;\n\n  up.first = up.dom.first;\n\n  up.all = up.dom.all;\n\n  up.hello = up.dom.hello;\n\n  up.deprecateRenamedModule('flow', 'dom');\n\n}).call(this);\n\n/***\nAnimation\n=========\n  \nWhenever you [update a page fragment](/up.link) you can animate the change.\n\nLet's say you are using an [`up-target`](/a-up-target) link to update an element\nwith content from the server. You can add an attribute [`up-transition`](/a-up-target#up-transition)\nto smoothly fade out the old element while fading in the new element:\n\n    <a href=\"/users\" up-target=\".list\" up-transition=\"cross-fade\">Show users</a>\n\n\\#\\#\\# Transitions vs. animations\n\nWhen we morph between an old and a new element, we call it a *transition*.\nIn contrast, when we animate a new element without simultaneously removing an\nold element, we call it an *animation*.\n\nAn example for an animation is opening a new dialog. We can animate the appearance\nof the dialog by adding an [`[up-animation]`](/a-up-modal#up-animation) attribute to the opening link:\n\n    <a href=\"/users\" up-modal=\".list\" up-animation=\"move-from-top\">Show users</a>\n\n\\#\\#\\# Which animations are available?\n\nUnpoly ships with a number of [predefined transitions](/up.morph#named-transitions)\nand [predefined animations](/up.animate#named-animations).\n\nYou can define custom animations using [`up.transition()`](/up.transition) and\n[`up.animation()`](/up.animation).\n\n@class up.motion\n */\n\n(function() {\n  var slice = [].slice;\n\n  up.motion = (function($) {\n    var animCount, animate, animateNow, animateOptions, composeTransitionFn, config, defaultNamedAnimations, defaultNamedTransitions, findAnimationFn, findNamedAnimation, findTransitionFn, finish, isEnabled, isNone, morph, motionTracker, namedAnimations, namedTransitions, registerAnimation, registerTransition, reset, skipAnimate, snapshot, swapElementsDirectly, translateCss, u, willAnimate;\n    u = up.util;\n    namedAnimations = {};\n    defaultNamedAnimations = {};\n    namedTransitions = {};\n    defaultNamedTransitions = {};\n    motionTracker = new up.MotionTracker('motion');\n\n    /***\n    Sets default options for animations and transitions.\n    \n    @property up.motion.config\n    @param {number} [config.duration=300]\n      The default duration for all animations and transitions (in milliseconds).\n    @param {number} [config.delay=0]\n      The default delay for all animations and transitions (in milliseconds).\n    @param {string} [config.easing='ease']\n      The default timing function that controls the acceleration of animations and transitions.\n    \n      See [W3C documentation](http://www.w3.org/TR/css3-transitions/#transition-timing-function)\n      for a list of pre-defined timing functions.\n    @param {boolean} [config.enabled=true]\n      Whether animation is enabled.\n    \n      Set this to `false` to disable animation globally.\n      This can be useful in full-stack integration tests like a Selenium test suite.\n    \n      Regardless of this setting, all animations will be skipped on browsers\n      that do not support [CSS transitions](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Transitions/Using_CSS_transitions).\n    @stable\n     */\n    config = u.config({\n      duration: 300,\n      delay: 0,\n      easing: 'ease',\n      enabled: true\n    });\n    reset = function() {\n      motionTracker.reset();\n      namedAnimations = u.copy(defaultNamedAnimations);\n      namedTransitions = u.copy(defaultNamedTransitions);\n      return config.reset();\n    };\n\n    /***\n    Returns whether Unpoly will perform animations.\n    \n    Set [`up.motion.config.enabled`](/up.motion.config) `false` in order to disable animations globally.\n    \n    @function up.motion.isEnabled\n    @return {boolean}\n    @stable\n     */\n    isEnabled = function() {\n      return config.enabled;\n    };\n\n    /***\n    Applies the given animation to the given element.\n    \n    \\#\\#\\# Example\n    \n        up.animate('.warning', 'fade-in');\n    \n    You can pass additional options:\n    \n        up.animate('warning', '.fade-in', {\n          delay: 1000,\n          duration: 250,\n          easing: 'linear'\n        });\n    \n    \\#\\#\\# Named animations\n    \n    The following animations are pre-defined:\n    \n    | `fade-in`          | Changes the element's opacity from 0% to 100% |\n    | `fade-out`         | Changes the element's opacity from 100% to 0% |\n    | `move-to-top`      | Moves the element upwards until it exits the screen at the top edge |\n    | `move-from-top`    | Moves the element downwards from beyond the top edge of the screen until it reaches its current position |\n    | `move-to-bottom`   | Moves the element downwards until it exits the screen at the bottom edge |\n    | `move-from-bottom` | Moves the element upwards from beyond the bottom edge of the screen until it reaches its current position |\n    | `move-to-left`     | Moves the element leftwards until it exists the screen at the left edge  |\n    | `move-from-left`   | Moves the element rightwards from beyond the left edge of the screen until it reaches its current position |\n    | `move-to-right`    | Moves the element rightwards until it exists the screen at the right edge  |\n    | `move-from-right`  | Moves the element leftwards from beyond the right  edge of the screen until it reaches its current position |\n    | `none`             | An animation that has no visible effect. Sounds useless at first, but can save you a lot of `if` statements. |\n    \n    You can define additional named animations using [`up.animation()`](/up.animation).\n    \n    \\#\\#\\# Animating CSS properties directly\n    \n    By passing an object instead of an animation name, you can animate\n    the CSS properties of the given element:\n    \n        var $warning = $('.warning');\n        $warning.css({ opacity: 0 });\n        up.animate($warning, { opacity: 1 });\n    \n    \\#\\#\\# Multiple animations on the same element\n    \n    Unpoly doesn't allow more than one concurrent animation on the same element.\n    \n    If you attempt to animate an element that is already being animated,\n    the previous animation will instantly jump to its last frame before\n    the new animation begins.\n    \n    @function up.animate\n    @param {Element|jQuery|string} elementOrSelector\n      The element to animate.\n    @param {string|Function|Object} animation\n      Can either be:\n    \n      - The animation's name\n      - A function performing the animation\n      - An object of CSS attributes describing the last frame of the animation\n    @param {number} [options.duration=300]\n      The duration of the animation, in milliseconds.\n    @param {number} [options.delay=0]\n      The delay before the animation starts, in milliseconds.\n    @param {string} [options.easing='ease']\n      The timing function that controls the animation's acceleration.\n    \n      See [W3C documentation](http://www.w3.org/TR/css3-transitions/#transition-timing-function)\n      for a list of pre-defined timing functions.\n    @return {Promise}\n      A promise for the animation's end.\n    @stable\n     */\n    animate = function(elementOrSelector, animation, options) {\n      var $element, animationFn, runNow, willRun;\n      $element = $(elementOrSelector);\n      options = animateOptions(options);\n      animationFn = findAnimationFn(animation);\n      willRun = willAnimate($element, animation, options);\n      if (willRun) {\n        runNow = function() {\n          return animationFn($element, options);\n        };\n        return motionTracker.claim($element, runNow, options);\n      } else {\n        return skipAnimate($element, animation);\n      }\n    };\n    willAnimate = function($elements, animationOrTransition, options) {\n      options = animateOptions(options);\n      return isEnabled() && !isNone(animationOrTransition) && options.duration > 0 && !u.isSingletonElement($elements);\n    };\n    skipAnimate = function($element, animation) {\n      if (u.isOptions(animation)) {\n        u.writeInlineStyle($element, animation);\n      }\n      return Promise.resolve();\n    };\n    animCount = 0;\n\n    /***\n    Animates the given element's CSS properties using CSS transitions.\n    \n    Does not track the animation, nor does it finishes existing animations\n    (use `up.motion.animate()` for that). It does, however, listen to the motionTracker's\n    finish event.\n    \n    @function animateNow\n    @param {Element|jQuery|string} elementOrSelector\n      The element to animate.\n    @param {Object} lastFrame\n      The CSS properties that should be transitioned to.\n    @param {number} [options.duration=300]\n      The duration of the animation, in milliseconds.\n    @param {number} [options.delay=0]\n      The delay before the animation starts, in milliseconds.\n    @param {string} [options.easing='ease']\n      The timing function that controls the animation's acceleration.\n      See [W3C documentation](http://www.w3.org/TR/css3-transitions/#transition-timing-function)\n      for a list of pre-defined timing functions.\n    @return {Promise}\n      A promise that fulfills when the animation ends.\n    @internal\n     */\n    animateNow = function($element, lastFrame, options) {\n      var cssTransition;\n      options = u.merge(options, {\n        finishEvent: motionTracker.finishEvent\n      });\n      cssTransition = new up.CssTransition($element, lastFrame, options);\n      return cssTransition.start();\n    };\n\n    /***\n    Extracts animation-related options from the given options hash.\n    If `$element` is given, also inspects the element for animation-related\n    attributes like `up-easing` or `up-duration`.\n    \n    @function up.motion.animateOptions\n    @internal\n     */\n    animateOptions = function() {\n      var $element, args, consolidatedOptions, moduleDefaults, userOptions;\n      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n      userOptions = args.shift() || {};\n      $element = u.isJQuery(args[0]) ? args.shift() : u.nullJQuery();\n      moduleDefaults = u.isObject(args[0]) ? args.shift() : {};\n      consolidatedOptions = {};\n      consolidatedOptions.easing = u.option(userOptions.easing, u.presentAttr($element, 'up-easing'), moduleDefaults.easing, config.easing);\n      consolidatedOptions.duration = Number(u.option(userOptions.duration, u.presentAttr($element, 'up-duration'), moduleDefaults.duration, config.duration));\n      consolidatedOptions.delay = Number(u.option(userOptions.delay, u.presentAttr($element, 'up-delay'), moduleDefaults.delay, config.delay));\n      consolidatedOptions.trackMotion = userOptions.trackMotion;\n      return consolidatedOptions;\n    };\n    findNamedAnimation = function(name) {\n      return namedAnimations[name] || up.fail(\"Unknown animation %o\", name);\n    };\n\n    /***\n    Completes [animations](/up.animate) and [transitions](/up.morph).\n    \n    If called without arguments, all animations on the screen are completed.\n    If given an element (or selector), animations on that element and its children\n    are completed.\n    \n    Animations are completed by jumping to the last animation frame instantly.\n    \n    Does nothing if there are no animation to complete.\n    \n    @function up.motion.finish\n    @param {Element|jQuery|string} [elementOrSelector]\n    @return {Promise}\n      A promise that fulfills when animations and transitions have finished.\n    @stable\n     */\n    finish = function(elementOrSelector) {\n      return motionTracker.finish(elementOrSelector);\n    };\n\n    /***\n    Performs an animated transition between the `source` and `target` elements.\n    \n    Transitions are implement by performing two animations in parallel,\n    causing `source` to disappear and the `target` to appear.\n    \n    - `target` is [inserted before](https://developer.mozilla.org/en-US/docs/Web/API/Node/insertBefore) `source`\n    - `source` is removed from the [document flow](https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Positioning) with `position: absolute`.\n       It will be positioned over its original place in the flow that is now occupied by `target`.\n    - Both `source` and `target` are animated in parallel\n    - `source` is removed from the DOM\n    \n    \\#\\#\\# Named transitions\n    \n    The following transitions are pre-defined:\n    \n    | `cross-fade` | Fades out the first element. Simultaneously fades in the second element. |\n    | `move-up`    | Moves the first element upwards until it exits the screen at the top edge. Simultaneously moves the second element upwards from beyond the bottom edge of the screen until it reaches its current position. |\n    | `move-down`  | Moves the first element downwards until it exits the screen at the bottom edge. Simultaneously moves the second element downwards from beyond the top edge of the screen until it reaches its current position. |\n    | `move-left`  | Moves the first element leftwards until it exists the screen at the left edge. Simultaneously moves the second element leftwards from beyond the right  edge of the screen until it reaches its current position. |\n    | `move-right` | Moves the first element rightwards until it exists the screen at the right edge. Simultaneously moves the second element rightwards from beyond the left edge of the screen until it reaches its current position. |\n    | `none`       | A transition that has no visible effect. Sounds useless at first, but can save you a lot of `if` statements. |\n    \n    You can define additional named transitions using [`up.transition()`](/up.transition).\n    \n    You can also compose a transition from two [named animations](/named-animations).\n    separated by a slash character (`/`):\n    \n    - `move-to-bottom/fade-in`\n    - `move-to-left/move-from-top`\n    \n    \\#\\#\\# Implementation details\n    \n    During a transition both the old and new element occupy\n    the same position on the screen.\n    \n    Since the CSS layout flow will usually not allow two elements to\n    overlay the same space, Unpoly:\n    \n    - The old and new elements are cloned\n    - The old element is removed from the layout flow using `display: hidden`\n    - The new element is hidden, but still leaves space in the layout flow by setting `visibility: hidden`\n    - The clones are [absolutely positioned](https://developer.mozilla.org/en-US/docs/Web/CSS/position#Absolute_positioning)\n      over the original elements.\n    - The transition is applied to the cloned elements.\n      At no point will the hidden, original elements be animated.\n    - When the transition has finished, the clones are removed from the DOM and the new element is shown.\n      The old element remains hidden in the DOM.\n    \n    @function up.morph\n    @param {Element|jQuery|string} source\n    @param {Element|jQuery|string} target\n    @param {Function|string} transitionOrName\n    @param {number} [options.duration=300]\n      The duration of the animation, in milliseconds.\n    @param {number} [options.delay=0]\n      The delay before the animation starts, in milliseconds.\n    @param {string} [options.easing='ease']\n      The timing function that controls the transition's acceleration.\n    \n      See [W3C documentation](http://www.w3.org/TR/css3-transitions/#transition-timing-function)\n      for a list of pre-defined timing functions.\n    @param {boolean} [options.reveal=false]\n      Whether to reveal the new element by scrolling its parent viewport.\n    @return {Promise}\n      A promise that fulfills when the transition ends.\n    @experimental\n     */\n    morph = function(source, target, transitionObject, options) {\n      var $both, $new, $old, $viewport, afterDetach, afterInsert, beforeDetach, beforeStart, oldRemote, promise, scrollNew, scrollTopBeforeReveal, trackable, transitionFn, willMorph;\n      options = u.options(options);\n      options = u.assign(options, animateOptions(options));\n      $old = $(source);\n      $new = $(target);\n      $both = $old.add($new);\n      transitionFn = findTransitionFn(transitionObject);\n      willMorph = willAnimate($old, transitionFn, options);\n      beforeStart = u.pluckKey(options, 'beforeStart') || u.noop;\n      afterInsert = u.pluckKey(options, 'afterInsert') || u.noop;\n      beforeDetach = u.pluckKey(options, 'beforeDetach') || u.noop;\n      afterDetach = u.pluckKey(options, 'afterDetach') || u.noop;\n      beforeStart();\n      scrollNew = function() {\n        var scrollOptions;\n        scrollOptions = u.merge(options, {\n          duration: 0\n        });\n        return up.layout.scrollAfterInsertFragment($new, scrollOptions);\n      };\n      if (willMorph) {\n        if (motionTracker.isActive($old) && options.trackMotion === false) {\n          return transitionFn($old, $new, options);\n        }\n        up.puts('Morphing %o to %o with transition %o', $old.get(0), $new.get(0), transitionObject);\n        $viewport = up.layout.viewportOf($old);\n        scrollTopBeforeReveal = $viewport.scrollTop();\n        oldRemote = up.layout.absolutize($old, {\n          afterMeasure: function() {\n            $new.insertBefore($old);\n            return afterInsert();\n          }\n        });\n        trackable = function() {\n          var promise;\n          promise = scrollNew();\n          promise = promise.then(function() {\n            var scrollTopAfterReveal;\n            scrollTopAfterReveal = $viewport.scrollTop();\n            oldRemote.moveTop(scrollTopAfterReveal - scrollTopBeforeReveal);\n            return transitionFn($old, $new, options);\n          });\n          promise = promise.then(function() {\n            beforeDetach();\n            $old.detach();\n            oldRemote.$bounds.remove();\n            return afterDetach();\n          });\n          return promise;\n        };\n        return motionTracker.claim($both, trackable, options);\n      } else {\n        beforeDetach();\n        swapElementsDirectly($old, $new);\n        afterInsert();\n        afterDetach();\n        promise = scrollNew();\n        return promise;\n      }\n    };\n    findTransitionFn = function(object) {\n      var namedTransition;\n      if (isNone(object)) {\n        return void 0;\n      } else if (u.isFunction(object)) {\n        return object;\n      } else if (u.isArray(object)) {\n        return composeTransitionFn.apply(null, object);\n      } else if (u.isString(object)) {\n        if (object.indexOf('/') >= 0) {\n          return composeTransitionFn.apply(null, object.split('/'));\n        } else if (namedTransition = namedTransitions[object]) {\n          return findTransitionFn(namedTransition);\n        }\n      } else {\n        return up.fail(\"Unknown transition %o\", object);\n      }\n    };\n    composeTransitionFn = function(oldAnimation, newAnimation) {\n      var newAnimationFn, oldAnimationFn;\n      if (isNone(oldAnimation) && isNone(oldAnimation)) {\n        return void 0;\n      } else {\n        oldAnimationFn = findAnimationFn(oldAnimation) || u.asyncNoop;\n        newAnimationFn = findAnimationFn(newAnimation) || u.asyncNoop;\n        return function($old, $new, options) {\n          return Promise.all([oldAnimationFn($old, options), newAnimationFn($new, options)]);\n        };\n      }\n    };\n    findAnimationFn = function(object) {\n      if (isNone(object)) {\n        return void 0;\n      } else if (u.isFunction(object)) {\n        return object;\n      } else if (u.isString(object)) {\n        return findNamedAnimation(object);\n      } else if (u.isOptions(object)) {\n        return function($element, options) {\n          return animateNow($element, object, options);\n        };\n      } else {\n        return up.fail('Unknown animation %o', object);\n      }\n    };\n    swapElementsDirectly = function($old, $new) {\n      return $old.replaceWith($new);\n    };\n\n    /***\n    Defines a named transition.\n    \n    Here is the definition of the pre-defined `cross-fade` animation:\n    \n        up.transition('cross-fade', ($old, $new, options) ->\n          up.motion.when(\n            up.animate($old, 'fade-out', options),\n            up.animate($new, 'fade-in', options)\n          )\n        )\n    \n    It is recommended that your transitions use [`up.animate()`](/up.animate),\n    passing along the `options` that were passed to you.\n    \n    If you choose to *not* use `up.animate()` and roll your own\n    logic instead, your code must honor the following contract:\n    \n    1. It must honor the options `{ delay, duration, easing }` if given\n    2. It must *not* remove any of the given elements from the DOM.\n    3. It returns a promise that is fulfilled when the transition has ended\n    4. If during the animation an event `up:motion:finish` is emitted on\n       the given element, the transition instantly jumps to the last frame\n       and resolves the returned promise.\n    \n    Calling [`up.animate()`](/up.animate) with an object argument\n    will take care of all these points.\n    \n    @function up.transition\n    @param {string} name\n    @param {Function} transition\n    @stable\n     */\n    registerTransition = function(name, transition) {\n      return namedTransitions[name] = findTransitionFn(transition);\n    };\n\n    /***\n    Defines a named animation.\n    \n    Here is the definition of the pre-defined `fade-in` animation:\n    \n        up.animation('fade-in', function($element, options) {\n          $element.css(opacity: 0);\n          up.animate($element, { opacity: 1 }, options);\n        })\n    \n    It is recommended that your definitions always end by calling\n    calling [`up.animate()`](/up.animate) with an object argument, passing along\n    the `options` that were passed to you.\n    \n    If you choose to *not* use `up.animate()` and roll your own\n    animation code instead, your code must honor the following contract:\n    \n    1. It must honor the options `{ delay, duration, easing }` if given\n    2. It must *not* remove any of the given elements from the DOM.\n    3. It returns a promise that is fulfilled when the transition has ended\n    4. If during the animation an event `up:motion:finish` is emitted on\n       the given element, the transition instantly jumps to the last frame\n       and resolves the returned promise.\n    \n    Calling [`up.animate()`](/up.animate) with an object argument\n    will take care of all these points.\n    \n    @function up.animation\n    @param {string} name\n    @param {Function} animation\n    @stable\n     */\n    registerAnimation = function(name, animation) {\n      return namedAnimations[name] = findAnimationFn(animation);\n    };\n    snapshot = function() {\n      defaultNamedAnimations = u.copy(namedAnimations);\n      return defaultNamedTransitions = u.copy(namedTransitions);\n    };\n\n    /***\n    Returns whether the given animation option will cause the animation\n    to be skipped.\n    \n    @function up.motion.isNone\n    @internal\n     */\n    isNone = function(animationOrTransition) {\n      return !animationOrTransition || animationOrTransition === 'none' || u.isBlank(animationOrTransition);\n    };\n    registerAnimation('fade-in', function($element, options) {\n      u.writeInlineStyle($element, {\n        opacity: 0\n      });\n      return animateNow($element, {\n        opacity: 1\n      }, options);\n    });\n    registerAnimation('fade-out', function($element, options) {\n      u.writeInlineStyle($element, {\n        opacity: 1\n      });\n      return animateNow($element, {\n        opacity: 0\n      }, options);\n    });\n    translateCss = function(x, y) {\n      return {\n        transform: \"translate(\" + x + \"px, \" + y + \"px)\"\n      };\n    };\n    registerAnimation('move-to-top', function($element, options) {\n      var box, travelDistance;\n      u.writeInlineStyle($element, translateCss(0, 0));\n      box = u.measure($element);\n      travelDistance = box.top + box.height;\n      return animateNow($element, translateCss(0, -travelDistance), options);\n    });\n    registerAnimation('move-from-top', function($element, options) {\n      var box, travelDistance;\n      u.writeInlineStyle($element, translateCss(0, 0));\n      box = u.measure($element);\n      travelDistance = box.top + box.height;\n      u.writeInlineStyle($element, translateCss(0, -travelDistance));\n      return animateNow($element, translateCss(0, 0), options);\n    });\n    registerAnimation('move-to-bottom', function($element, options) {\n      var box, travelDistance;\n      u.writeInlineStyle($element, translateCss(0, 0));\n      box = u.measure($element);\n      travelDistance = u.clientSize().height - box.top;\n      return animateNow($element, translateCss(0, travelDistance), options);\n    });\n    registerAnimation('move-from-bottom', function($element, options) {\n      var box, travelDistance;\n      u.writeInlineStyle($element, translateCss(0, 0));\n      box = u.measure($element);\n      travelDistance = u.clientSize().height - box.top;\n      u.writeInlineStyle($element, translateCss(0, travelDistance));\n      return animateNow($element, translateCss(0, 0), options);\n    });\n    registerAnimation('move-to-left', function($element, options) {\n      var box, travelDistance;\n      u.writeInlineStyle($element, translateCss(0, 0));\n      box = u.measure($element);\n      travelDistance = box.left + box.width;\n      return animateNow($element, translateCss(-travelDistance, 0), options);\n    });\n    registerAnimation('move-from-left', function($element, options) {\n      var box, travelDistance;\n      u.writeInlineStyle($element, translateCss(0, 0));\n      box = u.measure($element);\n      travelDistance = box.left + box.width;\n      u.writeInlineStyle($element, translateCss(-travelDistance, 0));\n      return animateNow($element, translateCss(0, 0), options);\n    });\n    registerAnimation('move-to-right', function($element, options) {\n      var box, travelDistance;\n      u.writeInlineStyle($element, translateCss(0, 0));\n      box = u.measure($element);\n      travelDistance = u.clientSize().width - box.left;\n      return animateNow($element, translateCss(travelDistance, 0), options);\n    });\n    registerAnimation('move-from-right', function($element, options) {\n      var box, travelDistance;\n      u.writeInlineStyle($element, translateCss(0, 0));\n      box = u.measure($element);\n      travelDistance = u.clientSize().width - box.left;\n      u.writeInlineStyle($element, translateCss(travelDistance, 0));\n      return animateNow($element, translateCss(0, 0), options);\n    });\n    registerAnimation('roll-down', function($element, options) {\n      var deferred, fullHeight, styleMemo;\n      fullHeight = $element.height();\n      styleMemo = u.writeTemporaryStyle($element, {\n        height: '0px',\n        overflow: 'hidden'\n      });\n      deferred = animate($element, {\n        height: fullHeight + \"px\"\n      }, options);\n      deferred.then(styleMemo);\n      return deferred;\n    });\n    registerTransition('move-left', ['move-to-left', 'move-from-right']);\n    registerTransition('move-right', ['move-to-right', 'move-from-left']);\n    registerTransition('move-up', ['move-to-top', 'move-from-bottom']);\n    registerTransition('move-down', ['move-to-bottom', 'move-from-top']);\n    registerTransition('cross-fade', ['fade-out', 'fade-in']);\n    up.on('up:framework:booted', snapshot);\n    up.on('up:framework:reset', reset);\n    return {\n      morph: morph,\n      animate: animate,\n      animateOptions: animateOptions,\n      willAnimate: willAnimate,\n      finish: finish,\n      finishCount: function() {\n        return motionTracker.finishCount;\n      },\n      transition: registerTransition,\n      animation: registerAnimation,\n      config: config,\n      isEnabled: isEnabled,\n      isNone: isNone\n    };\n  })(jQuery);\n\n  up.transition = up.motion.transition;\n\n  up.animation = up.motion.animation;\n\n  up.morph = up.motion.morph;\n\n  up.animate = up.motion.animate;\n\n}).call(this);\n\n/***\nAJAX acceleration\n=================\n\nUnpoly comes with a number of tricks to shorten the latency between browser and server.\n\n\\#\\#\\# Server responses are cached by default\n\nUnpoly caches server responses for a few minutes,\nmaking requests to these URLs return instantly.\nAll Unpoly functions and selectors go through this cache, unless\nyou explicitly pass a `{ cache: false }` option or set an `up-cache=\"false\"` attribute.\n\nThe cache holds up to 70 responses for 5 minutes. You can configure the cache size and expiry using\n[`up.proxy.config`](/up.proxy.config), or clear the cache manually using [`up.proxy.clear()`](/up.proxy.clear).\n\nAlso the entire cache is cleared with every non-`GET` request (like `POST` or `PUT`).\n\nIf you need to make cache-aware requests from your [custom JavaScript](/up.syntax),\nuse [`up.request()`](/up.request).\n\n\\#\\#\\# Preloading links\n\nUnpoly also lets you speed up reaction times by [preloading\nlinks](/a-up-preload) when the user hovers over the click area (or puts the mouse/finger\ndown). This way the response will already be cached when\nthe user releases the mouse/finger.\n\n\\#\\#\\# Spinners\n\nYou can listen to the [`up:proxy:slow`](/up:proxy:slow) event to implement a spinner\nthat appears during a long-running request.\n\n\\#\\#\\# More acceleration\n\nOther Unpoly modules contain even more tricks to outsmart network latency:\n\n- [Instantaneous feedback for links that are currently loading](/a.up-active)\n- [Follow links on `mousedown` instead of `click`](/a-up-instant)\n\n@class up.proxy\n */\n\n(function() {\n  var slice = [].slice;\n\n  up.proxy = (function($) {\n    var $waitingLink, ajax, alias, cache, cancelPreloadDelay, cancelSlowDelay, clear, config, get, isBusy, isIdle, isSafeMethod, load, loadEnded, loadOrQueue, loadStarted, makeRequest, pendingCount, pokeQueue, preload, preloadAfterDelay, preloadDelayTimer, queue, queuedLoaders, registerAliasForRedirect, remove, reset, responseReceived, set, slowDelayTimer, slowEventEmitted, startPreloadDelay, stopPreload, u, wrapMethod;\n    u = up.util;\n    $waitingLink = void 0;\n    preloadDelayTimer = void 0;\n    slowDelayTimer = void 0;\n    pendingCount = void 0;\n    slowEventEmitted = void 0;\n    queuedLoaders = [];\n\n    /***\n    @property up.proxy.config\n    @param {number} [config.preloadDelay=75]\n      The number of milliseconds to wait before [`[up-preload]`](/a-up-preload)\n      starts preloading.\n    @param {number} [config.cacheSize=70]\n      The maximum number of responses to cache.\n      If the size is exceeded, the oldest items will be dropped from the cache.\n    @param {number} [config.cacheExpiry=300000]\n      The number of milliseconds until a cache entry expires.\n      Defaults to 5 minutes.\n    @param {number} [config.slowDelay=300]\n      How long the proxy waits until emitting the [`up:proxy:slow` event](/up:proxy:slow).\n      Use this to prevent flickering of spinners.\n    @param {number} [config.maxRequests=4]\n      The maximum number of concurrent requests to allow before additional\n      requests are queued. This currently ignores preloading requests.\n    \n      You might find it useful to set this to `1` in full-stack integration\n      tests (e.g. Selenium).\n    \n      Note that your browser might [impose its own request limit](http://www.browserscope.org/?category=network)\n      regardless of what you configure here.\n    @param {Array<string>} [config.wrapMethods]\n      An array of uppercase HTTP method names. AJAX requests with one of these methods\n      will be converted into a `POST` request and carry their original method as a `_method`\n      parameter. This is to [prevent unexpected redirect behavior](https://makandracards.com/makandra/38347).\n    @param {Array<string>} [config.safeMethods]\n      An array of uppercase HTTP method names that are considered [safe](https://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9.1.1).\n      The proxy cache will only cache safe requests and will clear the entire\n      cache after an unsafe request.\n    @stable\n     */\n    config = u.config({\n      slowDelay: 300,\n      preloadDelay: 75,\n      cacheSize: 70,\n      cacheExpiry: 1000 * 60 * 5,\n      maxRequests: 4,\n      wrapMethods: ['PATCH', 'PUT', 'DELETE'],\n      safeMethods: ['GET', 'OPTIONS', 'HEAD']\n    });\n    cache = new up.Cache({\n      size: function() {\n        return config.cacheSize;\n      },\n      expiry: function() {\n        return config.cacheExpiry;\n      },\n      key: function(request) {\n        return up.Request.wrap(request).cacheKey();\n      },\n      cachable: function(request) {\n        return up.Request.wrap(request).isCachable();\n      }\n    });\n\n    /***\n    Returns a cached response for the given request.\n    \n    Returns `undefined` if the given request is not currently cached.\n    \n    @function up.proxy.get\n    @return {Promise<up.Response>}\n      A promise for the response.\n    @experimental\n     */\n    get = function(request) {\n      var candidate, candidates, i, len, requestForBody, requestForHtml, response;\n      request = up.Request.wrap(request);\n      candidates = [request];\n      if (request.target !== 'html') {\n        requestForHtml = request.copy({\n          target: 'html'\n        });\n        candidates.push(requestForHtml);\n        if (request.target !== 'body') {\n          requestForBody = request.copy({\n            target: 'body'\n          });\n          candidates.push(requestForBody);\n        }\n      }\n      for (i = 0, len = candidates.length; i < len; i++) {\n        candidate = candidates[i];\n        if (response = cache.get(candidate)) {\n          return response;\n        }\n      }\n    };\n    cancelPreloadDelay = function() {\n      clearTimeout(preloadDelayTimer);\n      return preloadDelayTimer = null;\n    };\n    cancelSlowDelay = function() {\n      clearTimeout(slowDelayTimer);\n      return slowDelayTimer = null;\n    };\n    reset = function() {\n      $waitingLink = null;\n      cancelPreloadDelay();\n      cancelSlowDelay();\n      pendingCount = 0;\n      config.reset();\n      cache.clear();\n      slowEventEmitted = false;\n      return queuedLoaders = [];\n    };\n    reset();\n\n    /***\n    Makes an AJAX request to the given URL.\n    \n    \\#\\#\\# Example\n    \n        up.request('/search', params: { query: 'sunshine' }).then(function(response) {\n          console.log('The response text is %o', response.text);\n        }).catch(function() {\n          console.error('The request failed');\n        });\n    \n    \\#\\#\\# Caching\n    \n    All responses are cached by default. If requesting a URL with a non-`GET` method, the response will\n    not be cached and the entire cache will be cleared.\n    \n    You can configure caching with the [`up.proxy.config`](/up.proxy.config) property.\n    \n    \\#\\#\\# Events\n    \n    If a network connection is attempted, the proxy will emit\n    a [`up:proxy:load`](/up:proxy:load) event with the `request` as its argument.\n    Once the response is received, a [`up:proxy:loaded`](/up:proxy:loaded) event will\n    be emitted.\n    \n    @function up.request\n    @param {string} [url]\n      The URL for the request.\n    \n      Instead of passing the URL as a string argument, you can also pass it as an `{ url }` option.\n    @param {string} [options.url]\n      You can omit the first string argument and pass the URL as\n      a `request` property instead.\n    @param {string} [options.method='GET']\n      The HTTP method for the options.\n    @param {boolean} [options.cache]\n      Whether to use a cached response for [safe](https://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9.1.1)\n      requests, if available. If set to `false` a network connection will always be attempted.\n    @param {Object} [options.headers={}]\n      An object of additional HTTP headers.\n    @param {Object|FormData|string|Array} [options.params={}]\n      [Parameters](/up.params) that should be sent as the request's payload.\n    @param {string} [options.timeout]\n      A timeout in milliseconds.\n    \n      If [`up.proxy.config.maxRequests`](/up.proxy.config#config.maxRequests) is set, the timeout\n      will not include the time spent waiting in the queue.\n    @param {string} [options.target='body']\n      The CSS selector that will be sent as an [`X-Up-Target` header](/up.protocol#optimizing-responses).\n    @param {string} [options.failTarget='body']\n      The CSS selector that will be sent as an [`X-Up-Fail-Target` header](/up.protocol#optimizing-responses).\n    @return {Promise<up.Response>}\n      A promise for the response.\n    @stable\n     */\n    makeRequest = function() {\n      var args, ignoreCache, promise, request, requestOrOptions, url;\n      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n      if (u.isString(args[0])) {\n        url = args.shift();\n      }\n      requestOrOptions = args.shift() || {};\n      if (url) {\n        requestOrOptions.url = url;\n      }\n      request = up.Request.wrap(requestOrOptions);\n      if (!request.isSafe()) {\n        clear();\n      }\n      ignoreCache = request.cache === false;\n      if (!ignoreCache && (promise = get(request))) {\n        up.puts('Re-using cached response for %s %s', request.method, request.url);\n      } else {\n        promise = loadOrQueue(request);\n        set(request, promise);\n        promise[\"catch\"](function(e) {\n          return remove(request);\n        });\n      }\n      if (!request.preload) {\n        loadStarted();\n        u.always(promise, loadEnded);\n      }\n      return promise;\n    };\n\n    /***\n    Makes an AJAX request to the given URL and caches the response.\n    \n    The function returns a promise that fulfills with the response text.\n    \n    \\#\\#\\# Example\n    \n        up.request('/search', params: { query: 'sunshine' }).then(function(text) {\n          console.log('The response text is %o', text);\n        }).catch(function() {\n          console.error('The request failed');\n        });\n    \n    @function up.ajax\n    @param {string} [url]\n      The URL for the request.\n    \n      Instead of passing the URL as a string argument, you can also pass it as an `{ url }` option.\n    @param {string} [request.url]\n      You can omit the first string argument and pass the URL as\n      a `request` property instead.\n    @param {string} [request.method='GET']\n      The HTTP method for the request.\n    @param {boolean} [request.cache]\n      Whether to use a cached response for [safe](https://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9.1.1)\n      requests, if available. If set to `false` a network connection will always be attempted.\n    @param {Object} [request.headers={}]\n      An object of additional header key/value pairs to send along\n      with the request.\n    @param {Object|FormData|string|Array} [options.params]\n      [Parameters](/up.params) that should be sent as the request's payload.\n    @param {string} [request.timeout]\n      A timeout in milliseconds for the request.\n    \n      If [`up.proxy.config.maxRequests`](/up.proxy.config#config.maxRequests) is set, the timeout\n      will not include the time spent waiting in the queue.\n    @return {Promise<string>}\n      A promise for the response text.\n    @deprecated\n      Use [`up.request()`](/up.request) instead.\n     */\n    ajax = function() {\n      var args;\n      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n      up.warn('up.ajax() has been deprecated. Use up.request() instead.');\n      return new Promise(function(resolve, reject) {\n        var pickResponseText;\n        pickResponseText = function(response) {\n          return resolve(response.text);\n        };\n        return makeRequest.apply(null, args).then(pickResponseText, reject);\n      });\n    };\n\n    /***\n    Returns `true` if the proxy is not currently waiting\n    for a request to finish. Returns `false` otherwise.\n    \n    @function up.proxy.isIdle\n    @return {boolean}\n      Whether the proxy is idle\n    @experimental\n     */\n    isIdle = function() {\n      return pendingCount === 0;\n    };\n\n    /***\n    Returns `true` if the proxy is currently waiting\n    for a request to finish. Returns `false` otherwise.\n    \n    @function up.proxy.isBusy\n    @return {boolean}\n      Whether the proxy is busy\n    @experimental\n     */\n    isBusy = function() {\n      return pendingCount > 0;\n    };\n    loadStarted = function() {\n      var emission;\n      pendingCount += 1;\n      if (!slowDelayTimer) {\n        emission = function() {\n          if (isBusy()) {\n            up.emit('up:proxy:slow', {\n              message: 'Proxy is slow to respond'\n            });\n            return slowEventEmitted = true;\n          }\n        };\n        return slowDelayTimer = u.setTimer(config.slowDelay, emission);\n      }\n    };\n\n    /***\n    This event is [emitted](/up.emit) when [AJAX requests](/up.request)\n    are taking long to finish.\n    \n    By default Unpoly will wait 300 ms for an AJAX request to finish\n    before emitting `up:proxy:slow`. You can configure this time like this:\n    \n        up.proxy.config.slowDelay = 150;\n    \n    Once all responses have been received, an [`up:proxy:recover`](/up:proxy:recover)\n    will be emitted.\n    \n    Note that if additional requests are made while Unpoly is already busy\n    waiting, **no** additional `up:proxy:slow` events will be triggered.\n    \n    \n    \\#\\#\\# Spinners\n    \n    You can [listen](/up.on) to the `up:proxy:slow`\n    and [`up:proxy:recover`](/up:proxy:recover) events to implement a spinner\n    that appears during a long-running request,\n    and disappears once the response has been received:\n    \n        <div class=\"spinner\">Please wait!</div>\n    \n    Here is the JavaScript to make it alive:\n    \n        up.compiler('.spinner', function($element) {\n    \n          show = function() { $element.show() };\n          hide = function() { $element.hide() };\n    \n          hide();\n    \n          return [\n            up.on('up:proxy:slow', show),\n            up.on('up:proxy:recover', hide)\n          ];\n    \n        });\n    \n    The `up:proxy:slow` event will be emitted after a delay of 300 ms\n    to prevent the spinner from flickering on and off.\n    You can change (or remove) this delay by [configuring `up.proxy`](/up.proxy.config) like this:\n    \n        up.proxy.config.slowDelay = 150;\n    \n    \n    @event up:proxy:slow\n    @stable\n     */\n    loadEnded = function() {\n      pendingCount -= 1;\n      if (isIdle()) {\n        cancelSlowDelay();\n        if (slowEventEmitted) {\n          up.emit('up:proxy:recover', {\n            message: 'Proxy has recovered from slow response'\n          });\n          return slowEventEmitted = false;\n        }\n      }\n    };\n\n    /***\n    This event is [emitted](/up.emit) when [AJAX requests](/up.request)\n    have [taken long to finish](/up:proxy:slow), but have finished now.\n    \n    See [`up:proxy:slow`](/up:proxy:slow) for more documentation on\n    how to use this event for implementing a spinner that shows during\n    long-running requests.\n    \n    @event up:proxy:recover\n    @stable\n     */\n    loadOrQueue = function(request) {\n      if (pendingCount < config.maxRequests) {\n        return load(request);\n      } else {\n        return queue(request);\n      }\n    };\n    queue = function(request) {\n      var loader;\n      up.puts('Queuing request for %s %s', request.method, request.url);\n      loader = function() {\n        return load(request);\n      };\n      loader = u.previewable(loader);\n      queuedLoaders.push(loader);\n      return loader.promise;\n    };\n    load = function(request) {\n      var eventProps, responsePromise;\n      eventProps = {\n        request: request,\n        message: ['Loading %s %s', request.method, request.url]\n      };\n      if (up.bus.nobodyPrevents('up:proxy:load', eventProps)) {\n        responsePromise = request.send();\n        u.always(responsePromise, responseReceived);\n        u.always(responsePromise, pokeQueue);\n        return responsePromise;\n      } else {\n        u.microtask(pokeQueue);\n        return Promise.reject(new Error('Event up:proxy:load was prevented'));\n      }\n    };\n\n    /***\n    This event is [emitted](/up.emit) before an [AJAX request](/up.request)\n    is sent over the network.\n    \n    @event up:proxy:load\n    @param {up.Request} event.request\n    @param event.preventDefault()\n      Event listeners may call this method to prevent the request from being sent.\n    @experimental\n     */\n    registerAliasForRedirect = function(response) {\n      var newRequest, request;\n      request = response.request;\n      if (response.url && request.url !== response.url) {\n        newRequest = request.copy({\n          method: response.method,\n          url: response.url\n        });\n        return up.proxy.alias(request, newRequest);\n      }\n    };\n    responseReceived = function(response) {\n      if (response.isFatalError()) {\n        return up.emit('up:proxy:fatal', {\n          message: 'Fatal error during request',\n          request: response.request,\n          response: response\n        });\n      } else {\n        if (!response.isError()) {\n          registerAliasForRedirect(response);\n        }\n        return up.emit('up:proxy:loaded', {\n          message: ['Server responded with HTTP %d (%d bytes)', response.status, response.text.length],\n          request: response.request,\n          response: response\n        });\n      }\n    };\n\n    /***\n    This event is [emitted](/up.emit) when the response to an\n    [AJAX request](/up.request) has been received.\n    \n    Note that this event will also be emitted when the server signals an\n    error with an HTTP status like `500`. Only if the request\n    encounters a fatal error (like a loss of network connectivity),\n    [`up:proxy:fatal`](/up:proxy:fatal) is emitted instead.\n    \n    @event up:proxy:loaded\n    @param {up.Request} event.request\n    @param {up.Response} event.response\n    @experimental\n     */\n\n    /***\n    This event is [emitted](/up.emit) when an [AJAX request](/up.request)\n    encounters fatal error like a timeout or loss of network connectivity.\n    \n    Note that this event will *not* be emitted when the server produces an\n    error message with an HTTP status like `500`. When the server can produce\n    any response, [`up:proxy:loaded`](/up:proxy:loaded) is emitted instead.\n    \n    @event up:proxy:fatal\n     */\n    pokeQueue = function() {\n      var base;\n      if (typeof (base = queuedLoaders.shift()) === \"function\") {\n        base();\n      }\n      return void 0;\n    };\n\n    /***\n    Makes the proxy assume that `newRequest` has the same response as the\n    already cached `oldRequest`.\n    \n    Unpoly uses this internally when the user redirects from `/old` to `/new`.\n    In that case, both `/old` and `/new` will cache the same response from `/new`.\n    \n    @function up.proxy.alias\n    @param {Object} oldRequest\n    @param {Object} newRequest\n    @experimental\n     */\n    alias = cache.alias;\n\n    /***\n    Manually stores a promise for the response to the given request.\n    \n    @function up.proxy.set\n    @param {string} request.url\n    @param {string} [request.method='GET']\n    @param {string} [request.target='body']\n    @param {Promise<up.Response>} response\n      A promise for the response.\n    @experimental\n     */\n    set = cache.set;\n\n    /***\n    Manually removes the given request from the cache.\n    \n    You can also [configure](/up.proxy.config) when the proxy\n    automatically removes cache entries.\n    \n    @function up.proxy.remove\n    @param {string} request.url\n    @param {string} [request.method='GET']\n    @param {string} [request.target='body']\n    @experimental\n     */\n    remove = cache.remove;\n\n    /***\n    Removes all cache entries.\n    \n    Unpoly also automatically clears the cache whenever it processes\n    a request with an [unsafe](https://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9.1.1)\n    HTTP method like `POST`.\n    \n    @function up.proxy.clear\n    @stable\n     */\n    clear = cache.clear;\n    up.bus.deprecateRenamedEvent('up:proxy:received', 'up:proxy:loaded');\n    preloadAfterDelay = function($link) {\n      var curriedPreload, delay;\n      delay = parseInt(u.presentAttr($link, 'up-delay')) || config.preloadDelay;\n      if (!$link.is($waitingLink)) {\n        $waitingLink = $link;\n        cancelPreloadDelay();\n        curriedPreload = function() {\n          u.muteRejection(preload($link));\n          return $waitingLink = null;\n        };\n        return startPreloadDelay(curriedPreload, delay);\n      }\n    };\n    startPreloadDelay = function(block, delay) {\n      return preloadDelayTimer = setTimeout(block, delay);\n    };\n    stopPreload = function($link) {\n      if ($link.is($waitingLink)) {\n        $waitingLink = void 0;\n        return cancelPreloadDelay();\n      }\n    };\n\n    /***\n    Preloads the given link.\n    \n    When the link is clicked later, the response will already be cached,\n    making the interaction feel instant.\n    \n    @function up.proxy.preload\n    @param {string|Element|jQuery}\n      The element whose destination should be preloaded.\n    @param {object} options\n      Options that will be passed to the function making the HTTP requests.\n    @return\n      A promise that will be fulfilled when the request was loaded and cached\n    @experimental\n     */\n    preload = function(linkOrSelector, options) {\n      var $link, preloadEventAttrs;\n      $link = $(linkOrSelector);\n      if (up.link.isSafe($link)) {\n        preloadEventAttrs = {\n          message: ['Preloading link %o', $link.get(0)],\n          $element: $link,\n          $link: $link\n        };\n        return up.bus.whenEmitted('up:link:preload', preloadEventAttrs).then(function() {\n          var variant;\n          variant = up.link.followVariantForLink($link);\n          return variant.preloadLink($link, options);\n        });\n      } else {\n        return Promise.reject(new Error(\"Won't preload unsafe link\"));\n      }\n    };\n\n    /***\n    This event is [emitted](/up.emit) before a link is [preloaded](/up.preload).\n    \n    @event up:link:preload\n    @param {jQuery} event.$link\n      The link element that will be preloaded.\n    @param event.preventDefault()\n      Event listeners may call this method to prevent the link from being preloaded.\n    @stable\n     */\n\n    /***\n    @internal\n     */\n    isSafeMethod = function(method) {\n      return u.contains(config.safeMethods, method);\n    };\n\n    /***\n    @internal\n     */\n    wrapMethod = function(method, params) {\n      if (u.contains(config.wrapMethods, method)) {\n        params = up.params.add(params, up.protocol.config.methodParam, method);\n        method = 'POST';\n      }\n      return [method, params];\n    };\n\n    /***\n    Links with an `up-preload` attribute will silently fetch their target\n    when the user hovers over the click area, or when the user puts her\n    mouse/finger down (before releasing).\n    \n    When the link is clicked later, the response will already be cached,\n    making the interaction feel instant.   \n    \n    @selector a[up-preload]\n    @param [up-delay=75]\n      The number of milliseconds to wait between hovering\n      and preloading. Increasing this will lower the load in your server,\n      but will also make the interaction feel less instant.\n    @stable\n     */\n    up.compiler('a[up-preload], [up-href][up-preload]', function($link) {\n      if (up.link.isSafe($link)) {\n        $link.on('mouseenter touchstart', function(event) {\n          if (up.link.shouldProcessEvent(event, $link)) {\n            return preloadAfterDelay($link);\n          }\n        });\n        return $link.on('mouseleave', function() {\n          return stopPreload($link);\n        });\n      }\n    });\n    up.on('up:framework:reset', reset);\n    return {\n      preload: preload,\n      ajax: ajax,\n      request: makeRequest,\n      get: get,\n      alias: alias,\n      clear: clear,\n      remove: remove,\n      isIdle: isIdle,\n      isBusy: isBusy,\n      isSafeMethod: isSafeMethod,\n      wrapMethod: wrapMethod,\n      config: config\n    };\n  })(jQuery);\n\n  up.ajax = up.proxy.ajax;\n\n  up.request = up.proxy.request;\n\n}).call(this);\n\n/***\nLinking to fragments\n====================\n\nIn a traditional web application, the entire page is destroyed and re-created when the\nuser follows a link:\n\n![Traditional page flow](/images/tutorial/fragment_flow_vanilla.svg){:width=\"620\" class=\"picture has_border is_sepia has_padding\"}\n\nThis makes for an unfriendly experience:\n\n- State changes caused by AJAX updates get lost during the page transition.\n- Unsaved form changes get lost during the page transition.\n- The JavaScript VM is reset during the page transition.\n- If the page layout is composed from multiple srollable containers\n  (e.g. a pane view), the scroll positions get lost during the page transition.\n- The user sees a \"flash\" as the browser loads and renders the new page,\n  even if large portions of the old and new page are the same (navigation, layout, etc.).\n\nUnpoly fixes this by letting you annotate links with an [`up-target`](/a-up-target)\nattribute. The value of this attribute is a CSS selector that indicates which page\nfragment to update. The server **still renders full HTML pages**, but we only use\nthe targeted ragments and discard the rest:\n\n![Unpoly page flow](/images/tutorial/fragment_flow_unpoly.svg){:width=\"620\" class=\"picture has_border is_sepia has_padding\"}\n\nWith this model, following links feel smooth. All transient DOM changes outside the updated fragment are preserved.\nPages also load much faster since the DOM, CSS and Javascript environments do not need to be\ndestroyed and recreated for every request.\n\n\n## Example\n\nLet's say we are rendering three pages with a tabbed navigation to switch between screens:\n\nYour HTML could look like this:\n\n```\n<nav>\n  <a href=\"/pages/a\">A</a>\n  <a href=\"/pages/b\">B</a>\n  <a href=\"/pages/b\">C</a>\n</nav>\n\n<article>\n  Page A\n</article>\n```\n\nSince we only want to update the `<article>` tag, we annotate the links\nwith an `up-target` attribute:\n\n```\n<nav>\n  <a href=\"/pages/a\" up-target=\"article\">A</a>\n  <a href=\"/pages/b\" up-target=\"article\">B</a>\n  <a href=\"/pages/b\" up-target=\"article\">C</a>\n</nav>\n```\n\nNote that instead of `article` you can use any other CSS selector like `#main .article`.\n\nWith these [`up-target`](/a-up-target) annotations Unpoly only updates the targeted part of the screen.\nThe JavaScript environment will persist and the user will not see a white flash while the\nnew page is loading.\n\n@class up.link\n */\n\n(function() {\n  up.link = (function($) {\n    var DEFAULT_FOLLOW_VARIANT, addFollowVariant, allowDefault, defaultFollow, defaultPreload, follow, followMethod, followVariantForLink, followVariants, isFollowable, isSafe, makeFollowable, shouldProcessEvent, u, visit;\n    u = up.util;\n\n    /***\n    Visits the given URL without a full page load.\n    This is done by fetching `url` through an AJAX request\n    and [replacing](/up.replace) the current `<body>` element with the response's `<body>` element.\n    \n    For example, this would fetch the `/users` URL:\n    \n        up.visit('/users')\n    \n    @function up.visit\n    @param {string} url\n      The URL to visit.\n    @param {string} [options.target='body']\n      The selector to replace.\n    @param {Object} [options]\n      See options for [`up.replace()`](/up.replace)\n    @stable\n     */\n    visit = function(url, options) {\n      var selector;\n      options = u.options(options);\n      selector = u.option(options.target, 'body');\n      return up.replace(selector, url, options);\n    };\n\n    /***\n    Follows the given link via AJAX and [replaces](/up.replace) the current page\n    with HTML from the response.\n    \n    By default the page's `<body>` element will be replaced.\n    If the link has an attribute like [`[up-target]`](/up-target)\n    or [`[up-modal]`](/a-up-modal), the corresponding UJS behavior will be activated\n    just as if the user had clicked on the link.\n    \n    Emits the event [`up:link:follow`](/up:link:follow).\n    \n    \\#\\#\\# Examples\n    \n    Let's say you have a link with an [`a[up-target]`](/a-up-target) attribute:\n    \n        <a href=\"/users\" up-target=\".main\">Users</a>\n    \n    Calling `up.follow()` with this link will replace the page's `.main` fragment\n    as if the user had clicked on the link:\n    \n        var $link = $('a:first');\n        up.follow($link);\n    \n    @function up.follow\n    @param {Element|jQuery|string} linkOrSelector\n      An element or selector which is either an `<a>` tag or any element with an `up-href` attribute.\n    @param {string} [options.target]\n      The selector to replace.\n    \n      Defaults to the link's `[up-target]`, `[up-modal]` or `[up-popup]` attribute.\n      If no target is given, the `<body>` element will be replaced.\n    @param {String} [options.url]\n      The URL to navigate to.\n    \n      Defaults to the link's `[up-href]` or `[href]` attribute.\n    @param {boolean|string} [options.reveal=true]\n      Whether to [reveal](/up.reveal) the target fragment after it was replaced.\n    \n      You can also pass a CSS selector for the element to reveal.\n    @param {boolean|string} [options.failReveal=true]\n      Whether to [reveal](/up.reveal) the target fragment when the server responds with an error.\n    \n      You can also pass a CSS selector for the element to reveal.\n    @return {Promise}\n      A promise that will be fulfilled when the link destination\n      has been loaded and rendered.\n    @stable\n     */\n    follow = function(linkOrSelector, options) {\n      var $link, variant;\n      $link = $(linkOrSelector);\n      variant = followVariantForLink($link);\n      return variant.followLink($link, options);\n    };\n\n    /***\n    This event is [emitted](/up.emit) when a link is [followed](/up.follow) through Unpoly.\n    \n    The event is emitted on the `<a>` element that is being followed.\n    \n    @event up:link:follow\n    @param {jQuery} event.$link\n      The link element that will be followed.\n    @param event.preventDefault()\n      Event listeners may call this method to prevent the link from being followed.\n    @stable\n     */\n\n    /***\n    @function defaultFollow\n    @internal\n     */\n    defaultFollow = function(linkOrSelector, options) {\n      var $link, target, url;\n      $link = $(linkOrSelector);\n      options = u.options(options);\n      url = u.option(options.url, $link.attr('up-href'), $link.attr('href'));\n      target = u.option(options.target, $link.attr('up-target'));\n      options.failTarget = u.option(options.failTarget, $link.attr('up-fail-target'));\n      options.fallback = u.option(options.fallback, $link.attr('up-fallback'));\n      options.transition = u.option(options.transition, u.castedAttr($link, 'up-transition'), 'none');\n      options.failTransition = u.option(options.failTransition, u.castedAttr($link, 'up-fail-transition'), 'none');\n      options.history = u.option(options.history, u.castedAttr($link, 'up-history'));\n      options.reveal = u.option(options.reveal, u.castedAttr($link, 'up-reveal'), true);\n      options.failReveal = u.option(options.failReveal, u.castedAttr($link, 'up-fail-reveal'), true);\n      options.cache = u.option(options.cache, u.castedAttr($link, 'up-cache'));\n      options.restoreScroll = u.option(options.restoreScroll, u.castedAttr($link, 'up-restore-scroll'));\n      options.method = followMethod($link, options);\n      options.origin = u.option(options.origin, $link);\n      options.layer = u.option(options.layer, $link.attr('up-layer'), 'auto');\n      options.failLayer = u.option(options.failLayer, $link.attr('up-fail-layer'), 'auto');\n      options.confirm = u.option(options.confirm, $link.attr('up-confirm'));\n      options = u.merge(options, up.motion.animateOptions(options, $link));\n      return up.browser.whenConfirmed(options).then(function() {\n        return up.replace(target, url, options);\n      });\n    };\n    defaultPreload = function($link, options) {\n      options = u.options(options);\n      options.preload = true;\n      return defaultFollow($link, options);\n    };\n\n    /***\n    Returns the HTTP method that should be used when following the given link.\n    \n    Looks at the link's `up-method` or `data-method` attribute.\n    Defaults to `\"get\"`.\n    \n    @function up.link.followMethod\n    @param linkOrSelector\n    @param options.method {string}\n    @internal\n     */\n    followMethod = function(linkOrSelector, options) {\n      var $link;\n      $link = $(linkOrSelector);\n      options = u.options(options);\n      return u.option(options.method, $link.attr('up-method'), $link.attr('data-method'), 'get').toUpperCase();\n    };\n\n    /***\n    No-op that is called when we allow a browser's default action to go through,\n    so we can spy on it in unit tests. See `link_spec.js`.\n    \n    @function allowDefault\n    @internal\n     */\n    allowDefault = function(event) {};\n    followVariants = [];\n\n    /***\n    Registers the given handler for links with the given selector.\n    \n    This does more than a simple `click` handler:\n    \n    - It also handles `[up-instant]`\n    - It also handles `[up-href]`\n    \n    @function up.link.addFollowVariant\n    @param {string} simplifiedSelector\n      A selector without `a` or `[up-href]`, e.g. `[up-target]`\n    @param {Function(jQuery, Object)} options.follow\n    @param {Function(jQuery, Object)} options.preload\n    @internal\n     */\n    addFollowVariant = function(simplifiedSelector, options) {\n      var variant;\n      variant = new up.FollowVariant(simplifiedSelector, options);\n      followVariants.push(variant);\n      variant.registerEvents();\n      return variant;\n    };\n\n    /***\n    Returns whether the given link will be handled by Unpoly instead of making a full page load.\n    \n    A link will be handled by Unpoly if it has an attribute\n    like `up-target` or `up-modal`.\n    \n    @function up.link.isFollowable\n    @param {Element|jQuery|string} linkOrSelector\n      The link to check.\n    @experimental\n     */\n    isFollowable = function(link) {\n      return !!followVariantForLink(link, {\n        \"default\": false\n      });\n    };\n\n    /***\n    Returns the handler function that can be used to follow the given link.\n    E.g. it wil return a handler calling `up.modal.follow` if the link is a `[up-modal]`,\n    but a handler calling `up.link.follow` if the links is `[up-target]`.\n    \n    @param {Element|jQuery|string}\n    @return {Function(jQuery)}\n    @internal\n     */\n    followVariantForLink = function(linkOrSelector, options) {\n      var $link, variant;\n      options = u.options(options);\n      $link = $(linkOrSelector);\n      variant = u.detect(followVariants, function(variant) {\n        return variant.matchesLink($link);\n      });\n      if (options[\"default\"] !== false) {\n        variant || (variant = DEFAULT_FOLLOW_VARIANT);\n      }\n      return variant;\n    };\n\n    /***\n    Makes sure that the given link will be handled by Unpoly instead of making a full page load.\n    \n    This is done by giving the link an `up-follow` attribute\n    unless it already have it an attribute like `up-target` or `up-modal`.\n    \n    @function up.link.makeFollowable\n    @param {Element|jQuery|string} linkOrSelector\n      The link to process.\n    @experimental\n     */\n    makeFollowable = function(link) {\n      var $link;\n      $link = $(link);\n      if (!isFollowable($link)) {\n        return $link.attr('up-follow', '');\n      }\n    };\n    shouldProcessEvent = function(event, $link) {\n      var $betterTarget, target;\n      target = event.target;\n      if (!u.isUnmodifiedMouseEvent(event)) {\n        return false;\n      }\n      if (target === $link.get(0)) {\n        return true;\n      }\n      $betterTarget = $(target).closest(\"a, [up-href], \" + (up.form.fieldSelector())).not($link);\n      if ($betterTarget.length) {\n        return false;\n      }\n      return true;\n    };\n\n    /***\n    Returns whether the given link has a [safe](https://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9.1.1)\n    HTTP method like `GET`.\n    \n    @function up.link.isSafe\n    @experimental\n     */\n    isSafe = function(selectorOrLink, options) {\n      var $link, method;\n      $link = $(selectorOrLink);\n      method = followMethod($link, options);\n      return up.proxy.isSafeMethod(method);\n    };\n\n    /***\n    Follows this link via AJAX and replaces a CSS selector in the current page\n    with corresponding elements from a new page fetched from the server:\n    \n        <a href=\"/posts/5\" up-target=\".main\">Read post</a>\n    \n    \\#\\#\\# Updating multiple fragments\n    \n    You can update multiple fragments from a single request by separating\n    separators with a comma (like in CSS). E.g. if opening a post should\n    also update a bubble showing the number of unread posts, you might\n    do this:\n    \n        <a href=\"/posts/5\" up-target=\".main, .unread-count\">Read post</a>\n    \n    \\#\\#\\# Appending or prepending content\n    \n    By default Unpoly will replace the given selector with the same\n    selector from a freshly fetched page. Instead of replacing you\n    can *append* the loaded content to the existing content by using the\n    `:after` pseudo selector. In the same fashion, you can use `:before`\n    to indicate that you would like the *prepend* the loaded content.\n    \n    A practical example would be a paginated list of items. Below the list is\n    a button to load the next page. You can append to the existing list\n    by using `:after` in the `up-target` selector like this:\n    \n        <ul class=\"tasks\">\n          <li>Wash car</li>\n          <li>Purchase supplies</li>\n          <li>Fix tent</li>\n        </ul>\n    \n        <a href=\"/page/2\" class=\"next-page\" up-target=\".tasks:after, .next-page\">\n          Load more tasks\n        </a>\n    \n    \\#\\#\\# Following elements that are no links\n    \n    You can also use `[up-target]` to turn an arbitrary element into a link.\n    In this case, put the link's destination into the `up-href` attribute:\n    \n        <button up-target=\".main\" up-href=\"/foo/bar\">Go</button>\n    \n    Note that using any element other than `<a>` will prevent users from\n    opening the destination in a new tab.\n    \n    @selector a[up-target]\n    @param {string} up-target\n      The CSS selector to replace\n    \n      Inside the CSS selector you may refer to this link as `&` ([like in Sass](https://sass-lang.com/documentation/file.SASS_REFERENCE.html#parent-selector)).\n    @param {string} [up-method='get']\n      The HTTP method to use for the request.\n    @param {string} [up-transition='none']\n      The [transition](/up.motion) to use for morphing between the old and new elements.\n    @param [up-fail-target='body']\n      The CSS selector to replace if the server responds with an error.\n    \n      Inside the CSS selector you may refer to this link as `&` ([like in Sass](https://sass-lang.com/documentation/file.SASS_REFERENCE.html#parent-selector)).\n    @param {string} [up-fail-transition='none']\n      The [transition](/up.motion) to use for morphing between the old and new elements\n      when the server responds with an error.\n    @param {string} [up-fallback]\n      The selector to update when the original target was not found in the page.\n    @param {string} [up-href]\n      The destination URL to follow.\n      If omitted, the the link's `href` attribute will be used.\n    @param {string} [up-confirm]\n      A message that will be displayed in a cancelable confirmation dialog\n      before the link is followed.\n    @param {string} [up-reveal='true']\n      Whether to reveal the target element after it was replaced.\n    \n      You can also pass a CSS selector for the element to reveal.\n      Inside the CSS selector you may refer to this link as `&` ([like in Sass](https://sass-lang.com/documentation/file.SASS_REFERENCE.html#parent-selector)).\n    @param {string} [up-fail-reveal='true']\n      Whether to reveal the target element when the server responds with an error.\n    \n      You can also pass a CSS selector for the element to reveal.\n      Inside the CSS selector you may refer to this link as `&` ([like in Sass](https://sass-lang.com/documentation/file.SASS_REFERENCE.html#parent-selector)).\n    @param {string} [up-restore-scroll='false']\n      Whether to restore previously known scroll position of all viewports\n      within the target selector.\n    @param {string} [up-cache]\n      Whether to force the use of a cached response (`true`)\n      or never use the cache (`false`)\n      or make an educated guess (default).\n    @param {string} [up-layer='auto']\n      The name of the layer that ought to be updated. Valid values are\n      `'auto'`, `'page'`, `'modal'` and `'popup'`.\n    \n      If set to `'auto'` (default), Unpoly will try to find a match in the link's layer.\n      If no match was found in that layer,\n      Unpoly will search in other layers, starting from the topmost layer.\n    @param {string} [up-fail-layer='auto']\n      The name of the layer that ought to be updated if the server sends a\n      non-200 status code.\n    @param [up-history]\n      Whether to push an entry to the browser history when following the link.\n    \n      Set this to `'false'` to prevent the URL bar from being updated.\n      Set this to a URL string to update the history with the given URL.\n    @stable\n     */\n    DEFAULT_FOLLOW_VARIANT = addFollowVariant('[up-target], [up-follow]', {\n      follow: function($link, options) {\n        return defaultFollow($link, options);\n      },\n      preload: function($link, options) {\n        return defaultPreload($link, options);\n      }\n    });\n\n    /***\n    If applied on a link, follows this link via AJAX and replaces the\n    current `<body>` element with the response's `<body>` element.\n    \n    To only update a fragment instead of the entire page, see\n    [`a[up-target]`](/a-up-target).\n    \n    \\#\\#\\# Example\n    \n        <a href=\"/users\" up-follow>User list</a>\n    \n    \\#\\#\\# Turn any element into a link\n    \n    You can also use `[up-follow]` to turn an arbitrary element into a link.\n    In this case, put the link's destination into the `up-href` attribute:\n    \n        <span up-follow up-href=\"/foo/bar\">Go</span>\n    \n    Note that using any element other than `<a>` will prevent users from\n    opening the destination in a new tab.\n    \n    @selector a[up-follow]\n    \n    @param {string} [up-method='get']\n      The HTTP method to use for the request.\n    @param [up-fail-target='body']\n      The selector to replace if the server responds with an error.\n    @param {string} [up-fallback]\n      The selector to update when the original target was not found in the page.\n    @param {string} [up-transition='none']\n      The [transition](/up.motion) to use for morphing between the old and new elements.\n    @param {string} [up-fail-transition='none']\n      The [transition](/up.motion) to use for morphing between the old and new elements\n      when the server responds with an error.\n    @param [up-href]\n      The destination URL to follow.\n      If omitted, the the link's `href` attribute will be used.\n    @param {string} [up-confirm]\n      A message that will be displayed in a cancelable confirmation dialog\n      before the link is followed.\n    @param {string} [up-history]\n      Whether to push an entry to the browser history when following the link.\n    \n      Set this to `'false'` to prevent the URL bar from being updated.\n      Set this to a URL string to update the history with the given URL.\n    @param [up-restore-scroll='false']\n      Whether to restore the scroll position of all viewports\n      within the response.\n    @stable\n     */\n\n    /***\n    By adding an `up-instant` attribute to a link, the destination will be\n    fetched on `mousedown` instead of `click` (`mouseup`).\n    \n        <a href=\"/users\" up-target=\".main\" up-instant>User list</a>\n    \n    This will save precious milliseconds that otherwise spent\n    on waiting for the user to release the mouse button. Since an\n    AJAX request will be triggered right way, the interaction will\n    appear faster.\n    \n    Note that using `[up-instant]` will prevent a user from canceling a link\n    click by moving the mouse away from the interaction area. However, for\n    navigation actions this isn't needed. E.g. popular operation\n    systems switch tabs on `mousedown` instead of `click`.\n    \n    `up-instant` will also work for links that open [modals](/up.modal) or [popups](/up.popup).\n    \n    @selector a[up-instant]\n    @stable\n     */\n\n    /***\n    Marks up the current link to be followed *as fast as possible*.\n    \n    This is done by:\n    \n    - [Following the link through AJAX](/a-up-target) instead of a full page load\n    - [Preloading the link's destination URL](/a-up-preload)\n    - [Triggering the link on `mousedown`](/a-up-instant) instead of on `click`\n    \n    Use `up-dash` like this:\n    \n        <a href=\"/users\" up-dash=\".main\">User list</a>\n    \n    Note that this is shorthand for:\n    \n        <a href=\"/users\" up-target=\".main\" up-instant up-preload>User list</a>\n    \n    @selector a[up-dash]\n    @stable\n     */\n    up.macro('[up-dash]', function($element) {\n      var newAttrs, target;\n      target = u.castedAttr($element, 'up-dash');\n      $element.removeAttr('up-dash');\n      newAttrs = {\n        'up-preload': '',\n        'up-instant': ''\n      };\n      if (target === true) {\n        makeFollowable($element);\n      } else {\n        newAttrs['up-target'] = target;\n      }\n      return u.setMissingAttrs($element, newAttrs);\n    });\n\n    /***\n    Add an `[up-expand]` attribute to any element that contains a link\n    in order to enlarge the link's click area.\n    \n    `[up-expand]` honors all the UJS behavior in expanded links\n    ([`a[up-target]`](/a-up-target), [`a[up-instant]`](/a-up-instant), [`a[up-preload]`](/a-up-preload), etc.).\n    \n    \\#\\#\\# Example\n    \n        <div class=\"notification\" up-expand>\n          Record was saved!\n          <a href=\"/records\">Close</a>\n        </div>\n    \n    In the example above, clicking anywhere within `.notification` element\n    would [follow](/up.follow) the *Close* link.\n    \n    `up-expand` also expands links that open [modals](/up.modal) or [popups](/up.popup).\n    \n    \\#\\#\\# Elements with multiple contained links\n    \n    If a container contains more than one link, you can set the value of the\n    `up-expand` attribute to a CSS selector to define which link should be expanded:\n    \n        <div class=\"notification\" up-expand=\".close\">\n          Record was saved!\n          <a class=\"details\" href=\"/records/5\">Details</a>\n          <a class=\"close\" href=\"/records\">Close</a>\n        </div>\n    \n    \\#\\#\\# Limitations\n    \n    `[up-expand]` has some limitations for advanced browser users:\n    \n    - Users won't be able to right-click the expanded area to open a context menu\n    - Users won't be able to CTRL+click the expanded area to open a new tab\n    \n    To overcome these limitations, consider nesting the entire clickable area in an actual `<a>` tag.\n    [It's OK to put block elements inside an anchor tag](https://makandracards.com/makandra/43549-it-s-ok-to-put-block-elements-inside-an-a-tag).\n    \n    @selector [up-expand]\n    @param {string} [up-expand]\n      A CSS selector that defines which containing link should be expanded.\n    \n      If omitted, the first contained link will be expanded.\n    @stable\n     */\n    up.macro('[up-expand]', function($area) {\n      var $childLinks, attribute, i, len, link, name, newAttrs, ref, selector, upAttributePattern;\n      $childLinks = $area.find('a, [up-href]');\n      if (selector = $area.attr('up-expand')) {\n        $childLinks = $childLinks.filter(selector);\n      }\n      if (link = $childLinks.get(0)) {\n        upAttributePattern = /^up-/;\n        newAttrs = {};\n        newAttrs['up-href'] = $(link).attr('href');\n        ref = link.attributes;\n        for (i = 0, len = ref.length; i < len; i++) {\n          attribute = ref[i];\n          name = attribute.name;\n          if (name.match(upAttributePattern)) {\n            newAttrs[name] = attribute.value;\n          }\n        }\n        u.setMissingAttrs($area, newAttrs);\n        $area.removeAttr('up-expand');\n        return makeFollowable($area);\n      }\n    });\n    return {\n      visit: visit,\n      follow: follow,\n      makeFollowable: makeFollowable,\n      isSafe: isSafe,\n      isFollowable: isFollowable,\n      shouldProcessEvent: shouldProcessEvent,\n      followMethod: followMethod,\n      addFollowVariant: addFollowVariant,\n      followVariantForLink: followVariantForLink,\n      allowDefault: allowDefault\n    };\n  })(jQuery);\n\n  up.visit = up.link.visit;\n\n  up.follow = up.link.follow;\n\n}).call(this);\n\n/***\nForms\n=====\n  \nUnpoly comes with functionality to [submit](/form-up-target) and [validate](/input-up-validate)\nforms without leaving the current page. This means you can replace page fragments,\nopen dialogs with sub-forms, etc. all without losing form state.\n\n@class up.form\n */\n\n(function() {\n  var slice = [].slice;\n\n  up.form = (function($) {\n    var autosubmit, config, fieldSelector, findSwitcherForTarget, observe, observeField, reset, resolveValidateTarget, submit, submitButtonSelector, switchTarget, switchTargets, switcherValues, u, validate;\n    u = up.util;\n\n    /***\n    Sets default options for form submission and validation.\n    \n    @property up.form.config\n    @param {number} [config.observeDelay=0]\n      The number of miliseconds to wait before [`up.observe()`](/up.observe) runs the callback\n      after the input value changes. Use this to limit how often the callback\n      will be invoked for a fast typist.\n    @param {Array} [config.validateTargets=['[up-fieldset]:has(&)', 'fieldset:has(&)', 'label:has(&)', 'form:has(&)']]\n      An array of CSS selectors that are searched around a form field\n      that wants to [validate](/up.validate). The first matching selector\n      will be updated with the validation messages from the server.\n    \n      By default this looks for a `<fieldset>`, `<label>` or `<form>`\n      around the validating input field, or any element with an\n      `up-fieldset` attribute.\n    @param {string} [config.fields]\n      An array of CSS selectors that represent form fields, such as `input` or `select`.\n    @param {string} [config.submitButtons]\n      An array of CSS selectors that represent submit buttons, such as `input[type=submit]`.\n    @stable\n     */\n    config = u.config({\n      validateTargets: ['[up-fieldset]:has(&)', 'fieldset:has(&)', 'label:has(&)', 'form:has(&)'],\n      fields: ['select', 'input:not([type=submit]):not([type=image])', 'button[type]:not([type=submit])', 'textarea'],\n      submitButtons: ['input[type=submit]', 'input[type=image]', 'button[type=submit]', 'button:not([type])'],\n      observeDelay: 0\n    });\n    reset = function() {\n      return config.reset();\n    };\n\n    /***\n    @function up.form.fieldSelector\n    @internal\n     */\n    fieldSelector = function() {\n      return config.fields.join(',');\n    };\n\n    /***\n    @function up.form.submitButtonSelector\n    @internal\n     */\n    submitButtonSelector = function() {\n      return config.submitButtons.join(',');\n    };\n\n    /***\n    Submits a form via AJAX and updates a page fragment with the response.\n    \n        up.submit('form.new-user', { target: '.main' })\n    \n    Instead of loading a new page, the form is submitted via AJAX.\n    The response is parsed for a CSS selector and the matching elements will\n    replace corresponding elements on the current page.\n    \n    The unobtrusive variant of this is the [`form[up-target]`](/form-up-target) selector.\n    See the documentation for [`form[up-target]`](/form-up-target) for more\n    information on how AJAX form submissions work in Unpoly.\n    \n    Emits the event [`up:form:submit`](/up:form:submit).\n    \n    @function up.submit\n    @param {Element|jQuery|string} formOrSelector\n      A reference or selector for the form to submit.\n      If the argument points to an element that is not a form,\n      Unpoly will search its ancestors for the closest form.\n    @param {string} [options.url]\n      The URL where to submit the form.\n      Defaults to the form's `action` attribute, or to the current URL of the browser window.\n    @param {string} [options.method='post']\n      The HTTP method used for the form submission.\n      Defaults to the form's `up-method`, `data-method` or `method` attribute, or to `'post'`\n      if none of these attributes are given.\n    @param {string} [options.target]\n      The CSS selector to update when the form submission succeeds (server responds with status 200).\n      Defaults to the form's `up-target` attribute.\n    \n      Inside the CSS selector you may refer to the form as `&` ([like in Sass](https://sass-lang.com/documentation/file.SASS_REFERENCE.html#parent-selector)).\n    @param {string} [options.failTarget]\n      The CSS selector to update when the form submission fails (server responds with non-200 status).\n      Defaults to the form's `up-fail-target` attribute, or to an auto-generated\n      selector that matches the form itself.\n    \n      Inside the CSS selector you may refer to the form as `&` ([like in Sass](https://sass-lang.com/documentation/file.SASS_REFERENCE.html#parent-selector)).\n    @param {string} [options.fallback]\n      The selector to update when the original target was not found in the page.\n      Defaults to the form's `up-fallback` attribute.\n    @param {boolean|string} [options.history=true]\n      Successful form submissions will add a history entry and change the browser's\n      location bar if the form either uses the `GET` method or the response redirected\n      to another page (this requires the `unpoly-rails` gem).\n      If you want to prevent history changes in any case, set this to `false`.\n      If you pass a string, it is used as the URL for the browser history.\n    @param {string} [options.transition='none']\n      The transition to use when a successful form submission updates the `options.target` selector.\n      Defaults to the form's `up-transition` attribute, or to `'none'`.\n    @param {string} [options.failTransition='none']\n      The transition to use when a failed form submission updates the `options.failTarget` selector.\n      Defaults to the form's `up-fail-transition` attribute, or to `options.transition`, or to `'none'`.\n    @param {number} [options.duration]\n      The duration of the transition. See [`up.morph()`](/up.morph).\n    @param {number} [options.delay]\n      The delay before the transition starts. See [`up.morph()`](/up.morph).\n    @param {string} [options.easing]\n      The timing function that controls the transition's acceleration. [`up.morph()`](/up.morph).\n    @param {Element|string} [options.reveal=true]\n      Whether to reveal the target fragment after it was replaced.\n    \n      You can also pass a CSS selector for the element to reveal.\n    @param {boolean|string} [options.failReveal=true]\n      Whether to [reveal](/up.reveal) the target fragment when the server responds with an error.\n    \n      You can also pass a CSS selector for the element to reveal.\n    @param {boolean} [options.restoreScroll]\n      If set to `true`, this will attempt to [`restore scroll positions`](/up.restoreScroll)\n      previously seen on the destination URL.\n    @param {boolean} [options.cache]\n      Whether to force the use of a cached response (`true`)\n      or never use the cache (`false`)\n      or make an educated guess (`undefined`).\n    \n      By default only responses to `GET` requests are cached\n      for a few minutes.\n    @param {Object} [options.headers={}]\n      An object of additional header key/value pairs to send along\n      with the request.\n    @param {string} [options.layer='auto']\n      The name of the layer that ought to be updated. Valid values are\n      `'auto'`, `'page'`, `'modal'` and `'popup'`.\n    \n      If set to `'auto'` (default), Unpoly will try to find a match in the form's layer.\n    @param {string} [options.failLayer='auto']\n      The name of the layer that ought to be updated if the server sends a non-200 status code.\n    @return {Promise}\n      A promise for the successful form submission.\n    @stable\n     */\n    submit = function(formOrSelector, options) {\n      var $form, target, url;\n      $form = $(formOrSelector).closest('form');\n      options = u.options(options);\n      target = u.option(options.target, $form.attr('up-target'), 'body');\n      url = u.option(options.url, $form.attr('action'), up.browser.url());\n      options.failTarget = u.option(options.failTarget, $form.attr('up-fail-target')) || u.selectorForElement($form);\n      options.reveal = u.option(options.reveal, u.castedAttr($form, 'up-reveal'), true);\n      options.failReveal = u.option(options.failReveal, u.castedAttr($form, 'up-fail-reveal'), true);\n      options.fallback = u.option(options.fallback, $form.attr('up-fallback'));\n      options.history = u.option(options.history, u.castedAttr($form, 'up-history'), true);\n      options.transition = u.option(options.transition, u.castedAttr($form, 'up-transition'), 'none');\n      options.failTransition = u.option(options.failTransition, u.castedAttr($form, 'up-fail-transition'), 'none');\n      options.method = u.option(options.method, $form.attr('up-method'), $form.attr('data-method'), $form.attr('method'), 'post').toUpperCase();\n      options.headers = u.option(options.headers, {});\n      options.cache = u.option(options.cache, u.castedAttr($form, 'up-cache'));\n      options.restoreScroll = u.option(options.restoreScroll, u.castedAttr($form, 'up-restore-scroll'));\n      options.origin = u.option(options.origin, $form);\n      options.layer = u.option(options.layer, $form.attr('up-layer'), 'auto');\n      options.failLayer = u.option(options.failLayer, $form.attr('up-fail-layer'), 'auto');\n      options.params = up.params.fromForm($form);\n      options = u.merge(options, up.motion.animateOptions(options, $form));\n      if (options.validate) {\n        options.headers || (options.headers = {});\n        options.transition = false;\n        options.failTransition = false;\n        options.headers[up.protocol.config.validateHeader] = options.validate;\n      }\n      return up.bus.whenEmitted('up:form:submit', {\n        message: 'Submitting form',\n        $form: $form,\n        $element: $form\n      }).then(function() {\n        var promise;\n        up.feedback.start($form);\n        if (!(up.browser.canPushState() || options.history === false)) {\n          $form.get(0).submit();\n          return u.unresolvablePromise();\n        }\n        promise = up.replace(target, url, options);\n        u.always(promise, function() {\n          return up.feedback.stop($form);\n        });\n        return promise;\n      });\n    };\n\n    /***\n    This event is [emitted](/up.emit) when a form is [submitted](/up.submit) through Unpoly.\n    \n    @event up:form:submit\n    @param {jQuery} event.$form\n      The `<form>` element that will be submitted.\n    @param event.preventDefault()\n      Event listeners may call this method to prevent the form from being submitted.\n    @stable\n     */\n\n    /***\n    Observes form fields and runs a callback when a value changes.\n    \n    This is useful for observing text fields while the user is typing.\n    \n    The unobtrusive variant of this is the [`up-observe`](/up-observe) attribute.\n    \n    \\#\\#\\# Example\n    \n    The following would print to the console whenever an input field changes:\n    \n        up.observe('input.query', function(value, $input) {\n          console.log('Query is now ' + value);\n        });\n    \n    Instead of a single form field, you can also pass multiple fields,\n    a `<form>` or any container that contains form fields.\n    The callback will be run if any of the given fields change.\n    \n    \\#\\#\\# Preventing concurrency\n    \n    Making network requests whenever a form field changes can cause\n    [concurrency issues](https://makandracards.com/makandra/961-concurrency-issues-with-find-as-you-type-boxes).\n    Since `up.observe()` can trigger many requests in a short period of time,\n    the responses might not arrive in the same order.\n    \n    To mitigate this, `up.observe()` will try to never run a callback\n    before the previous callback has completed.\n    For this your callback code must return a promise that resolves\n    when your request completes.\n    \n    The following would submit a form whenever an input field changes,\n    but never make more than one request at a time:\n    \n        up.observe('input.query', function(value, $input) {\n          var submitDone = up.submit($input);\n          return submitDone;\n        });\n    \n    Note that many Unpoly functions like [`up.submit()`](/up.submit) or\n    [`up.replace()`](/up.replace) return promises.\n    \n    \\#\\#\\# Debouncing\n    \n    If you are concerned about fast typists causing too much\n    load on your server, you can use a `delay` option to wait\n    a few miliseconds before executing the callback:\n    \n        up.observe('input', { delay: 100 }, function(value, $input) {\n          up.submit($input)\n        });\n    \n    @function up.observe\n    @param {Element|jQuery|string} selectorOrElement\n      The form fields that wiill be observed.\n    \n      You can pass one or more fields, a `<form>` or any container that contains form fields.\n      The callback will be run if any of the given fields change.\n    @param {number} [options.delay=up.form.config.observeDelay]\n      The number of miliseconds to wait before executing the callback\n      after the input value changes. Use this to limit how often the callback\n      will be invoked for a fast typist.\n    @param {Function(value, $field)|string} onChange\n      The callback to run when the field's value changes.\n      If given as a function, it must take two arguments (`value`, `$field`).\n      If given as a string, it will be evaled as JavaScript code in a context where\n      (`value`, `$field`) are set.\n    @return {Function}\n      A destructor function that removes the observe watch when called.\n    @stable\n     */\n    observe = function() {\n      var $element, $fields, callback, callbackArg, delay, destructors, extraArgs, options, rawCallback, selectorOrElement;\n      selectorOrElement = arguments[0], extraArgs = 2 <= arguments.length ? slice.call(arguments, 1) : [];\n      options = {};\n      callbackArg = void 0;\n      if (extraArgs.length === 1) {\n        callbackArg = extraArgs[0];\n      } else if (extraArgs.length > 1) {\n        options = u.options(extraArgs[0]);\n        callbackArg = extraArgs[1];\n      }\n      $element = $(selectorOrElement);\n      callback = null;\n      rawCallback = u.option(callbackArg, u.presentAttr($element, 'up-observe'));\n      if (u.isString(rawCallback)) {\n        callback = new Function('value', '$field', rawCallback);\n      } else {\n        callback = rawCallback || up.fail('up.observe: No change callback given');\n      }\n      delay = u.option(u.presentAttr($element, 'up-delay'), options.delay, config.observeDelay);\n      delay = parseInt(delay);\n      $fields = u.selectInSubtree($element, fieldSelector());\n      destructors = u.map($fields, function(field) {\n        return observeField($(field), delay, callback);\n      });\n      return u.sequence.apply(u, destructors);\n    };\n    observeField = function($field, delay, callback) {\n      var observer;\n      observer = new up.FieldObserver($field, {\n        delay: delay,\n        callback: callback\n      });\n      observer.start();\n      return observer.stop;\n    };\n\n    /***\n    [Observes](/up.observe) a field or form and submits the form when a value changes.\n    \n    Both the form and the changed field will be assigned a CSS class [`form-up-active`](/form-up-active)\n    while the autosubmitted form is processing.\n    \n    The unobtrusive variant of this is the [`up-autosubmit`](/form-up-autosubmit) attribute.\n    \n    @function up.autosubmit\n    @param {string|Element|jQuery} selectorOrElement\n      The field or form to observe.\n    @param {Object} [options]\n      See options for [`up.observe()`](/up.observe)\n    @return {Function}\n      A destructor function that removes the observe watch when called.\n    @stable\n     */\n    autosubmit = function(selectorOrElement, options) {\n      return observe(selectorOrElement, options, function(value, $field) {\n        var $form;\n        $form = $field.closest('form');\n        return up.feedback.start($field, function() {\n          return submit($form);\n        });\n      });\n    };\n    resolveValidateTarget = function($field, options) {\n      var target;\n      target = u.option(options.target, $field.attr('up-validate'));\n      if (u.isBlank(target)) {\n        target || (target = u.detect(config.validateTargets, function(defaultTarget) {\n          var resolvedDefault;\n          resolvedDefault = up.dom.resolveSelector(defaultTarget, options.origin);\n          return $field.closest(resolvedDefault).length;\n        }));\n      }\n      if (u.isBlank(target)) {\n        up.fail('Could not find default validation target for %o (tried ancestors %o)', $field.get(0), config.validateTargets);\n      }\n      if (!u.isString(target)) {\n        target = u.selectorForElement(target);\n      }\n      return target;\n    };\n\n    /***\n    Performs a server-side validation of a form field.\n    \n    `up.validate()` submits the given field's form with an additional `X-Up-Validate`\n    HTTP header. Upon seeing this header, the server is expected to validate (but not save)\n    the form submission and render a new copy of the form with validation errors.\n    \n    The unobtrusive variant of this is the [`input[up-validate]`](/input-up-validate) selector.\n    See the documentation for [`input[up-validate]`](/input-up-validate) for more information\n    on how server-side validation works in Unpoly.\n    \n    \\#\\#\\# Example\n    \n        up.validate('input[name=email]', { target: '.email-errors' })\n    \n    @function up.validate\n    @param {string|Element|jQuery} fieldOrSelector\n    \n    @param {string|Element|jQuery} [options.target]\n    @return {Promise}\n      A promise that is fulfilled when the server-side\n      validation is received and the form was updated.\n    @stable\n     */\n    validate = function(fieldOrSelector, options) {\n      var $field, $form, promise;\n      $field = $(fieldOrSelector);\n      options = u.options(options);\n      options.origin = $field;\n      options.target = resolveValidateTarget($field, options);\n      options.failTarget = options.target;\n      options.reveal = u.option(options.reveal, u.castedAttr($field, 'up-reveal'), false);\n      options.history = false;\n      options.headers = u.option(options.headers, {});\n      options.validate = $field.attr('name') || '__none__';\n      options = u.merge(options, up.motion.animateOptions(options, $field));\n      $form = $field.closest('form');\n      promise = up.submit($form, options);\n      return promise;\n    };\n    switcherValues = function($field) {\n      var $checkedButton, meta, value, values;\n      if ($field.is('input[type=checkbox]')) {\n        if ($field.is(':checked')) {\n          value = $field.val();\n          meta = ':checked';\n        } else {\n          meta = ':unchecked';\n        }\n      } else if ($field.is('input[type=radio]')) {\n        $checkedButton = $field.closest('form, body').find(\"input[type='radio'][name='\" + ($field.attr('name')) + \"']:checked\");\n        if ($checkedButton.length) {\n          meta = ':checked';\n          value = $checkedButton.val();\n        } else {\n          meta = ':unchecked';\n        }\n      } else {\n        value = $field.val();\n      }\n      values = [];\n      if (u.isPresent(value)) {\n        values.push(value);\n        values.push(':present');\n      } else {\n        values.push(':blank');\n      }\n      if (u.isPresent(meta)) {\n        values.push(meta);\n      }\n      return values;\n    };\n\n    /***\n    Shows or hides a target selector depending on the value.\n    \n    See [`input[up-switch]`](/input-up-switch) for more documentation and examples.\n    \n    This function does not currently have a very useful API outside\n    of our use for `up-switch`'s UJS behavior, that's why it's currently\n    still marked `@internal`.\n    \n    @function up.form.switchTargets\n    @param {string|Element|jQuery} fieldOrSelector\n    @param {string} [options.target]\n      The target selectors to switch.\n      Defaults to an `up-switch` attribute on the given field.\n    @internal\n     */\n    switchTargets = function(fieldOrSelector, options) {\n      var $switcher, fieldValues, targetSelector;\n      $switcher = $(fieldOrSelector);\n      options = u.options(options);\n      targetSelector = u.option(options.target, $switcher.attr('up-switch'));\n      u.isPresent(targetSelector) || up.fail(\"No switch target given for %o\", $switcher.get(0));\n      fieldValues = switcherValues($switcher);\n      return $(targetSelector).each(function() {\n        return switchTarget($(this), fieldValues);\n      });\n    };\n\n    /***\n    @internal\n     */\n    switchTarget = function(target, fieldValues) {\n      var $target, hideValues, show, showValues;\n      $target = $(target);\n      fieldValues || (fieldValues = switcherValues(findSwitcherForTarget($target)));\n      if (hideValues = $target.attr('up-hide-for')) {\n        hideValues = u.splitValues(hideValues);\n        show = u.intersect(fieldValues, hideValues).length === 0;\n      } else {\n        if (showValues = $target.attr('up-show-for')) {\n          showValues = u.splitValues(showValues);\n        } else {\n          showValues = [':present', ':checked'];\n        }\n        show = u.intersect(fieldValues, showValues).length > 0;\n      }\n      $target.toggle(show);\n      return $target.addClass('up-switched');\n    };\n\n    /***\n    @internal\n     */\n    findSwitcherForTarget = function($target) {\n      var $switchers, switcher;\n      $switchers = $('[up-switch]');\n      switcher = u.detect($switchers, function(switcher) {\n        var target;\n        target = $(switcher).attr('up-switch');\n        return $target.is(target);\n      });\n      if (switcher) {\n        return $(switcher);\n      } else {\n        return u.fail('Could not find [up-switch] field for %o', $target.get(0));\n      }\n    };\n\n    /***\n    Forms with an `up-target` attribute are [submitted via AJAX](/up.submit)\n    instead of triggering a full page reload.\n    \n        <form method=\"post\" action=\"/users\" up-target=\".main\">\n          ...\n        </form>\n    \n    The server response is searched for the selector given in `up-target`.\n    The selector content is then [replaced](/up.replace) in the current page.\n    \n    The programmatic variant of this is the [`up.submit()`](/up.submit) function.\n    \n    \\#\\#\\# Failed submission\n    \n    When the server was unable to save the form due to invalid params,\n    it will usually re-render an updated copy of the form with\n    validation messages.\n    \n    For Unpoly to be able to detect a failed form submission,\n    the form must be re-rendered with a non-200 HTTP status code.\n    We recommend to use either 400 (bad request) or\n    422 (unprocessable entity).\n    \n    In Ruby on Rails, you can pass a\n    [`:status` option to `render`](http://guides.rubyonrails.org/layouts_and_rendering.html#the-status-option)\n    for this:\n    \n        class UsersController < ApplicationController\n    \n          def create\n            user_params = params[:user].permit(:email, :password)\n            @user = User.new(user_params)\n            if @user.save?\n              sign_in @user\n            else\n              render 'form', status: :bad_request\n            end\n          end\n    \n        end\n    \n    Note that you can also use\n    [`input[up-validate]`](/input-up-validate) to perform server-side\n    validations while the user is completing fields.\n    \n    \\#\\#\\# Redirects\n    \n    Unpoly requires an additional response headers to detect redirects,\n    which are otherwise undetectable for an AJAX client.\n    \n    After the form's action performs a redirect, the next response should echo\n    the new request's URL as a response header `X-Up-Location`.\n    \n    If you are using Unpoly via the `unpoly-rails` gem, these headers\n    are set automatically for every request.\n    \n    \\#\\#\\# Giving feedback while the form is processing\n    \n    The `<form>` element will be assigned a CSS class [`up-active`](/form.up-active) while\n    the submission is loading.\n    \n    You can also [implement a spinner](/up.proxy/#spinners)\n    by [listening](/up.on) to the [`up:proxy:slow`](/up:proxy:slow)\n    and [`up:proxy:recover`](/up:proxy:recover) events.\n    \n    @selector form[up-target]\n    @param {string} up-target\n      The CSS selector to [replace](/up.replace) if the form submission is successful (200 status code).\n    \n      Inside the CSS selector you may refer to this form as `&` ([like in Sass](https://sass-lang.com/documentation/file.SASS_REFERENCE.html#parent-selector)).\n    @param {string} [up-fail-target]\n      The CSS selector to [replace](/up.replace) if the form submission is not successful (non-200 status code).\n    \n      Inside the CSS selector you may refer to this form as `&` ([like in Sass](https://sass-lang.com/documentation/file.SASS_REFERENCE.html#parent-selector)).\n    \n      If omitted, Unpoly will replace the `<form>` tag itself, assuming that the server has echoed the form with validation errors.\n    @param [up-fallback]\n      The selector to replace if the server responds with an error.\n    @param {string} [up-transition]\n      The animation to use when the form is replaced after a successful submission.\n    @param {string} [up-fail-transition]\n      The animation to use when the form is replaced after a failed submission.\n    @param [up-history]\n      Whether to push a browser history entry after a successful form submission.\n    \n      By default the form's target URL is used. If the form redirects to another URL,\n      the redirect target will be used.\n    \n      Set this to `'false'` to prevent the URL bar from being updated.\n      Set this to a URL string to update the history with the given URL.\n    @param {string} [up-method]\n      The HTTP method to be used to submit the form (`get`, `post`, `put`, `delete`, `patch`).\n      Alternately you can use an attribute `data-method`\n      ([Rails UJS](https://github.com/rails/jquery-ujs/wiki/Unobtrusive-scripting-support-for-jQuery))\n      or `method` (vanilla HTML) for the same purpose.\n    @param {string} [up-layer='auto']\n      The name of the layer that ought to be updated. Valid values are\n      `'auto'`, `'page'`, `'modal'` and `'popup'`.\n    \n      If set to `'auto'` (default), Unpoly will try to find a match in the form's layer.\n      If no match was found in that layer,\n      Unpoly will search in other layers, starting from the topmost layer.\n    @param {string} [up-fail-layer='auto']\n      The name of the layer that ought to be updated if the server sends a\n      non-200 status code.\n    @param {string} [up-reveal='true']\n      Whether to reveal the target element after it was replaced.\n    \n      You can also pass a CSS selector for the element to reveal.\n      Inside the CSS selector you may refer to the form as `&` ([like in Sass](https://sass-lang.com/documentation/file.SASS_REFERENCE.html#parent-selector)).\n    @param {string} [up-fail-reveal='true']\n      Whether to reveal the target element when the server responds with an error.\n    \n      You can also pass a CSS selector for the element to reveal. You may use this, for example,\n      to reveal the first validation error message:\n    \n          <form up-target=\".content\" up-fail-reveal=\".error\">\n            ...\n          </form>\n    \n      Inside the CSS selector you may refer to the form as `&` ([like in Sass](https://sass-lang.com/documentation/file.SASS_REFERENCE.html#parent-selector)).\n    @param {string} [up-restore-scroll='false']\n      Whether to restore previously known scroll position of all viewports\n      within the target selector.\n    @param {string} [up-cache]\n      Whether to force the use of a cached response (`true`)\n      or never use the cache (`false`)\n      or make an educated guess (`undefined`).\n    \n      By default only responses to `GET` requests are cached for a few minutes.\n    @stable\n     */\n    up.on('submit', 'form[up-target]', function(event, $form) {\n      up.bus.consumeAction(event);\n      return u.muteRejection(submit($form));\n    });\n\n    /***\n    When a form field with this attribute is changed, the form is validated on the server\n    and is updated with validation messages.\n    \n    To validate the form, Unpoly will submit the form with an additional `X-Up-Validate` HTTP header.\n    When seeing this header, the server is expected to validate (but not save)\n    the form submission and render a new copy of the form with validation errors.\n    \n    The programmatic variant of this is the [`up.validate()`](/up.validate) function.\n    \n    \\#\\#\\# Example\n    \n    Let's look at a standard registration form that asks for an e-mail and password:\n    \n        <form action=\"/users\">\n    \n          <label>\n            E-mail: <input type=\"text\" name=\"email\" />\n          </label>\n    \n          <label>\n            Password: <input type=\"password\" name=\"password\" />\n          </label>\n    \n          <button type=\"submit\">Register</button>\n    \n        </form>\n    \n    When the user changes the `email` field, we want to validate that\n    the e-mail address is valid and still available. Also we want to\n    change the `password` field for the minimum required password length.\n    We can do this by giving both fields an `up-validate` attribute:\n    \n        <form action=\"/users\">\n    \n          <label>\n            E-mail: <input type=\"text\" name=\"email\" up-validate />\n          </label>\n    \n          <label>\n            Password: <input type=\"password\" name=\"password\" up-validate />\n          </label>\n    \n          <button type=\"submit\">Register</button>\n    \n        </form>\n    \n    Whenever a field with `up-validate` changes, the form is POSTed to\n    `/users` with an additional `X-Up-Validate` HTTP header.\n    When seeing this header, the server is expected to validate (but not save)\n    the form submission and render a new copy of the form with validation errors.\n    \n    In Ruby on Rails the processing action should behave like this:\n    \n        class UsersController < ApplicationController\n    \n           * This action handles POST /users\n          def create\n            user_params = params[:user].permit(:email, :password)\n            @user = User.new(user_params)\n            if request.headers['X-Up-Validate']\n              @user.valid?  # run validations, but don't save to the database\n              render 'form' # render form with error messages\n            elsif @user.save?\n              sign_in @user\n            else\n              render 'form', status: :bad_request\n            end\n          end\n    \n        end\n    \n    Note that if you're using the `unpoly-rails` gem you can simply say `up.validate?`\n    instead of manually checking for `request.headers['X-Up-Validate']`.\n    \n    The server now renders an updated copy of the form with eventual validation errors:\n    \n        <form action=\"/users\">\n    \n          <label class=\"has-error\">\n            E-mail: <input type=\"text\" name=\"email\" value=\"foo@bar.com\" />\n            Has already been taken!\n          </label>\n    \n          <button type=\"submit\">Register</button>\n    \n        </form>\n    \n    The `<label>` around the e-mail field is now updated to have the `has-error`\n    class and display the validation message.\n    \n    \\#\\#\\# How validation results are displayed\n    \n    Although the server will usually respond to a validation with a complete,\n    fresh copy of the form, Unpoly will by default not update the entire form.\n    This is done in order to preserve volatile state such as the scroll position\n    of `<textarea>` elements.\n    \n    By default Unpoly looks for a `<fieldset>`, `<label>` or `<form>`\n    around the validating input field, or any element with an\n    `up-fieldset` attribute.\n    With the Bootstrap bindings, Unpoly will also look\n    for a container with the `form-group` class.\n    \n    You can change this default behavior by setting [`up.form.config.validateTargets`](/up.form.config#config.validateTargets):\n    \n        // Always update the entire form containing the current field (\"&\")\n        up.form.config.validateTargets = ['form &']\n    \n    You can also individually override what to update by setting the `up-validate`\n    attribute to a CSS selector:\n    \n        <input type=\"text\" name=\"email\" up-validate=\".email-errors\">\n        <span class=\"email-errors\"></span>\n    \n    \\#\\#\\# Updating dependent fields\n    \n    The `[up-validate]` behavior is also a great way to partially update a form\n    when one fields depends on the value of another field.\n    \n    Let's say you have a form with one `<select>` to pick a department (sales, engineering, ...)\n    and another `<select>` to pick an employeee from the selected department:\n    \n        <form action=\"/contracts\">\n          <select name=\"department\">...</select> <!-- options for all departments -->\n          <select name=\"employeed\">...</select> <!-- options for employees of selected department -->\n        </form>\n    \n    The list of employees needs to be updated as the appartment changes:\n    \n        <form action=\"/contracts\">\n          <select name=\"department\" up-validate=\"[name=employee]\">...</select>\n          <select name=\"employee\">...</select>\n        </form>\n    \n    In order to update the `department` field in addition to the `employee` field, you could say\n    `up-validate=\"&, [name=employee]\"`, or simply `up-validate=\"form\"` to update the entire form.\n    \n    @selector input[up-validate]\n    @param {string} up-validate\n      The CSS selector to update with the server response.\n    \n      This defaults to a fieldset or form group around the validating field.\n    @stable\n     */\n    up.on('change', '[up-validate]', function(event, $field) {\n      return u.muteRejection(validate($field));\n    });\n\n    /***\n    Show or hide elements when a `<select>` or `<input>` has a given value.\n    \n    \\#\\#\\# Example: Select options\n    \n    The controlling form field gets an `up-switch` attribute with a selector for the elements to show or hide:\n    \n        <select name=\"advancedness\" up-switch=\".target\">\n          <option value=\"basic\">Basic parts</option>\n          <option value=\"advanced\">Advanced parts</option>\n          <option value=\"very-advanced\">Very advanced parts</option>\n        </select>\n    \n    The target elements can use [`[up-show-for]`](/up-show-for) and [`[up-hide-for]`](/up-hide-for)\n    attributes to indicate for which values they should be shown or hidden:\n    \n        <div class=\"target\" up-show-for=\"basic\">\n          only shown for advancedness = basic\n        </div>\n    \n        <div class=\"target\" up-hide-for=\"basic\">\n          hidden for advancedness = basic\n        </div>\n    \n        <div class=\"target\" up-show-for=\"advanced very-advanced\">\n          shown for advancedness = advanced or very-advanced\n        </div>\n    \n    \\#\\#\\# Example: Text field\n    \n    The controlling `<input>` gets an `up-switch` attribute with a selector for the elements to show or hide:\n    \n        <input type=\"text\" name=\"user\" up-switch=\".target\">\n    \n        <div class=\"target\" up-show-for=\"alice\">\n          only shown for user alice\n        </div>\n    \n    You can also use the pseudo-values `:blank` to match an empty input value,\n    or `:present` to match a non-empty input value:\n    \n        <input type=\"text\" name=\"user\" up-switch=\".target\">\n    \n        <div class=\"target\" up-show-for=\":blank\">\n          please enter a username\n        </div>\n    \n    \\#\\#\\# Example: Checkbox\n    \n    For checkboxes you can match against the pseudo-values `:checked` or `:unchecked`:\n    \n        <input type=\"checkbox\" name=\"flag\" up-switch=\".target\">\n    \n        <div class=\"target\" up-show-for=\":checked\">\n          only shown when checkbox is checked\n        </div>\n    \n        <div class=\"target\" up-show-for=\":cunhecked\">\n          only shown when checkbox is unchecked\n        </div>\n    \n    Of course you can also match against the `value` property of the checkbox element:\n    \n        <input type=\"checkbox\" name=\"flag\" value=\"active\" up-switch=\".target\">\n    \n        <div class=\"target\" up-show-for=\"active\">\n          only shown when checkbox is checked\n        </div>\n    \n    @selector input[up-switch]\n    @param {string} up-switch\n      A CSS selector for elements whose visibility depends on this field's value.\n    @stable\n     */\n\n    /***\n    Only shows this element if an input field with [`[up-switch]`](/input-up-switch) has one of the given values.\n    \n    See [`input[up-switch]`](/input-up-switch) for more documentation and examples.\n    \n    @selector [up-show-for]\n    @param {string} [up-show-for]\n      A space-separated list of input values for which this element should be shown.\n    @stable\n     */\n\n    /***\n    Hides this element if an input field with [`[up-switch]`](/input-up-switch) has one of the given values.\n    \n    See [`input[up-switch]`](/input-up-switch) for more documentation and examples.\n    \n    @selector [up-hide-for]\n    @param {string} [up-hide-for]\n      A space-separated list of input values for which this element should be hidden.\n    @stable\n     */\n    up.compiler('[up-switch]', function($field) {\n      return switchTargets($field);\n    });\n    up.on('change', '[up-switch]', function(event, $field) {\n      return switchTargets($field);\n    });\n    up.compiler('[up-show-for]:not(.up-switched), [up-hide-for]:not(.up-switched)', function($element) {\n      return switchTarget($element);\n    });\n\n    /***\n    Observes this field and runs a callback when a value changes.\n    \n    This is useful for observing text fields while the user is typing.\n    If you want to submit the form after a change see [`input[up-autosubmit]`](/input-up-autosubmit).\n    \n    The programmatic variant of this is the [`up.observe()`](/up.observe) function.\n    \n    \\#\\#\\# Examples\n    \n    The following would run a global `showSuggestions(value)` function\n    whenever the `<input>` changes:\n    \n        <form>\n          <input name=\"query\" up-observe=\"showSuggestions(value)\">\n        </form>\n    \n    \\#\\#\\# Callback context\n    \n    The script given to `up-observe` runs with the following context:\n    \n    | Name     | Type      | Description                           |\n    | -------- | --------- | ------------------------------------- |\n    | `value`  | `string`  | The current value of the field        |\n    | `this`   | `Element` | The form field                        |\n    | `$field` | `jQuery`  | The form field as a jQuery collection |\n    \n    @selector input[up-observe]\n    @param {string} up-observe\n      The code to run when the field's value changes.\n    @param {string} up-delay\n      The number of miliseconds to wait after a change before the code is run.\n    @stable\n     */\n\n    /***\n    Observes this form and runs a callback when any field changes.\n    \n    This is useful for observing text fields while the user is typing.\n    If you want to submit the form after a change see [`input[up-autosubmit]`](/input-up-autosubmit).\n    \n    The programmatic variant of this is the [`up.observe()`](/up.observe) function.\n    \n    \\#\\#\\# Example\n    \n    The would call a function `somethingChanged(value)`\n    when any `<input>` within the `<form>` changes:\n    \n        <form up-observe=\"somethingChanged(value)\">\n          <input name=\"foo\">\n          <input name=\"bar\">\n        </form>\n    \n    \\#\\#\\# Callback context\n    \n    The script given to `up-observe` runs with the following context:\n    \n    | Name     | Type      | Description                           |\n    | -------- | --------- | ------------------------------------- |\n    | `value`  | `string`  | The current value of the field        |\n    | `this`   | `Element` | The form field                        |\n    | `$field` | `jQuery`  | The form field as a jQuery collection |\n    \n    @selector form[up-observe]\n    @param {string} up-observe\n      The code to run when any field's value changes.\n    @param {string} up-delay\n      The number of miliseconds to wait after a change before the code is run.\n    @stable\n     */\n    up.compiler('[up-observe]', function($formOrField) {\n      return observe($formOrField);\n    });\n\n    /***\n    [Observes](/up.observe) this form field and submits the form when its value changes.\n    \n    Both the form and the changed field will be assigned a CSS class [`up-active`](/form-up-active)\n    while the autosubmitted form is loading.\n    \n    The programmatic variant of this is the [`up.autosubmit()`](/up.autosubmit) function.\n    \n    \\#\\#\\# Example\n    \n    The following would automatically submit the form when the query is changed:\n    \n        <form method=\"GET\" action=\"/search\">\n          <input type=\"search\" name=\"query\" up-autosubmit>\n          <input type=\"checkbox\" name=\"archive\"> Include archive\n        </form>\n    \n    @selector input[up-autosubmit]\n    @param {string} up-delay\n      The number of miliseconds to wait after a change before the form is submitted.\n    @stable\n     */\n\n    /***\n    [Observes](/up.observe) this form and submits the form when *any* field changes.\n    \n    Both the form and the field will be assigned a CSS class [`up-active`](/form-up-active)\n    while the autosubmitted form is loading.\n    \n    The programmatic variant of this is the [`up.autosubmit()`](/up.autosubmit) function.\n    \n    \\#\\#\\# Example\n    \n    This will submit the form when either query or checkbox was changed:\n    \n        <form method=\"GET\" action=\"/search\" up-autosubmit>\n          <input type=\"search\" name=\"query\">\n          <input type=\"checkbox\" name=\"archive\"> Include archive\n        </form>\n    \n    @selector form[up-autosubmit]\n    @param {string} up-delay\n      The number of miliseconds to wait after a change before the form is submitted.\n    @stable\n     */\n    up.compiler('[up-autosubmit]', function($formOrField) {\n      return autosubmit($formOrField);\n    });\n    up.compiler('[autofocus]', {\n      batch: true\n    }, function($input) {\n      return $input.last().focus();\n    });\n    up.on('up:framework:reset', reset);\n    return {\n      config: config,\n      submit: submit,\n      observe: observe,\n      validate: validate,\n      switchTargets: switchTargets,\n      autosubmit: autosubmit,\n      fieldSelector: fieldSelector,\n      submitButtonSelector: submitButtonSelector\n    };\n  })(jQuery);\n\n  up.submit = up.form.submit;\n\n  up.observe = up.form.observe;\n\n  up.autosubmit = up.form.autosubmit;\n\n  up.validate = up.form.validate;\n\n}).call(this);\n\n/***\nPop-up overlays\n===============\n\nInstead of [linking to a page fragment](/up.link), you can choose\nto show a fragment in a popup overlay that rolls down from an anchoring element.\n\nTo open a popup, add an [`up-popup` attribute](/a-up-popup) to a link:\n\n    <a href=\"/options\" up-popup=\".menu\">Show options</a>\n\nWhen this link is clicked, Unpoly will request the path `/options` and extract\nan element matching the selector `.menu` from the response. The matching element\nwill then be placed in the popup overlay.\n\n\n\\#\\#\\# Closing behavior\n\nThe popup closes when the user clicks anywhere outside the popup area.\n\nThe popup also closes *when a link within the popup changes a fragment behind the popup*.\nThis is useful to have the popup interact with the page that\nopened it, e.g. by updating parts of a larger form.\n\nTo disable this behavior, give the opening link an [`up-sticky`](/a-up-popup#up-sticky) attribute.\n\n\n\\#\\#\\# Customizing the popup design\n\nPopups have a minimal default design:\n\n- Popup contents are displayed in a white box\n- There is a a subtle box shadow around the popup\n- The box will grow to fit the popup contents\n\nThe easiest way to change how the popup looks is to override the\n[default CSS styles](https://github.com/unpoly/unpoly/blob/master/lib/assets/stylesheets/unpoly/popup.sass).\n\nThe HTML of a popup element is simply this:\n\n    <div class=\"up-popup\">\n      ...\n    </div>\n\n\n@class up.popup\n */\n\n(function() {\n  up.popup = (function($) {\n    var align, attachAsap, attachNow, autoclose, chain, closeAsap, closeNow, config, contains, createHiddenFrame, discardHistory, isOpen, preloadNow, reset, state, toggleAsap, u, unveilFrame;\n    u = up.util;\n\n    /***\n    Sets default options for future popups.\n    \n    @property up.popup.config\n    @param {string} [config.position='bottom-right']\n      Defines where the popup is attached to the opening element.\n    \n      Valid values are `'bottom-right'`, `'bottom-left'`, `'top-right'` and `'top-left'`.\n    @param {string} [config.history=false]\n      Whether opening a popup will add a browser history entry.\n    @param {string} [config.openAnimation='fade-in']\n      The animation used to open a popup.\n    @param {string} [config.closeAnimation='fade-out']\n      The animation used to close a popup.\n    @param {string} [config.openDuration]\n      The duration of the open animation (in milliseconds).\n    @param {string} [config.closeDuration]\n      The duration of the close animation (in milliseconds).\n    @param {string} [config.openEasing]\n      The timing function controlling the acceleration of the opening animation.\n    @param {string} [config.closeEasing]\n      The timing function controlling the acceleration of the closing animation.\n    @param {boolean} [options.sticky=false]\n      If set to `true`, the popup remains\n      open even it changes the page in the background.\n    @stable\n     */\n    config = u.config({\n      openAnimation: 'fade-in',\n      closeAnimation: 'fade-out',\n      openDuration: 150,\n      closeDuration: 100,\n      openEasing: null,\n      closeEasing: null,\n      position: 'bottom-right',\n      history: false\n    });\n\n    /***\n    Returns the URL from which the current popup's contents were loaded.\n    \n    Returns `undefined` if no  popup is open.\n    \n    @function up.popup.url\n    @return {string}\n      the source URL\n    @stable\n     */\n\n    /***\n    Returns the URL of the page or modal behind the popup.\n    \n    @function up.popup.coveredUrl\n    @return {string}\n    @experimental\n     */\n    state = u.config({\n      phase: 'closed',\n      $anchor: null,\n      $popup: null,\n      position: null,\n      sticky: null,\n      url: null,\n      coveredUrl: null,\n      coveredTitle: null\n    });\n    chain = new u.DivertibleChain();\n    reset = function() {\n      var ref;\n      if ((ref = state.$popup) != null) {\n        ref.remove();\n      }\n      state.reset();\n      chain.reset();\n      return config.reset();\n    };\n    align = function() {\n      var linkBox, popupBox, style;\n      style = {};\n      popupBox = u.measure(state.$popup);\n      if (u.isFixed(state.$anchor)) {\n        linkBox = state.$anchor.get(0).getBoundingClientRect();\n        style.position = 'fixed';\n      } else {\n        linkBox = u.measure(state.$anchor);\n      }\n      switch (state.position) {\n        case 'bottom-right':\n          style.top = linkBox.top + linkBox.height;\n          style.left = linkBox.left + linkBox.width - popupBox.width;\n          break;\n        case 'bottom-left':\n          style.top = linkBox.top + linkBox.height;\n          style.left = linkBox.left;\n          break;\n        case 'top-right':\n          style.top = linkBox.top - popupBox.height;\n          style.left = linkBox.left + linkBox.width - popupBox.width;\n          break;\n        case 'top-left':\n          style.top = linkBox.top - popupBox.height;\n          style.left = linkBox.left;\n          break;\n        default:\n          up.fail(\"Unknown position option '%s'\", state.position);\n      }\n      state.$popup.attr('up-position', state.position);\n      return u.writeInlineStyle(state.$popup, style);\n    };\n    discardHistory = function() {\n      state.coveredTitle = null;\n      return state.coveredUrl = null;\n    };\n    createHiddenFrame = function(target) {\n      var $popup;\n      $popup = u.$createElementFromSelector('.up-popup');\n      u.$createPlaceholder(target, $popup);\n      $popup.hide();\n      $popup.appendTo(document.body);\n      return state.$popup = $popup;\n    };\n    unveilFrame = function() {\n      return state.$popup.show();\n    };\n\n    /***\n    Returns whether popup modal is currently open.\n    \n    @function up.popup.isOpen\n    @return {boolean}\n    @stable\n     */\n    isOpen = function() {\n      return state.phase === 'opened' || state.phase === 'opening';\n    };\n\n    /***\n    Attaches a popup overlay to the given element or selector.\n    \n    Emits events [`up:popup:open`](/up:popup:open) and [`up:popup:opened`](/up:popup:opened).\n    \n    @function up.popup.attach\n    @param {Element|jQuery|string} anchor\n      The element to which the popup will be attached.\n    @param {string} [options.url]\n      The URL from which to fetch the popup contents.\n    \n      If omitted, the `href` or `up-href` attribute of the anchor element will be used.\n    \n      Will be ignored if `options.html` is given.\n    @param {string} [options.target]\n      A CSS selector that will be extracted from the response and placed into the popup.\n    @param {string} [options.position='bottom-right']\n      Defines where the popup is attached to the opening element.\n    \n      Valid values are `'bottom-right'`, `'bottom-left'`, `'top-right'` and `'top-left'`.\n    @param {string} [options.html]\n      A string of HTML from which to extract the popup contents. No network request will be made.\n    @param {string} [options.confirm]\n      A message that will be displayed in a cancelable confirmation dialog\n      before the modal is being opened.\n    @param {string} [options.animation]\n      The animation to use when opening the popup.\n    @param {number} [options.duration]\n      The duration of the animation. See [`up.animate()`](/up.animate).\n    @param {number} [options.delay]\n      The delay before the animation starts. See [`up.animate()`](/up.animate).\n    @param {string} [options.easing]\n      The timing function that controls the animation's acceleration. [`up.animate()`](/up.animate).\n    @param {string} [options.method=\"GET\"]\n      Override the request method.\n    @param {boolean} [options.sticky=false]\n      If set to `true`, the popup remains\n      open even if the page changes in the background.\n    @param {boolean} [options.history=false]\n    @return {Promise}\n      A promise that will be fulfilled when the popup has been loaded and\n      the opening animation has completed.\n    @stable\n     */\n    attachAsap = function(elementOrSelector, options) {\n      return chain.asap(closeNow, (function() {\n        return attachNow(elementOrSelector, options);\n      }));\n    };\n    attachNow = function(elementOrSelector, options) {\n      var $anchor, animateOptions, extractOptions, html, position, target, url;\n      $anchor = $(elementOrSelector);\n      $anchor.length || up.fail('Cannot attach popup to non-existing element %o', elementOrSelector);\n      options = u.options(options);\n      url = u.option(u.pluckKey(options, 'url'), $anchor.attr('up-href'), $anchor.attr('href'));\n      html = u.option(u.pluckKey(options, 'html'));\n      url || html || up.fail('up.popup.attach() requires either an { url } or { html } option');\n      target = u.option(u.pluckKey(options, 'target'), $anchor.attr('up-popup')) || up.fail('No target selector given for [up-popup]');\n      position = u.option(options.position, $anchor.attr('up-position'), config.position);\n      options.animation = u.option(options.animation, $anchor.attr('up-animation'), config.openAnimation);\n      options.sticky = u.option(options.sticky, u.castedAttr($anchor, 'up-sticky'), config.sticky);\n      options.history = up.browser.canPushState() ? u.option(options.history, u.castedAttr($anchor, 'up-history'), config.history) : false;\n      options.confirm = u.option(options.confirm, $anchor.attr('up-confirm'));\n      options.method = up.link.followMethod($anchor, options);\n      options.layer = 'popup';\n      options.failTarget = u.option(options.failTarget, $anchor.attr('up-fail-target'));\n      options.failLayer = u.option(options.failLayer, $anchor.attr('up-fail-layer'), 'auto');\n      options.provideTarget = function() {\n        return createHiddenFrame(target);\n      };\n      animateOptions = up.motion.animateOptions(options, $anchor, {\n        duration: config.openDuration,\n        easing: config.openEasing\n      });\n      extractOptions = u.merge(options, {\n        animation: false\n      });\n      if (options.preload && url) {\n        return up.replace(target, url, options);\n      }\n      return up.browser.whenConfirmed(options).then(function() {\n        return up.bus.whenEmitted('up:popup:open', {\n          url: url,\n          message: 'Opening popup'\n        }).then(function() {\n          var promise;\n          state.phase = 'opening';\n          state.$anchor = $anchor;\n          state.position = position;\n          if (options.history) {\n            state.coveredUrl = up.browser.url();\n            state.coveredTitle = document.title;\n          }\n          state.sticky = options.sticky;\n          if (html) {\n            promise = up.extract(target, html, extractOptions);\n          } else {\n            promise = up.replace(target, url, extractOptions);\n          }\n          promise = promise.then(function() {\n            align();\n            unveilFrame();\n            return up.animate(state.$popup, options.animation, animateOptions);\n          });\n          promise = promise.then(function() {\n            state.phase = 'opened';\n            return up.emit('up:popup:opened', {\n              message: 'Popup opened'\n            });\n          });\n          return promise;\n        });\n      });\n    };\n\n    /***\n    This event is [emitted](/up.emit) when a popup is starting to open.\n    \n    @event up:popup:open\n    @param event.preventDefault()\n      Event listeners may call this method to prevent the popup from opening.\n    @stable\n     */\n\n    /***\n    This event is [emitted](/up.emit) when a popup has finished opening.\n    \n    @event up:popup:opened\n    @stable\n     */\n\n    /***\n    Closes a currently opened popup overlay.\n    \n    Does nothing if no popup is currently open.\n    \n    Emits events [`up:popup:close`](/up:popup:close) and [`up:popup:closed`](/up:popup:closed).\n    \n    @function up.popup.close\n    @param {Object} options\n      See options for [`up.animate()`](/up.animate).\n    @return {Promise}\n      A promise that will be fulfilled once the modal's close\n      animation has finished.\n    @stable\n     */\n    closeAsap = function(options) {\n      return chain.asap(function() {\n        return closeNow(options);\n      });\n    };\n    closeNow = function(options) {\n      var animateOptions;\n      if (!isOpen()) {\n        return Promise.resolve();\n      }\n      options = u.options(options, {\n        animation: config.closeAnimation,\n        history: state.coveredUrl,\n        title: state.coveredTitle\n      });\n      animateOptions = up.motion.animateOptions(options, {\n        duration: config.closeDuration,\n        easing: config.closeEasing\n      });\n      u.assign(options, animateOptions);\n      return up.bus.whenEmitted('up:popup:close', {\n        message: 'Closing popup',\n        $element: state.$popup\n      }).then(function() {\n        state.phase = 'closing';\n        state.url = null;\n        state.coveredUrl = null;\n        state.coveredTitle = null;\n        return up.destroy(state.$popup, options).then(function() {\n          state.phase = 'closed';\n          state.$popup = null;\n          state.$anchor = null;\n          state.sticky = null;\n          return up.emit('up:popup:closed', {\n            message: 'Popup closed'\n          });\n        });\n      });\n    };\n    preloadNow = function($link, options) {\n      options = u.options(options);\n      options.preload = true;\n      return attachNow($link, options);\n    };\n    toggleAsap = function($link, options) {\n      if (u.hasClass($link, 'up-current')) {\n        return closeAsap();\n      } else {\n        return attachAsap($link, options);\n      }\n    };\n\n    /***\n    This event is [emitted](/up.emit) when a popup dialog\n    is starting to [close](/up.popup.close).\n    \n    @event up:popup:close\n    @param event.preventDefault()\n      Event listeners may call this method to prevent the popup from closing.\n    @stable\n     */\n\n    /***\n    This event is [emitted](/up.emit) when a popup dialog\n    is done [closing](/up.popup.close).\n    \n    @event up:popup:closed\n    @stable\n     */\n    autoclose = function() {\n      if (!state.sticky) {\n        discardHistory();\n        return closeAsap();\n      }\n    };\n\n    /***\n    Returns whether the given element or selector is contained\n    within the current popup.\n    \n    @methods up.popup.contains\n    @param {string} elementOrSelector\n      The element to test\n    @return {boolean}\n    @stable\n     */\n    contains = function(elementOrSelector) {\n      var $element;\n      $element = $(elementOrSelector);\n      return $element.closest('.up-popup').length > 0;\n    };\n\n    /***\n    Opens this link's destination of in a popup overlay:\n    \n        <a href=\"/decks\" up-popup=\".deck_list\">Switch deck</a>\n    \n    If the `up-sticky` attribute is set, the dialog does not auto-close\n    if a page fragment behind the popup overlay updates:\n    \n        <a href=\"/decks\" up-popup=\".deck_list\">Switch deck</a>\n        <a href=\"/settings\" up-popup=\".options\" up-sticky>Settings</a>\n    \n    @selector a[up-popup]\n    @param {string} up-popup\n      The CSS selector that will be extracted from the response and\n      displayed in a popup overlay.\n    @param [up-position]\n      Defines where the popup is attached to the opening element.\n    \n      Valid values are `'bottom-right'`, `'bottom-left'`, `'top-right'` and `'top-left'`.\n    @param {string} [up-confirm]\n      A message that will be displayed in a cancelable confirmation dialog\n      before the popup is opened.\n    @param {string} [up-method='GET']\n      Override the request method.\n    @param [up-sticky]\n      If set to `true`, the popup remains\n      open even if the page changes in the background.\n    @param {string} [up-history='false']\n      Whether to push an entry to the browser history for the popup's source URL.\n    \n      Set this to `'false'` to prevent the URL bar from being updated.\n      Set this to a URL string to update the history with the given URL.\n    \n    @stable\n     */\n    up.link.addFollowVariant('[up-popup]', {\n      follow: function($link, options) {\n        return toggleAsap($link, options);\n      },\n      preload: function($link, options) {\n        return preloadNow($link, options);\n      }\n    });\n    up.on('click up:action:consumed', function(event) {\n      var $target;\n      $target = $(event.target);\n      if (!$target.closest('.up-popup, [up-popup]').length) {\n        return u.muteRejection(closeAsap());\n      }\n    });\n    up.on('up:fragment:inserted', function(event, $fragment) {\n      var newSource;\n      if (contains($fragment)) {\n        if (newSource = $fragment.attr('up-source')) {\n          return state.url = newSource;\n        }\n      } else if (event.origin && contains(event.origin)) {\n        return u.muteRejection(autoclose());\n      }\n    });\n    up.bus.onEscape(function() {\n      return u.muteRejection(closeAsap());\n    });\n\n    /***\n    When this element is clicked, a currently open [popup](/up.popup) is closed.\n    \n    Does nothing if no popup is currently open.\n    \n    \\#\\#\\# Example\n    \n    Clickin on this `<span>` will close a currently open popup:\n    \n        <span class='up-close'>Close this popup</span>\n    \n    When a popup changes the current URL, you might need to deal with content being displayed\n    as either a popup or a full page.\n    \n    To make a link that closes the current popup, but follows to\n    a fallback destination if no popup is open:\n    \n        <a href=\"/fallback\" up-close>Okay</a>\n    \n    @selector .up-popup [up-close]\n    @stable\n     */\n    up.on('click', '.up-popup [up-close]', function(event, $element) {\n      u.muteRejection(closeAsap());\n      return up.bus.consumeAction(event);\n    });\n    up.on('up:history:restore', function() {\n      return u.muteRejection(closeAsap());\n    });\n    up.on('up:framework:reset', reset);\n    return {\n      attach: attachAsap,\n      close: closeAsap,\n      url: function() {\n        return state.url;\n      },\n      coveredUrl: function() {\n        return state.coveredUrl;\n      },\n      config: config,\n      contains: contains,\n      isOpen: isOpen\n    };\n  })(jQuery);\n\n}).call(this);\n\n/***\nModal dialogs\n=============\n\nInstead of [linking to a page fragment](/up.link), you can choose to show a fragment\nin a modal dialog. The existing page will remain open in the background.\n\nTo open a modal, add an [`up-modal`](/a-up-modal) attribute to a link:\n\n    <a href=\"/blogs\" up-modal=\".blog-list\">Switch blog</a>\n\nWhen this link is clicked, Unpoly will request the path `/blogs` and extract\nan element matching the selector `.blog-list` from the response. The matching element\nwill then be placed in a modal dialog.\n\n\n\\#\\#\\# Closing behavior\n\nBy default the dialog automatically closes\n*when a link inside a modal changes a fragment behind the modal*.\nThis is useful to have the dialog interact with the page that\nopened it, e.g. by updating parts of a larger form.\n\nTo disable this behavior, give the opening link an [`up-sticky`](/a-up-modal#up-sticky) attribute:\n\n\n\\#\\#\\# Customizing the dialog design\n\nDialogs have a minimal default design:\n\n- Contents are displayed in a white box with a subtle box shadow\n- The box will grow to fit the dialog contents, but never grow larger than the screen\n- The box is placed over a semi-transparent backdrop to dim the rest of the page\n- There is a button to close the dialog in the top-right corner\n\nThe easiest way to change how the dialog looks is to override the\n[default CSS styles](https://github.com/unpoly/unpoly/blob/master/lib/assets/stylesheets/unpoly/modal.sass).\n\nBy default the dialog uses the following DOM structure:\n\n    <div class=\"up-modal\">\n      <div class=\"up-modal-backdrop\">\n      <div class=\"up-modal-viewport\">\n        <div class=\"up-modal-dialog\">\n          <div class=\"up-modal-content\">\n            <!-- the matching element will be placed here -->\n          </div>\n          <div class=\"up-modal-close\" up-close>X</div>\n        </div>\n      </div>\n    </div>\n\nYou can change this structure by setting [`up.modal.config.template`](/up.modal.config#config.template) to a new template string\nor function.\n\n\n@class up.modal\n */\n\n(function() {\n  up.modal = (function($) {\n    var animate, autoclose, chain, closeAsap, closeNow, config, contains, createHiddenFrame, discardHistory, extractAsap, flavor, flavorDefault, flavorOverrides, flavors, followAsap, isOpen, markAsAnimating, openAsap, openNow, preloadNow, reset, shiftElements, state, templateHtml, u, unshiftElements, unveilFrame, validateTarget, visitAsap;\n    u = up.util;\n\n    /***\n    Sets default options for future modals.\n    \n    @property up.modal.config\n    @param {string} [config.history=true]\n      Whether opening a modal will add a browser history entry.\n    @param {number} [config.width]\n      The width of the dialog as a CSS value like `'400px'` or `'50%'`.\n    \n      Defaults to `undefined`, meaning that the dialog will grow to fit its contents\n      until it reaches `config.maxWidth`. Leaving this as `undefined` will\n      also allow you to control the width using CSS on `.up-modal-dialog.\n    @param {number} [config.maxWidth]\n      The width of the dialog as a CSS value like `'400px'` or `50%`.\n      You can set this to `undefined` to make the dialog fit its contents.\n      Be aware however, that e.g. Bootstrap stretches input elements\n      to `width: 100%`, meaning the dialog will also stretch to the full\n      width of the screen.\n    @param {number} [config.height='auto']\n      The height of the dialog in pixels.\n      Defaults to `undefined`, meaning that the dialog will grow to fit its contents.\n    @param {string|Function(config)} [config.template]\n      A string containing the HTML structure of the modal.\n      You can supply an alternative template string, but make sure that it\n      defines tag with the classes `up-modal`, `up-modal-dialog` and  `up-modal-content`.\n    \n      You can also supply a function that returns a HTML string.\n      The function will be called with the modal options (merged from these defaults\n      and any per-open overrides) whenever a modal opens.\n    @param {string} [config.closeLabel='']\n      The label of the button that closes the dialog.\n    @param {boolean} [config.closable=true]\n      When `true`, the modal will render a close icon and close when the user\n      clicks on the backdrop or presses Escape.\n    \n      When `false`, you need to either supply an element with `[up-close]` or\n      close the modal manually with `up.modal.close()`.\n    @param {string} [config.openAnimation='fade-in']\n      The animation used to open the viewport around the dialog.\n    @param {string} [config.closeAnimation='fade-out']\n      The animation used to close the viewport the dialog.\n    @param {string} [config.backdropOpenAnimation='fade-in']\n      The animation used to open the backdrop that dims the page below the dialog.\n    @param {string} [config.backdropCloseAnimation='fade-out']\n      The animation used to close the backdrop that dims the page below the dialog.\n    @param {number} [config.openDuration]\n      The duration of the open animation (in milliseconds).\n    @param {number} [config.closeDuration]\n      The duration of the close animation (in milliseconds).\n    @param {string} [config.openEasing]\n      The timing function controlling the acceleration of the opening animation.\n    @param {string} [config.closeEasing]\n      The timing function controlling the acceleration of the closing animation.\n    @param {boolean} [options.sticky=false]\n      If set to `true`, the modal remains\n      open even it changes the page in the background.\n    @param {string} [options.flavor='default']\n      The default [flavor](/up.modal.flavors).\n    @stable\n     */\n    config = u.config({\n      maxWidth: null,\n      width: null,\n      height: null,\n      history: true,\n      openAnimation: 'fade-in',\n      closeAnimation: 'fade-out',\n      openDuration: null,\n      closeDuration: null,\n      openEasing: null,\n      closeEasing: null,\n      backdropOpenAnimation: 'fade-in',\n      backdropCloseAnimation: 'fade-out',\n      closeLabel: '',\n      closable: true,\n      sticky: false,\n      flavor: 'default',\n      position: null,\n      template: function(options) {\n        return \"<div class=\\\"up-modal\\\">\\n  <div class=\\\"up-modal-backdrop\\\"></div>\\n  <div class=\\\"up-modal-viewport\\\">\\n    <div class=\\\"up-modal-dialog\\\">\\n      <div class=\\\"up-modal-content\\\"></div>\\n      <div class=\\\"up-modal-close\\\" up-close>\" + options.closeLabel + \"</div>\\n    </div>\\n  </div>\\n</div>\";\n      }\n    });\n\n    /***\n    Define modal variants with their own default configuration, CSS or HTML template.\n    \n    \\#\\#\\# Example\n    \n    Unpoly's [`[up-drawer]`](/a-up-drawer) is implemented as a modal flavor:\n    \n        up.modal.flavors.drawer = {\n          openAnimation: 'move-from-right',\n          closeAnimation: 'move-to-right'\n        }\n    \n    Modals with that flavor will have a container with an `up-flavor` attribute:\n    \n        <div class='up-modal' up-flavor='drawer'>\n          ...\n        </div>\n    \n    We can target the `up-flavor` attribute to override the default dialog styles:\n    \n        .up-modal[up-flavor='drawer'] {\n    \n          .up-modal-dialog {\n            margin: 0;         // Remove margin so drawer starts at the screen edge\n            max-width: 350px;  // Set drawer size\n          }\n    \n          .up-modal-content {\n            min-height: 100vh; // Stretch background to full window height\n          }\n        }\n    \n    @property up.modal.flavors\n    @param {Object} flavors\n      An object where the keys are flavor names (e.g. `'drawer') and\n      the values are the respective default configurations.\n    @experimental\n     */\n    flavors = u.openConfig({\n      \"default\": {}\n    });\n\n    /***\n    Returns the source URL for the fragment displayed in the current modal overlay,\n    or `undefined` if no modal is currently open.\n    \n    @function up.modal.url\n    @return {string}\n      the source URL\n    @stable\n     */\n\n    /***\n    Returns the URL of the page behind the modal overlay.\n    \n    @function up.modal.coveredUrl\n    @return {string}\n    @experimental\n     */\n    state = u.config(function() {\n      return {\n        phase: 'closed',\n        $anchor: null,\n        $modal: null,\n        sticky: null,\n        closable: null,\n        flavor: null,\n        url: null,\n        coveredUrl: null,\n        coveredTitle: null,\n        position: null,\n        unshifters: []\n      };\n    });\n    chain = new u.DivertibleChain();\n    reset = function() {\n      var ref;\n      if ((ref = state.$modal) != null) {\n        ref.remove();\n      }\n      unshiftElements();\n      state.reset();\n      chain.reset();\n      config.reset();\n      return flavors.reset();\n    };\n    templateHtml = function() {\n      var template;\n      template = flavorDefault('template');\n      return u.evalOption(template, {\n        closeLabel: flavorDefault('closeLabel')\n      });\n    };\n    discardHistory = function() {\n      state.coveredTitle = null;\n      return state.coveredUrl = null;\n    };\n    createHiddenFrame = function(target, options) {\n      var $content, $dialog, $modal, dialogStyles;\n      $modal = $(templateHtml());\n      $modal.attr('up-flavor', state.flavor);\n      if (u.isPresent(state.position)) {\n        $modal.attr('up-position', state.position);\n      }\n      $dialog = $modal.find('.up-modal-dialog');\n      dialogStyles = u.only(options, 'width', 'maxWidth', 'height');\n      u.writeInlineStyle($dialog, dialogStyles);\n      if (!state.closable) {\n        $modal.find('.up-modal-close').remove();\n      }\n      $content = $modal.find('.up-modal-content');\n      u.$createPlaceholder(target, $content);\n      $modal.hide();\n      $modal.appendTo(document.body);\n      return state.$modal = $modal;\n    };\n    unveilFrame = function() {\n      return state.$modal.show();\n    };\n    shiftElements = function() {\n      var $body, bodyRightPadding, bodyRightShift, scrollbarWidth, unshiftBody;\n      if (u.documentHasVerticalScrollbar()) {\n        $body = $('body');\n        scrollbarWidth = u.scrollbarWidth();\n        bodyRightPadding = u.readComputedStyleNumber($body, 'paddingRight');\n        bodyRightShift = scrollbarWidth + bodyRightPadding;\n        unshiftBody = u.writeTemporaryStyle($body, {\n          paddingRight: bodyRightShift,\n          overflowY: 'hidden'\n        });\n        state.unshifters.push(unshiftBody);\n        return up.layout.anchoredRight().each(function() {\n          var $element, elementRight, elementRightShift, unshifter;\n          $element = $(this);\n          elementRight = u.readComputedStyleNumber($element, 'right');\n          elementRightShift = scrollbarWidth + elementRight;\n          unshifter = u.writeTemporaryStyle($element, {\n            right: elementRightShift\n          });\n          return state.unshifters.push(unshifter);\n        });\n      }\n    };\n    unshiftElements = function() {\n      var results, unshifter;\n      results = [];\n      while (unshifter = state.unshifters.pop()) {\n        results.push(unshifter());\n      }\n      return results;\n    };\n\n    /***\n    Returns whether a modal is currently open.\n    \n    This also returns `true` if the modal is in an opening or closing animation.\n    \n    @function up.modal.isOpen\n    @return {boolean}\n    @stable\n     */\n    isOpen = function() {\n      return state.phase === 'opened' || state.phase === 'opening';\n    };\n\n    /***\n    Opens the given link's destination in a modal overlay:\n    \n        var $link = $('...');\n        up.modal.follow($link);\n    \n    Any option attributes for [`a[up-modal]`](/a.up-modal) will be honored.\n    \n    Emits events [`up:modal:open`](/up:modal:open) and [`up:modal:opened`](/up:modal:opened).\n    \n    @function up.modal.follow\n    @param {Element|jQuery|string} linkOrSelector\n      The link to follow.\n    @param {string} [options.target]\n      The selector to extract from the response and open in a modal dialog.\n    @param {number} [options.width]\n      The width of the dialog in pixels.\n      By [default](/up.modal.config) the dialog will grow to fit its contents.\n    @param {number} [options.height]\n      The width of the dialog in pixels.\n      By [default](/up.modal.config) the dialog will grow to fit its contents.\n    @param {boolean} [options.sticky=false]\n      If set to `true`, the modal remains\n      open even it changes the page in the background.\n    @param {boolean} [config.closable=true]\n      When `true`, the modal will render a close icon and close when the user\n      clicks on the backdrop or presses Escape.\n    \n      When `false`, you need to either supply an element with `[up-close]` or\n      close the modal manually with `up.modal.close()`.\n    @param {string} [options.confirm]\n      A message that will be displayed in a cancelable confirmation dialog\n      before the modal is being opened.\n    @param {string} [options.method=\"GET\"]\n      Override the request method.\n    @param {boolean} [options.history=true]\n      Whether to add a browser history entry for the modal's source URL.\n    @param {string} [options.animation]\n      The animation to use when opening the modal.\n    @param {number} [options.duration]\n      The duration of the animation. See [`up.animate()`](/up.animate).\n    @param {number} [options.delay]\n      The delay before the animation starts. See [`up.animate()`](/up.animate).\n    @param {string} [options.easing]\n      The timing function that controls the animation's acceleration. [`up.animate()`](/up.animate).\n    @return {Promise}\n      A promise that will be fulfilled when the modal has been loaded and\n      the opening animation has completed.\n    @stable\n     */\n    followAsap = function(linkOrSelector, options) {\n      options = u.options(options);\n      options.$link = $(linkOrSelector);\n      return openAsap(options);\n    };\n    preloadNow = function($link, options) {\n      options = u.options(options);\n      options.$link = $link;\n      options.preload = true;\n      return openNow(options);\n    };\n\n    /***\n    Opens a modal for the given URL.\n    \n    \\#\\#\\# Example\n    \n        up.modal.visit('/foo', { target: '.list' });\n    \n    This will request `/foo`, extract the `.list` selector from the response\n    and open the selected container in a modal dialog.\n    \n    Emits events [`up:modal:open`](/up:modal:open) and [`up:modal:opened`](/up:modal:opened).\n    \n    @function up.modal.visit\n    @param {string} url\n      The URL to load.\n    @param {string} options.target\n      The CSS selector to extract from the response.\n      The extracted content will be placed into the dialog window.\n    @param {Object} options\n      See options for [`up.modal.follow()`](/up.modal.follow).\n    @return {Promise}\n      A promise that will be fulfilled when the modal has been loaded and the opening\n      animation has completed.\n    @stable\n     */\n    visitAsap = function(url, options) {\n      options = u.options(options);\n      options.url = url;\n      return openAsap(options);\n    };\n\n    /***\n    [Extracts](/up.extract) the given CSS selector from the given HTML string and\n    opens the results in a modal.\n    \n    \\#\\#\\# Example\n    \n        var html = 'before <div class=\"content\">inner</div> after';\n        up.modal.extract('.content', html);\n    \n    The would open a modal with the following contents:\n    \n        <div class=\"content\">inner</div>\n    \n    Emits events [`up:modal:open`](/up:modal:open) and [`up:modal:opened`](/up:modal:opened).\n    \n    @function up.modal.extract\n    @param {string} selector\n      The CSS selector to extract from the HTML.\n    @param {string} html\n      The HTML containing the modal content.\n    @param {Object} options\n      See options for [`up.modal.follow()`](/up.modal.follow).\n    @return {Promise}\n      A promise that will be fulfilled when the modal has been opened and the opening\n      animation has completed.\n    @stable\n     */\n    extractAsap = function(selector, html, options) {\n      options = u.options(options);\n      options.html = html;\n      options.history = u.option(options.history, false);\n      options.target = selector;\n      return openAsap(options);\n    };\n    openAsap = function(options) {\n      return chain.asap(closeNow, (function() {\n        return openNow(options);\n      }));\n    };\n    openNow = function(options) {\n      var $link, animateOptions, html, target, url;\n      options = u.options(options);\n      $link = u.option(u.pluckKey(options, '$link'), u.nullJQuery());\n      url = u.option(u.pluckKey(options, 'url'), $link.attr('up-href'), $link.attr('href'));\n      html = u.option(u.pluckKey(options, 'html'));\n      target = u.option(u.pluckKey(options, 'target'), $link.attr('up-modal'));\n      validateTarget(target);\n      options.flavor = u.option(options.flavor, $link.attr('up-flavor'), config.flavor);\n      options.position = u.option(options.position, $link.attr('up-position'), flavorDefault('position', options.flavor));\n      options.position = u.evalOption(options.position, {\n        $link: $link\n      });\n      options.width = u.option(options.width, $link.attr('up-width'), flavorDefault('width', options.flavor));\n      options.maxWidth = u.option(options.maxWidth, $link.attr('up-max-width'), flavorDefault('maxWidth', options.flavor));\n      options.height = u.option(options.height, $link.attr('up-height'), flavorDefault('height'));\n      options.animation = u.option(options.animation, $link.attr('up-animation'), flavorDefault('openAnimation', options.flavor));\n      options.animation = u.evalOption(options.animation, {\n        position: options.position\n      });\n      options.backdropAnimation = u.option(options.backdropAnimation, $link.attr('up-backdrop-animation'), flavorDefault('backdropOpenAnimation', options.flavor));\n      options.backdropAnimation = u.evalOption(options.backdropAnimation, {\n        position: options.position\n      });\n      options.sticky = u.option(options.sticky, u.castedAttr($link, 'up-sticky'), flavorDefault('sticky', options.flavor));\n      options.closable = u.option(options.closable, u.castedAttr($link, 'up-closable'), flavorDefault('closable', options.flavor));\n      options.confirm = u.option(options.confirm, $link.attr('up-confirm'));\n      options.method = up.link.followMethod($link, options);\n      options.layer = 'modal';\n      options.failTarget = u.option(options.failTarget, $link.attr('up-fail-target'));\n      options.failLayer = u.option(options.failLayer, $link.attr('up-fail-layer'), 'auto');\n      animateOptions = up.motion.animateOptions(options, $link, {\n        duration: flavorDefault('openDuration', options.flavor),\n        easing: flavorDefault('openEasing', options.flavor)\n      });\n      options.history = u.option(options.history, u.castedAttr($link, 'up-history'), flavorDefault('history', options.flavor));\n      if (!up.browser.canPushState()) {\n        options.history = false;\n      }\n      options.provideTarget = function() {\n        return createHiddenFrame(target, options);\n      };\n      if (options.preload) {\n        return up.replace(target, url, options);\n      }\n      return up.browser.whenConfirmed(options).then(function() {\n        return up.bus.whenEmitted('up:modal:open', {\n          url: url,\n          message: 'Opening modal'\n        }).then(function() {\n          var extractOptions, promise;\n          state.phase = 'opening';\n          state.flavor = options.flavor;\n          state.sticky = options.sticky;\n          state.closable = options.closable;\n          state.position = options.position;\n          if (options.history) {\n            state.coveredUrl = up.browser.url();\n            state.coveredTitle = document.title;\n          }\n          extractOptions = u.merge(options, {\n            animation: false\n          });\n          if (html) {\n            promise = up.extract(target, html, extractOptions);\n          } else {\n            promise = up.replace(target, url, extractOptions);\n          }\n          promise = promise.then(function() {\n            shiftElements();\n            unveilFrame();\n            return animate(options.animation, options.backdropAnimation, animateOptions);\n          });\n          promise = promise.then(function() {\n            state.phase = 'opened';\n            return up.emit('up:modal:opened', {\n              message: 'Modal opened'\n            });\n          });\n          return promise;\n        });\n      });\n    };\n    validateTarget = function(target) {\n      if (u.isBlank(target)) {\n        return up.fail('Cannot open a modal without a target selector');\n      } else if (target === 'body') {\n        return up.fail('Cannot open the <body> in a modal');\n      }\n    };\n\n    /***\n    This event is [emitted](/up.emit) when a modal dialog is starting to open.\n    \n    @event up:modal:open\n    @param event.preventDefault()\n      Event listeners may call this method to prevent the modal from opening.\n    @stable\n     */\n\n    /***\n    This event is [emitted](/up.emit) when a modal dialog has finished opening.\n    \n    @event up:modal:opened\n    @stable\n     */\n\n    /***\n    Closes a currently opened modal overlay.\n    \n    Does nothing if no modal is currently open.\n    \n    Emits events [`up:modal:close`](/up:modal:close) and [`up:modal:closed`](/up:modal:closed).\n    \n    @function up.modal.close\n    @param {Object} options\n      See options for [`up.animate()`](/up.animate)\n    @return {Promise}\n      A promise that will be fulfilled once the modal's close\n      animation has finished.\n    @stable\n     */\n    closeAsap = function(options) {\n      return chain.asap(function() {\n        return closeNow(options);\n      });\n    };\n    closeNow = function(options) {\n      var animateOptions, backdropCloseAnimation, destroyOptions, viewportCloseAnimation;\n      options = u.options(options);\n      if (!isOpen()) {\n        return Promise.resolve();\n      }\n      viewportCloseAnimation = u.option(options.animation, flavorDefault('closeAnimation'));\n      viewportCloseAnimation = u.evalOption(viewportCloseAnimation, {\n        position: state.position\n      });\n      backdropCloseAnimation = u.option(options.backdropAnimation, flavorDefault('backdropCloseAnimation'));\n      backdropCloseAnimation = u.evalOption(backdropCloseAnimation, {\n        position: state.position\n      });\n      animateOptions = up.motion.animateOptions(options, {\n        duration: flavorDefault('closeDuration'),\n        easing: flavorDefault('closeEasing')\n      });\n      destroyOptions = u.options(u.except(options, 'animation', 'duration', 'easing', 'delay'), {\n        history: state.coveredUrl,\n        title: state.coveredTitle\n      });\n      return up.bus.whenEmitted('up:modal:close', {\n        $element: state.$modal,\n        message: 'Closing modal'\n      }).then(function() {\n        var promise;\n        state.phase = 'closing';\n        state.url = null;\n        state.coveredUrl = null;\n        state.coveredTitle = null;\n        promise = animate(viewportCloseAnimation, backdropCloseAnimation, animateOptions);\n        promise = promise.then(function() {\n          return up.destroy(state.$modal, destroyOptions);\n        });\n        promise = promise.then(function() {\n          unshiftElements();\n          state.phase = 'closed';\n          state.$modal = null;\n          state.flavor = null;\n          state.sticky = null;\n          state.closable = null;\n          state.position = null;\n          return up.emit('up:modal:closed', {\n            message: 'Modal closed'\n          });\n        });\n        return promise;\n      });\n    };\n    markAsAnimating = function(isAnimating) {\n      if (isAnimating == null) {\n        isAnimating = true;\n      }\n      return state.$modal.toggleClass('up-modal-animating', isAnimating);\n    };\n    animate = function(viewportAnimation, backdropAnimation, animateOptions) {\n      var promise;\n      if (up.motion.isNone(viewportAnimation)) {\n        return Promise.resolve();\n      } else {\n        markAsAnimating();\n        promise = Promise.all([up.animate(state.$modal.find('.up-modal-viewport'), viewportAnimation, animateOptions), up.animate(state.$modal.find('.up-modal-backdrop'), backdropAnimation, animateOptions)]);\n        promise = promise.then(function() {\n          return markAsAnimating(false);\n        });\n        return promise;\n      }\n    };\n\n    /***\n    This event is [emitted](/up.emit) when a modal dialog\n    is starting to [close](/up.modal.close).\n    \n    @event up:modal:close\n    @param event.preventDefault()\n      Event listeners may call this method to prevent the modal from closing.\n    @stable\n     */\n\n    /***\n    This event is [emitted](/up.emit) when a modal dialog\n    is done [closing](/up.modal.close).\n    \n    @event up:modal:closed\n    @stable\n     */\n    autoclose = function() {\n      if (!state.sticky) {\n        discardHistory();\n        return closeAsap();\n      }\n    };\n\n    /***\n    Returns whether the given element or selector is contained\n    within the current modal.\n    \n    @function up.modal.contains\n    @param {string} elementOrSelector\n      The element to test\n    @return {boolean}\n    @stable\n     */\n    contains = function(elementOrSelector) {\n      var $element;\n      $element = $(elementOrSelector);\n      return $element.closest('.up-modal').length > 0;\n    };\n    flavor = function(name, overrideConfig) {\n      if (overrideConfig == null) {\n        overrideConfig = {};\n      }\n      up.warn('up.modal.flavor() is deprecated. Use the up.modal.flavors property instead.');\n      return u.assign(flavorOverrides(name), overrideConfig);\n    };\n\n    /***\n    Returns a config object for the given flavor.\n    Properties in that config should be preferred to the defaults in\n    [`/up.modal.config`](/up.modal.config).\n    \n    @function flavorOverrides\n    @internal\n     */\n    flavorOverrides = function(flavor) {\n      return flavors[flavor] || (flavors[flavor] = {});\n    };\n\n    /***\n    Returns the config option for the current flavor.\n    \n    @function flavorDefault\n    @internal\n     */\n    flavorDefault = function(key, flavorName) {\n      var value;\n      if (flavorName == null) {\n        flavorName = state.flavor;\n      }\n      if (flavorName) {\n        value = flavorOverrides(flavorName)[key];\n      }\n      if (u.isMissing(value)) {\n        value = config[key];\n      }\n      return value;\n    };\n\n    /***\n    Clicking this link will load the destination via AJAX and open\n    the given selector in a modal dialog.\n    \n    \\#\\#\\# Example\n    \n        <a href=\"/blogs\" up-modal=\".blog-list\">Switch blog</a>\n    \n    Clicking would request the path `/blog` and select `.blog-list` from\n    the HTML response. Unpoly will dim the page\n    and place the matching `.blog-list` tag will be placed in\n    a modal dialog.\n    \n    @selector a[up-modal]\n    @param {string} up-modal\n      The CSS selector that will be extracted from the response and displayed in a modal dialog.\n    @param {string} [up-confirm]\n      A message that will be displayed in a cancelable confirmation dialog\n      before the modal is opened.\n    @param {string} [up-method='GET']\n      Override the request method.\n    @param {string} [up-sticky]\n      If set to `\"true\"`, the modal remains\n      open even if the page changes in the background.\n    @param {boolean} [up-closable]\n      When `true`, the modal will render a close icon and close when the user\n      clicks on the backdrop or presses Escape.\n    \n      When `false`, you need to either supply an element with `[up-close]` or\n      close the modal manually with `up.modal.close()`.\n    @param {string} [up-animation]\n      The animation to use when opening the viewport containing the dialog.\n    @param {string} [up-backdrop-animation]\n      The animation to use when opening the backdrop that dims the page below the dialog.\n    @param {string} [up-height]\n      The width of the dialog in pixels.\n      By [default](/up.modal.config) the dialog will grow to fit its contents.\n    @param {string} [up-width]\n      The width of the dialog in pixels.\n      By [default](/up.modal.config) the dialog will grow to fit its contents.\n    @param {string} [up-history]\n      Whether to push an entry to the browser history for the modal's source URL.\n    \n      Set this to `'false'` to prevent the URL bar from being updated.\n      Set this to a URL string to update the history with the given URL.\n    \n    @stable\n     */\n    up.link.addFollowVariant('[up-modal]', {\n      follow: function($link, options) {\n        return followAsap($link, options);\n      },\n      preload: function($link, options) {\n        return preloadNow($link, options);\n      }\n    });\n    up.on('click', '.up-modal', function(event) {\n      var $target;\n      if (!state.closable) {\n        return;\n      }\n      $target = $(event.target);\n      if (!($target.closest('.up-modal-dialog').length || $target.closest('[up-modal]').length)) {\n        up.bus.consumeAction(event);\n        return u.muteRejection(closeAsap());\n      }\n    });\n    up.on('up:fragment:inserted', function(event, $fragment) {\n      var newSource;\n      if (contains($fragment)) {\n        if (newSource = $fragment.attr('up-source')) {\n          return state.url = newSource;\n        }\n      } else if (event.origin && contains(event.origin) && !up.popup.contains($fragment)) {\n        return u.muteRejection(autoclose());\n      }\n    });\n    up.bus.onEscape(function() {\n      if (state.closable) {\n        return u.muteRejection(closeAsap());\n      }\n    });\n\n    /***\n    When this element is clicked, closes a currently open dialog.\n    \n    Does nothing if no modal is currently open.\n    \n    To make a link that closes the current modal, but follows to\n    a fallback destination if no modal is open:\n    \n        <a href=\"/fallback\" up-close>Okay</a>\n    \n    @selector .up-modal [up-close]\n    @stable\n     */\n    up.on('click', '.up-modal [up-close]', function(event, $element) {\n      u.muteRejection(closeAsap());\n      return up.bus.consumeAction(event);\n    });\n\n    /***\n    Clicking this link will load the destination via AJAX and open\n    the given selector in a modal drawer that slides in from the edge of the screen.\n    \n    You can configure drawers using the [`up.modal.flavors.drawer`](/up.modal.flavors.drawer) property.\n    \n    \\#\\#\\# Example\n    \n        <a href=\"/blogs\" up-drawer=\".blog-list\">Switch blog</a>\n    \n    Clicking would request the path `/blog` and select `.blog-list` from\n    the HTML response. Unpoly will dim the page\n    and place the matching `.blog-list` tag will be placed in\n    a modal drawer.\n    \n    @selector a[up-drawer]\n    @param {string} up-drawer\n      The CSS selector to extract from the response and open in the drawer.\n    @param {string} [up-position='auto']\n      The side from which the drawer slides in.\n    \n      Valid values are `'left'`, `'right'` and `'auto'`. If set to `'auto'`, the\n      drawer will slide in from left if the opening link is on the left half of the screen.\n      Otherwise it will slide in from the right.\n    @stable\n     */\n    up.macro('a[up-drawer], [up-href][up-drawer]', function($link) {\n      var target;\n      target = $link.attr('up-drawer');\n      return $link.attr({\n        'up-modal': target,\n        'up-flavor': 'drawer'\n      });\n    });\n\n    /***\n    Sets default options for future drawers.\n    \n    @property up.modal.flavors.drawer\n    @param {Object} config\n      Default options for future drawers.\n    \n      See [`up.modal.config`](/up.modal.config) for available options.\n    @experimental\n     */\n    flavors.drawer = {\n      openAnimation: function(options) {\n        switch (options.position) {\n          case 'left':\n            return 'move-from-left';\n          case 'right':\n            return 'move-from-right';\n        }\n      },\n      closeAnimation: function(options) {\n        switch (options.position) {\n          case 'left':\n            return 'move-to-left';\n          case 'right':\n            return 'move-to-right';\n        }\n      },\n      position: function(options) {\n        if (u.isPresent(options.$link)) {\n          return u.horizontalScreenHalf(options.$link);\n        } else {\n          return 'left';\n        }\n      }\n    };\n    up.on('up:history:restore', function() {\n      return u.muteRejection(closeAsap());\n    });\n    up.on('up:framework:reset', reset);\n    return {\n      visit: visitAsap,\n      follow: followAsap,\n      extract: extractAsap,\n      close: closeAsap,\n      url: function() {\n        return state.url;\n      },\n      coveredUrl: function() {\n        return state.coveredUrl;\n      },\n      config: config,\n      flavors: flavors,\n      contains: contains,\n      isOpen: isOpen,\n      flavor: flavor\n    };\n  })(jQuery);\n\n}).call(this);\n\n/***\nTooltips\n========\n\nUnpoly comes with a basic tooltip implementation.\n\nAdd an [`up-tooltip`](/up-tooltip) attribute to any HTML tag to show a tooltip whenever\nthe user hovers over the element:\n\n      <a href=\"/decks\" up-tooltip=\"Show all decks\">Decks</a>\n\n\n\\#\\#\\# Styling\n\nThe default styles\nrender a tooltip with white text on a gray background.\nA gray triangle points to the element.\n\nTo change the styling, simply override the [CSS rules](https://github.com/unpoly/unpoly/blob/master/lib/assets/stylesheets/unpoly/tooltip.sass) for the `.up-tooltip` selector and its `:after`\nselector that is used for the triangle.\n\nThe HTML of a tooltip element is simply this:\n\n    <div class=\"up-tooltip\">\n      Show all decks\n    </div>\n\nThe tooltip element is appended to the end of `<body>`.\n\n@class up.tooltip\n */\n\n(function() {\n  up.tooltip = (function($) {\n    var align, attachAsap, attachNow, chain, closeAsap, closeNow, config, createElement, isOpen, reset, state, u;\n    u = up.util;\n\n    /***\n    Configures defaults for future tooltips.\n    \n    @property up.tooltip.config\n    @param {string} [config.position]\n      The default position of tooltips relative to the element.\n      Can be `'top'`, `'right'`, `'bottom'` or `'left'`.\n    @param {string} [config.openAnimation='fade-in']\n      The animation used to open a tooltip.\n    @param {string} [config.closeAnimation='fade-out']\n      The animation used to close a tooltip.\n    @param {number} [config.openDuration]\n      The duration of the open animation (in milliseconds).\n    @param {number} [config.closeDuration]\n      The duration of the close animation (in milliseconds).\n    @param {string} [config.openEasing]\n      The timing function controlling the acceleration of the opening animation.\n    @param {string} [config.closeEasing]\n      The timing function controlling the acceleration of the closing animation.\n    @stable\n     */\n    config = u.config({\n      position: 'top',\n      openAnimation: 'fade-in',\n      closeAnimation: 'fade-out',\n      openDuration: 100,\n      closeDuration: 50,\n      openEasing: null,\n      closeEasing: null\n    });\n    state = u.config({\n      phase: 'closed',\n      $anchor: null,\n      $tooltip: null,\n      position: null\n    });\n    chain = new u.DivertibleChain();\n    reset = function() {\n      var ref;\n      if ((ref = state.$tooltip) != null) {\n        ref.remove();\n      }\n      state.reset();\n      chain.reset();\n      return config.reset();\n    };\n    align = function() {\n      var linkBox, style, tooltipBox;\n      style = {};\n      tooltipBox = u.measure(state.$tooltip);\n      if (u.isFixed(state.$anchor)) {\n        linkBox = state.$anchor.get(0).getBoundingClientRect();\n        style.position = 'fixed';\n      } else {\n        linkBox = u.measure(state.$anchor);\n      }\n      switch (state.position) {\n        case 'top':\n          style.top = linkBox.top - tooltipBox.height;\n          style.left = linkBox.left + 0.5 * (linkBox.width - tooltipBox.width);\n          break;\n        case 'left':\n          style.top = linkBox.top + 0.5 * (linkBox.height - tooltipBox.height);\n          style.left = linkBox.left - tooltipBox.width;\n          break;\n        case 'right':\n          style.top = linkBox.top + 0.5 * (linkBox.height - tooltipBox.height);\n          style.left = linkBox.left + linkBox.width;\n          break;\n        case 'bottom':\n          style.top = linkBox.top + linkBox.height;\n          style.left = linkBox.left + 0.5 * (linkBox.width - tooltipBox.width);\n          break;\n        default:\n          up.fail(\"Unknown position option '%s'\", state.position);\n      }\n      state.$tooltip.attr('up-position', state.position);\n      return u.writeInlineStyle(state.$tooltip, style);\n    };\n    createElement = function(options) {\n      var $element;\n      $element = u.$createElementFromSelector('.up-tooltip');\n      if (u.isGiven(options.text)) {\n        $element.text(options.text);\n      } else {\n        $element.html(options.html);\n      }\n      $element.appendTo(document.body);\n      return state.$tooltip = $element;\n    };\n\n    /***\n    Opens a tooltip over the given element.\n    \n    The unobtrusive variant of this is the [`[up-tooltip]`](/up-tooltip) selector.\n    \n    \\#\\#\\# Examples\n    \n    In order to attach a tooltip to a `<span class=\"help\">?</span>`:\n    \n        up.tooltip.attach('.help', {\n          text: 'Enter multiple words or phrases'\n        });\n    \n    @function up.tooltip.attach\n    @param {Element|jQuery|string} elementOrSelector\n    @param {string} [options.text]\n      The text to display in the tooltip.\n    \n      Any HTML control characters will be escaped.\n      If you need to use HTML formatting in the tooltip, use `options.html` instead.\n    @param {string} [options.html]\n      The HTML to display in the tooltip unescaped.\n    \n      Make sure to escape any user-provided text before passing it as this option,\n      or use `options.text` (which automatically escapes).\n    @param {string} [options.position='top']\n      The position of the tooltip.\n      Can be `'top'`, `'right'`, `'bottom'` or `'left'`.\n    @param {string} [options.animation]\n      The [animation](/up.motion) to use when opening the tooltip.\n    @return {Promise}\n      A promise that will be fulfilled when the tooltip's opening animation has finished.\n    @stable\n     */\n    attachAsap = function(elementOrSelector, options) {\n      if (options == null) {\n        options = {};\n      }\n      return chain.asap(closeNow, (function() {\n        return attachNow(elementOrSelector, options);\n      }));\n    };\n    attachNow = function(elementOrSelector, options) {\n      var $anchor, animateOptions, animation, html, position, text;\n      $anchor = $(elementOrSelector);\n      options = u.options(options);\n      html = u.option(options.html, $anchor.attr('up-tooltip-html'));\n      text = u.option(options.text, $anchor.attr('up-tooltip'));\n      position = u.option(options.position, $anchor.attr('up-position'), config.position);\n      animation = u.option(options.animation, u.castedAttr($anchor, 'up-animation'), config.openAnimation);\n      animateOptions = up.motion.animateOptions(options, $anchor, {\n        duration: config.openDuration,\n        easing: config.openEasing\n      });\n      state.phase = 'opening';\n      state.$anchor = $anchor;\n      createElement({\n        text: text,\n        html: html\n      });\n      state.position = position;\n      align();\n      return up.animate(state.$tooltip, animation, animateOptions).then(function() {\n        return state.phase = 'opened';\n      });\n    };\n\n    /***\n    Closes a currently shown tooltip.\n    \n    Does nothing if no tooltip is currently shown.\n    \n    @function up.tooltip.close\n    @param {Object} options\n      See options for [`up.animate()`](/up.animate).\n    @return {Promise}\n      A promise for the end of the closing animation.\n    @stable\n     */\n    closeAsap = function(options) {\n      return chain.asap(function() {\n        return closeNow(options);\n      });\n    };\n    closeNow = function(options) {\n      var animateOptions;\n      if (!isOpen()) {\n        return Promise.resolve();\n      }\n      options = u.options(options, {\n        animation: config.closeAnimation\n      });\n      animateOptions = up.motion.animateOptions(options, {\n        duration: config.closeDuration,\n        easing: config.closeEasing\n      });\n      u.assign(options, animateOptions);\n      state.phase = 'closing';\n      return up.destroy(state.$tooltip, options).then(function() {\n        state.phase = 'closed';\n        state.$tooltip = null;\n        return state.$anchor = null;\n      });\n    };\n\n    /***\n    Returns whether a tooltip is currently showing.\n    \n    @function up.tooltip.isOpen\n    @stable\n     */\n    isOpen = function() {\n      return state.phase === 'opening' || state.phase === 'opened';\n    };\n\n    /***\n    Displays a tooltip with text content when hovering the mouse over this element.\n    \n    \\#\\#\\# Example\n    \n        <a href=\"/decks\" up-tooltip=\"Show all decks\">Decks</a>\n    \n    To make the tooltip appear below the element instead of above the element,\n    add an `up-position` attribute:\n    \n        <a href=\"/decks\" up-tooltip=\"Show all decks\" up-position=\"bottom\">Decks</a>\n    \n    @selector [up-tooltip]\n    @param {string} [up-animation]\n      The animation used to open the tooltip.\n      Defaults to [`up.tooltip.config.openAnimation`](/up.tooltip.config).\n    @param {string} [up-position]\n      The default position of tooltips relative to the element.\n      Can be either `\"top\"` or `\"bottom\"`.\n      Defaults to [`up.tooltip.config.position`](/up.tooltip.config).\n    @stable\n     */\n\n    /***\n    Displays a tooltip with HTML content when hovering the mouse over this element:\n    \n        <a href=\"/decks\" up-tooltip-html=\"Show &lt;b&gt;all&lt;/b&gt; decks\">Decks</a>\n    \n    @selector [up-tooltip-html]\n    @stable\n     */\n    up.compiler('[up-tooltip], [up-tooltip-html]', function($opener) {\n      $opener.on('mouseenter', function() {\n        return attachAsap($opener);\n      });\n      return $opener.on('mouseleave', function() {\n        return closeAsap();\n      });\n    });\n    up.on('click up:action:consumed', function(event) {\n      return closeAsap();\n    });\n    up.on('up:framework:reset', reset);\n    up.bus.onEscape(function() {\n      return closeAsap();\n    });\n    return {\n      config: config,\n      attach: attachAsap,\n      isOpen: isOpen,\n      close: closeAsap\n    };\n  })(jQuery);\n\n}).call(this);\n\n/***\nNavigation feedback\n===================\n\nUnpoly automatically adds the class [`.up-active`](/a.up-active) to links or forms while they are loading.\n\nBy marking navigation elements as [`[up-nav]`](/up-nav), contained links that point to the current location\nautomatically get the [`.up-current`](/up-nav-a.up-current) class.\n\nYou should style [`.up-active`](/a.up-active) and [`.up-current`](/up-nav a.up-current) with CSS to\nprovide instant feedback to user interactions. This improves the perceived speed of your interface.\n\n\\#\\#\\# Example\n\nLet's say we have an navigation bar with two links, pointing to `/foo` and `/bar` respectively:\n\n    <a href=\"/foo\" up-follow>Foo</a>\n    <a href=\"/bar\" up-follow>Bar</a>\n\nIf the current URL is `/foo`, the first link is automatically marked with an [`up-current`](/a.up-current) class:\n\n    <a href=\"/foo\" up-follow class=\"up-current\">Foo</a>\n    <a href=\"/bar\" up-follow>Bar</a>\n\nWhen the user clicks on the `/bar` link, the link will receive the [`up-active`](/a.up-active) class while it is waiting\nfor the server to respond:\n\n    <a href=\"/foo\" up-follow class=\"up-current\">Foo</a>\n    <a href=\"/bar\" up-follow class=\"up-active\">Bar</a>\n\nOnce the response is received the URL will change to `/bar` and the `up-active` class is removed:\n\n    <a href=\"/foo\" up-follow>Foo</a>\n    <a href=\"/bar\" up-follow class=\"up-current\">Bar</a>\n\n\n@class up.feedback\n */\n\n(function() {\n  var slice = [].slice;\n\n  up.feedback = (function($) {\n    var CLASS_ACTIVE, NORMALIZED_SECTION_URLS_KEY, SELECTOR_LINK, buildCurrentUrlSet, buildSectionUrls, config, currentUrlSet, findActivatableArea, navSelector, normalizeUrl, previousUrlSet, reset, sectionUrls, start, stop, u, updateAllNavigationSections, updateAllNavigationSectionsIfLocationChanged, updateCurrentClassForLinks, updateNavigationSectionsInNewFragment;\n    u = up.util;\n\n    /***\n    Sets default options for this module.\n    \n    @property up.feedback.config\n    @param {Array<string>} [config.currentClasses]\n      An array of classes to set on [links that point the current location](/a.up-current).\n    @param {Array<string>} [config.navs]\n      An array of CSS selectors that match [navigation components](/up-nav).\n    @stable\n     */\n    config = u.config({\n      currentClasses: ['up-current'],\n      navs: ['[up-nav]']\n    });\n    previousUrlSet = void 0;\n    currentUrlSet = void 0;\n    reset = function() {\n      config.reset();\n      previousUrlSet = void 0;\n      return currentUrlSet = void 0;\n    };\n    CLASS_ACTIVE = 'up-active';\n    SELECTOR_LINK = 'a, [up-href]';\n    navSelector = function() {\n      return config.navs.join(',');\n    };\n    normalizeUrl = function(url) {\n      if (u.isPresent(url)) {\n        return u.normalizeUrl(url, {\n          stripTrailingSlash: true\n        });\n      }\n    };\n    NORMALIZED_SECTION_URLS_KEY = 'up-normalized-urls';\n    sectionUrls = function($section) {\n      var urls;\n      if (!(urls = $section.data(NORMALIZED_SECTION_URLS_KEY))) {\n        urls = buildSectionUrls($section);\n        $section.data(NORMALIZED_SECTION_URLS_KEY, urls);\n      }\n      return urls;\n    };\n    buildSectionUrls = function($section) {\n      var attr, i, j, len, len1, ref, ref1, url, urls, value;\n      urls = [];\n      if (up.link.isSafe($section)) {\n        ref = ['href', 'up-href', 'up-alias'];\n        for (i = 0, len = ref.length; i < len; i++) {\n          attr = ref[i];\n          if (value = u.presentAttr($section, attr)) {\n            ref1 = u.splitValues(value);\n            for (j = 0, len1 = ref1.length; j < len1; j++) {\n              url = ref1[j];\n              if (url !== '#') {\n                url = normalizeUrl(url);\n                urls.push(url);\n              }\n            }\n          }\n        }\n      }\n      return urls;\n    };\n    buildCurrentUrlSet = function() {\n      var urls;\n      urls = [up.browser.url(), up.modal.url(), up.modal.coveredUrl(), up.popup.url(), up.popup.coveredUrl()];\n      return new up.UrlSet(urls, {\n        normalizeUrl: normalizeUrl\n      });\n    };\n    updateAllNavigationSectionsIfLocationChanged = function() {\n      previousUrlSet = currentUrlSet;\n      currentUrlSet = buildCurrentUrlSet();\n      if (!currentUrlSet.isEqual(previousUrlSet)) {\n        return updateAllNavigationSections($('body'));\n      }\n    };\n    updateAllNavigationSections = function($root) {\n      var $navs, $sections;\n      $navs = u.selectInSubtree($root, navSelector());\n      $sections = u.selectInSubtree($navs, SELECTOR_LINK);\n      return updateCurrentClassForLinks($sections);\n    };\n    updateNavigationSectionsInNewFragment = function($fragment) {\n      var $sections;\n      if ($fragment.closest(navSelector()).length) {\n        $sections = u.selectInSubtree($fragment, SELECTOR_LINK);\n        return updateCurrentClassForLinks($sections);\n      } else {\n        return updateAllNavigationSections($fragment);\n      }\n    };\n    updateCurrentClassForLinks = function($links) {\n      currentUrlSet || (currentUrlSet = buildCurrentUrlSet());\n      return u.each($links, function(link) {\n        var $link, classList, i, j, klass, len, len1, ref, ref1, results, results1, urls;\n        $link = $(link);\n        urls = sectionUrls($link);\n        classList = link.classList;\n        if (currentUrlSet.matchesAny(urls)) {\n          ref = config.currentClasses;\n          results = [];\n          for (i = 0, len = ref.length; i < len; i++) {\n            klass = ref[i];\n            results.push(classList.add(klass));\n          }\n          return results;\n        } else {\n          ref1 = config.currentClasses;\n          results1 = [];\n          for (j = 0, len1 = ref1.length; j < len1; j++) {\n            klass = ref1[j];\n            results1.push(classList.remove(klass));\n          }\n          return results1;\n        }\n      });\n    };\n\n    /***\n    @function findActivatableArea\n    @param {string|Element|jQuery} elementOrSelector\n    @internal\n     */\n    findActivatableArea = function(elementOrSelector) {\n      var $area;\n      $area = $(elementOrSelector);\n      if ($area.is(SELECTOR_LINK)) {\n        $area = u.presence($area.parent(SELECTOR_LINK)) || $area;\n      }\n      return $area;\n    };\n\n    /***\n    Marks the given element as currently loading, by assigning the CSS class [`up-active`](/a.up-active).\n    \n    This happens automatically when following links or submitting forms through the Unpoly API.\n    Use this function if you make custom network calls from your own JavaScript code.\n    \n    If the given element is a link within an [expanded click area](/up-expand),\n    the class will be assigned to the expanded area.\n    \n    \\#\\#\\# Example\n    \n        var $button = $('button');\n        $button.on('click', function() {\n          up.feedback.start($button, function() {\n            // the .up-active class will be removed when this promise resolves:\n            return up.request(...);\n          });\n        });\n    \n    @method up.feedback.start\n    @param {Element|jQuery|string} elementOrSelector\n      The element to mark as active\n    @param {Object} [options.preload]\n      If set to `false`, the element will not be marked as loading.\n    @param {Function} [action]\n      An optional function to run while the element is marked as loading.\n      The function must return a promise.\n      Once the promise resolves, the element will be [marked as no longer loading](/up.feedback.stop).\n    @internal\n     */\n    start = function() {\n      var $element, action, args, elementOrSelector, options, promise;\n      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n      elementOrSelector = args.shift();\n      action = args.pop();\n      options = u.options(args[0]);\n      $element = findActivatableArea(elementOrSelector);\n      if (!options.preload) {\n        $element.addClass(CLASS_ACTIVE);\n      }\n      if (action) {\n        promise = action();\n        if (u.isPromise(promise)) {\n          u.always(promise, function() {\n            return stop($element);\n          });\n        } else {\n          up.warn('Expected block to return a promise, but got %o', promise);\n        }\n        return promise;\n      }\n    };\n\n    /***\n    Links that are currently [loading through Unpoly](/form-up-target)\n    are assigned the `up-active` class automatically.\n    Style `.up-active` in your CSS to improve the perceived responsiveness\n    of your user interface.\n    \n    The `up-active` class will be removed when the link is done loading.\n    \n    \\#\\#\\# Example\n    \n    We have a link:\n    \n        <a href=\"/foo\" up-follow>Foo</a>\n    \n    The user clicks on the link. While the request is loading,\n    the link has the `up-active` class:\n    \n        <a href=\"/foo\" up-follow class=\"up-active\">Foo</a>\n    \n    Once the link destination has loaded and rendered, the `up-active` class\n    is removed and the [`up-current`](/a.up-current) class is added:\n    \n        <a href=\"/foo\" up-follow class=\"up-current\">Foo</a>\n    \n    @selector a.up-active\n    @stable\n     */\n\n    /***\n    Forms that are currently [loading through Unpoly](/a-up-target)\n    are assigned the `up-active` class automatically.\n    Style `.up-active` in your CSS to improve the perceived responsiveness\n    of your user interface.\n    \n    The `up-active` class will be removed as soon as the response to the\n    form submission has been received.\n    \n    \\#\\#\\# Example\n    \n    We have a form:\n    \n        <form up-target=\".foo\">\n          <button type=\"submit\">Submit</button>\n        </form>\n    \n    The user clicks on the submit button. While the form is being submitted\n    and waiting for the server to respond, the form has the `up-active` class:\n    \n        <form up-target=\".foo\" class=\"up-active\">\n          <button type=\"submit\">Submit</button>\n        </form>\n    \n    Once the link destination has loaded and rendered, the `up-active` class\n    is removed.\n    \n    @selector form.up-active\n    @stable\n     */\n\n    /***\n    Marks the given element as no longer loading, by removing the CSS class [`up-active`](/a.up-active).\n    \n    This happens automatically when network requests initiated by the Unpoly API have completed.\n    Use this function if you make custom network calls from your own JavaScript code.\n    \n    @function up.feedback.stop\n    @param {jQuery} event.$element\n      The link or form that has finished loading.\n    @internal\n     */\n    stop = function(elementOrSelector) {\n      var $element;\n      $element = findActivatableArea(elementOrSelector);\n      return $element.removeClass(CLASS_ACTIVE);\n    };\n\n    /***\n    Marks this element as a navigation component, such as a menu or navigation bar.\n    \n    When a link within an `[up-nav]` element points to the current location, it is assigned the `.up-current` class. When the browser navigates to another location, the class is removed automatically.\n    \n    You may also assign `[up-nav]` to an individual link instead of an navigational container.\n    \n    If you don't want to manually add this attribute to every navigational element, you can configure selectors to automatically match your navigation components in [`up.feedback.config.navs`](/up.feedback.config#config.navs).\n    \n    \n    \\#\\#\\# Example\n    \n    Let's take a simple menu with two links. The menu has been marked with the `[up-nav]` attribute:\n    \n        <div up-nav>\n          <a href=\"/foo\">Foo</a>\n          <a href=\"/bar\">Bar</a>\n        </div>\n    \n    If the browser location changes to `/foo`, the first link is marked as `.up-current`:\n    \n        <div up-nav>\n          <a href=\"/foo\" class=\"up-current\">Foo</a>\n          <a href=\"/bar\">Bar</a>\n        </div>\n    \n    If the browser location changes to `/bar`, the first link automatically loses its `.up-current` class. Now the second link is marked as `.up-current`:\n    \n        <div up-nav>\n          <a href=\"/foo\">Foo</a>\n          <a href=\"/bar\" class=\"up-current\">Bar</a>\n        </div>\n    \n    \n    \\#\\#\\# What is considered to be \"current\"?\n    \n    The current location is considered to be either:\n    \n    - the URL displayed in the browser window's location bar\n    - the source URL of a [modal dialog](/up.modal)\n    - the URL of the page behind a [modal dialog](/up.modal)\n    - the source URL of a [popup overlay](/up.popup)\n    - the URL of the content behind a [popup overlay](/up.popup)\n    \n    A link matches the current location (and is marked as `.up-current`) if it matches either:\n    \n    - the link's `href` attribute\n    - the link's `up-href` attribute\n    - a space-separated list of URLs in the link's `up-alias` attribute\n    \n    \\#\\#\\# Matching URL by prefix\n    \n    You can mark a link as `.up-current` whenever the current URL matches a prefix.\n    To do so, end the `up-alias` attribute in an asterisk (`*`).\n    \n    For instance, the following `[up-nav]` link is highlighted for both `/reports` and `/reports/123`:\n    \n        <a up-nav href=\"/reports\" up-alias=\"/reports/*\">Reports</a>\n    \n    @selector [up-nav]\n    @stable\n     */\n\n    /***\n    When a link within an `[up-nav]` element points to the current location, it is assigned the `.up-current` class.\n    \n    See [`[up-nav]`](/up-nav) for more documentation and examples.\n    \n    @selector [up-nav] a.up-current\n    @stable\n     */\n    up.on('up:history:pushed up:history:replaced up:history:restored up:modal:opened up:modal:closed up:popup:opened up:popup:closed', function(event) {\n      return updateAllNavigationSectionsIfLocationChanged();\n    });\n    up.on('up:fragment:inserted', function(event, $newFragment) {\n      return updateNavigationSectionsInNewFragment($newFragment);\n    });\n    up.on('up:framework:reset', reset);\n    return {\n      config: config,\n      start: start,\n      stop: stop\n    };\n  })(jQuery);\n\n  up.deprecateRenamedModule('navigation', 'feedback');\n\n}).call(this);\n\n/***\nPassive updates\n===============\n\nThis work-in-progress package will contain functionality to\npassively receive updates from the server.\n\n@class up.radio\n */\n\n(function() {\n  up.radio = (function($) {\n    var config, hungrySelector, reset, u;\n    u = up.util;\n\n    /***\n    Configures defaults for passive updates.\n    \n    @property up.radio.config\n    @param {Array<string>} [options.hungry]\n      An array of CSS selectors that is replaced whenever a matching element is found in a response.\n      These elements are replaced even when they were not targeted directly.\n    \n      By default this contains the [`[up-hungry]`](/up-hungry) attribute.\n    @param {string} [options.hungryTransition=null]\n      The transition to use when a [hungry element](/up-hungry) is replacing itself\n      while another target is replaced.\n    \n      By default this is not set and the original replacement's transition is used.\n    @stable\n     */\n    config = u.config({\n      hungry: ['[up-hungry]'],\n      hungryTransition: null\n    });\n    reset = function() {\n      return config.reset();\n    };\n\n    /***\n    @function up.radio.hungrySelector\n    @internal\n     */\n    hungrySelector = function() {\n      return config.hungry.join(',');\n    };\n\n    /***\n    Elements with this attribute are [updated](/up.replace) whenever there is a\n    matching element found in a successful response. The element is replaced even\n    when it isn't [targeted](/a-up-target) directly.\n    \n    Use cases for this are unread message counters or notification flashes.\n    Such elements often live in the layout, outside of the content area that is\n    being replaced.\n    \n    @selector [up-hungry]\n    @stable\n     */\n    up.on('up:framework:reset', reset);\n    return {\n      config: config,\n      hungrySelector: hungrySelector\n    };\n  })(jQuery);\n\n}).call(this);\n\n/***\nPlay nice with Rails UJS\n========================\n */\n\n(function() {\n  up.rails = (function($) {\n    var isRails, u;\n    u = up.util;\n    isRails = function() {\n      return !!$.rails;\n    };\n    return u.each(['method', 'confirm'], function(feature) {\n      var dataAttribute, upAttribute;\n      dataAttribute = \"data-\" + feature;\n      upAttribute = \"up-\" + feature;\n      return up.macro(\"[\" + dataAttribute + \"]\", function($element) {\n        var replacement;\n        if (isRails() && up.link.isFollowable($element)) {\n          replacement = {};\n          replacement[upAttribute] = $element.attr(dataAttribute);\n          u.setMissingAttrs($element, replacement);\n          return $element.removeAttr(dataAttribute);\n        }\n      });\n    });\n  })(jQuery);\n\n}).call(this);\n(function() {\n  up.boot();\n\n}).call(this);\n\n\n//# sourceURL=webpack://Presto/./node_modules/unpoly/dist/unpoly.js?");

/***/ })

/******/ });
});